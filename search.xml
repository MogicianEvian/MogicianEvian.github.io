<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CTSC2018 混合果汁（整体二分+线段树）]]></title>
    <url>%2F2018%2F09%2F14%2FCTSC2018-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%EF%BC%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述小 R 热衷于做黑暗料理，尤其是混合果汁。 商店里有 $n$ 种果汁，编号为 $0, 1, 2, . . . , n − 1$。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。 现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。 输入格式输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为$p_i$，在一瓶果汁中的添加上限为 $l_i$。 接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。 输出格式对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $−1$。 样例输入123456783 41 3 52 1 33 2 56 35 310 1020 10 样例输出123432-11 提示对于所有的测试数据，保证 $n, m \le 100000$，$1 \le d_i, p_i, l_i \le 10^5，1 \le g_j, L_j \le 10^{18}$。 测试点编号 $n=$ $m=$ 其他限制 $1,2,3$ $10$ $10$ 无 $4,5,6$ $500$ $500$ 无 $7,8,9$ $5000$ $5000$ 无 $10,11,12$ $100000$ $100000$ $p_i=1$ $13,14,15$ $100000$ $100000$ $l_i=1$ $16,17,18,19,20$ $100000$ $100000$ 无 容易想到对询问二分答案，那么只能选择美味度大于 $mid$ 的果汁，然后就贪心的选便宜的就行了，这个贪心可以用线段树完成，按价格建线段树，然后记录每个价格的可用体积，查询就在线段树上二分即可得到最低价格 处理多次询问考虑整体二分，这里跟 $Meteors$ 那题很像，整体二分过程中维护一颗全局线段树就行了 复杂度 $O(n\log^2n)$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005#define ll long longusing namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline ll _R()&#123; char t=GC;ll x=0; while(t&lt;48||t&gt;57)t=GC; for(;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;struct juice&#123;ll p,l;int d;&#125;A[N];struct query&#123;ll g,l;int id;&#125;Q[N],q[N];bool operator&lt;(juice a,juice b)&#123;return a.d&gt;b.d;&#125;int n,m,Ans[N],cur;struct node&#123; node *ls,*rs; ll suml,sump;&#125;seg[N&lt;&lt;1],*rt,*tl,*null;void Init()&#123; rt=tl=null=seg; null-&gt;ls=null-&gt;rs=null;&#125;void build(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;ls=p-&gt;rs=null; if(l==r)return; int mid=l+r&gt;&gt;1; build(p-&gt;ls,l,mid); build(p-&gt;rs,mid+1,r);&#125;void update(node *p)&#123; node *l=p-&gt;ls,*r=p-&gt;rs; p-&gt;sump=l-&gt;sump+r-&gt;sump; p-&gt;suml=l-&gt;suml+r-&gt;suml;&#125;void modify(node *p,int l,int r,int k,ll d)&#123; if(l==r)&#123;p-&gt;suml+=d;p-&gt;sump=p-&gt;suml*l;return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)modify(p-&gt;ls,l,mid,k,d); else modify(p-&gt;rs,mid+1,r,k,d); update(p);&#125;ll getmin(node *p,int l,int r,ll d)&#123; if(d==0)return 0; if(l==r)return d*l; int mid=l+r&gt;&gt;1; if(p-&gt;ls-&gt;suml&gt;=d)return getmin(p-&gt;ls,l,mid,d); return p-&gt;ls-&gt;sump+getmin(p-&gt;rs,mid+1,r,d-p-&gt;ls-&gt;suml);&#125;void solve(int l,int r,int ql,int qr)&#123; if(ql&gt;qr)return; if(l==r&amp;&amp;r!=n)&#123;for(int i=ql;i&lt;=qr;i++)Ans[Q[i].id]=A[l].d;return;&#125; int mid=l+r&gt;&gt;1,pl=ql-1,pr=qr+1; while(cur&lt;mid)cur++,modify(rt,1,1e5,A[cur].p,A[cur].l); while(cur&gt;mid)modify(rt,1,1e5,A[cur].p,-A[cur].l),cur--; for(int i=ql;i&lt;=qr;i++)q[i]=Q[i]; for(int i=ql;i&lt;=qr;i++) &#123; if(q[i].l&gt;rt-&gt;suml)Q[--pr]=q[i]; else if(getmin(rt,1,1e5,q[i].l)&lt;=q[i].g)Q[++pl]=q[i]; else Q[--pr]=q[i]; &#125; if(l==r) &#123; for(int i=ql;i&lt;=pl;i++)Ans[Q[i].id]=A[l].d; for(int i=pr;i&lt;=qr;i++)Ans[Q[i].id]=-1;return; &#125; solve(l,mid,ql,pl);solve(mid+1,r,pr,qr);&#125;int main()&#123; int i,j,k,x,y,z; n=_R();m=_R(); for(i=1;i&lt;=n;i++)A[i].d=_R(),A[i].p=_R(),A[i].l=_R(); for(i=1;i&lt;=m;i++)Q[i].g=_R(),Q[i].l=_R(),Q[i].id=i; sort(A+1,A+n+1); Init();build(rt,1,1e5); solve(1,n,1,m); for(i=1;i&lt;=m;i++)printf("%d\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>分治法</category>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LibreOJ β Round」ZQC 的手办（线段树+堆）]]></title>
    <url>%2F2018%2F09%2F14%2F%E3%80%8CLibreOJ-%CE%B2-Round%E3%80%8DZQC-%E7%9A%84%E6%89%8B%E5%8A%9E%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述众所周知，ZQC 是个很喜欢收纳手办的大佬，他平时在写题前会先扫视一下桌面上排开的小姐姐们以获取灵感。假设他有 $ n(1 \leq n \leq 5\times 10 ^ 5) $ 个手办，小手办们排成一排，每个手办按照入手批次从第 $ 1 $ 个到第 $ n $ 个被贴上了一个标号 $ a_i(1 \leq a_i \leq 10 ^ 9) $。有两个熊孩子到 ZQC 家里玩，熊孩子 A 不断地改掉标签并不停地提问熊孩子 B。由于熊孩子 B 太笨，经常回答不上来，熊孩子 A 表示很生气，ZQC 为了世界和平（把熊孩子哄高兴好让它们帮忙把标签贴回去），大发慈悲地帮助熊孩子 B 回答一系列问题。假设一共 $ m(1 \leq m \leq 5\times 10 ^ 5) $ 次操作，两种操作分别为： $ \texttt{1 a b k} $ 将数列 $ [a, b] $ 这个区间中所有比 $ k(1 \leq k \leq 10 ^ 9) $ 小的数改为 $ k $； $ \texttt{2 a b k x} $ 查询 $ [a, b] $ 的区间中比 $ k(1 \leq k \leq 10 ^ 9) $ 小的最小的 $ x(1 \leq x \leq 10^5) $ 个数。 ZQC 最后成功维护了世界正义，请在每次查询时输出熊孩子 A 所要的回答。 输入格式第一行为 $ n $，表示手办总数。接下来一行 $ n $ 个数 $a_1,a_2,…,a_n$，$ a_i $ 表示第 $i$ 个手办的标号。接下来一行为 $ m $，表示总操作数。接下来 $ m $ 行，格式见「题目描述」。 输出格式对于每次查询，输出一行 $ x $ 个数，每个数中间以空格间隔，按从小到大顺序排列；如果区间内小于 $ k $ 的数不足 $ x $ 个，输出 $ -1 $。 样例输入123456731 2 341 1 2 22 1 3 1 32 1 3 2 12 1 3 3 2 样例输出123-1-12 2 样例解释开始序列为 ${1,2,3}$；第一次操作修改后的序列为 ${2,2,3}$；第二次操作查询时，区间内最小的 $3$ 个数依次为 $2,2,3$，因为 $3$ 不小于 $1$ 所以答案为 $-1$；第三次操作查询时，区间内最小的 $1$ 个数为 $2$，因为 $2$ 不小于 $2$ 所以答案为 $-1$；第四次操作查询时，区间内最小的 $2$ 个数依次为 $2,2$，因为 $2$ 小于 $3$ 所以答案为 $2,2$。 提示$\sum{x}\leq 5\times 10^6$输出总数量不超过 $2\times 10^6$ 个整数，包括 $-1$。 出题人的关怀：由于输入规模较大，建议使用读入优化。 注意到 $\sum x\leq5\times10^6$ 考虑用线段树维护区间最小值和最小值的位置，用堆来暴力处理查询，即先将区间最小值加到堆中，取出后拆成两个区间，分别将两个子区间的区间最小值加进去，这样操作 $x$ 次即可 复杂度为 $O(\log n\sum x)$ 修改操作直接打 $lazy$ 就行了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 500005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x=0; while(t&lt;48||t&gt;57)t=GC; for(;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;struct minn&#123;int v,x;&#125;;struct data&#123;int l,r;minn v;&#125;;bool operator&lt;(data a,data b)&#123;return a.v.v&gt;b.v.v;&#125;int n,a[N],m,ans[N],tp;struct node&#123; node *ls,*rs; int Min,pos,lazy;&#125;seg[N&lt;&lt;1],*rt,*tl,*null;void Init()&#123; rt=tl=null=seg; null-&gt;ls=null-&gt;rs=null;&#125;void update(node *p)&#123; node *l=p-&gt;ls,*r=p-&gt;rs; if(l-&gt;Min&lt;r-&gt;Min)p-&gt;Min=l-&gt;Min,p-&gt;pos=l-&gt;pos; else p-&gt;Min=r-&gt;Min,p-&gt;pos=r-&gt;pos;&#125;void build(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;ls=p-&gt;rs=null; if(l==r)&#123;p-&gt;Min=a[l];p-&gt;pos=l;return;&#125; int mid=l+r&gt;&gt;1; build(p-&gt;ls,l,mid); build(p-&gt;rs,mid+1,r); update(p);&#125;void putdown(node *p)&#123; node *l=p-&gt;ls,*r=p-&gt;rs; int d=p-&gt;lazy;p-&gt;lazy=0; l-&gt;Min=max(l-&gt;Min,d); l-&gt;lazy=max(l-&gt;lazy,d); r-&gt;Min=max(r-&gt;Min,d); r-&gt;lazy=max(r-&gt;lazy,d);&#125;void modify(node *p,int l,int r,int x,int y,int d)&#123; if(p-&gt;Min&gt;=d)return; if(p-&gt;lazy)putdown(p); if(x&lt;=l&amp;&amp;y&gt;=r) &#123; p-&gt;Min=max(p-&gt;Min,d); p-&gt;lazy=max(p-&gt;lazy,d); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)modify(p-&gt;ls,l,mid,x,y,d); if(y&gt;mid)modify(p-&gt;rs,mid+1,r,x,y,d); update(p);&#125;minn getmin(node *p,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)return (minn)&#123;p-&gt;Min,p-&gt;pos&#125;; if(p-&gt;lazy)putdown(p); int mid=l+r&gt;&gt;1;minn tl,tr; if(x&gt;mid)return getmin(p-&gt;rs,mid+1,r,x,y); if(y&lt;=mid)return getmin(p-&gt;ls,l,mid,x,y); tl=getmin(p-&gt;ls,l,mid,x,y); tr=getmin(p-&gt;rs,mid+1,r,x,y); return tl.v&lt;tr.v?tl:tr;&#125;int main()&#123; int i,j,k,x,y,z; n=_R(); for(i=1;i&lt;=n;i++)a[i]=_R(); Init();build(rt,1,n); m=_R(); for(i=1;i&lt;=m;i++) &#123; j=_R(); if(j==1) &#123; x=_R();y=_R();z=_R(); modify(rt,1,n,x,y,z); &#125; else &#123; x=_R();y=_R();k=_R();z=_R(); priority_queue&lt;data&gt;Q;tp=0; Q.push((data)&#123;x,y,getmin(rt,1,n,x,y)&#125;); while(Q.size()&amp;&amp;tp&lt;z) &#123; data tmp=Q.top();Q.pop(); if(tmp.v.v&gt;=k)break; ans[++tp]=tmp.v.v; if(tmp.v.x&gt;tmp.l)Q.push((data)&#123;tmp.l,tmp.v.x-1,getmin(rt,1,n,tmp.l,tmp.v.x-1)&#125;); if(tmp.v.x&lt;tmp.r)Q.push((data)&#123;tmp.v.x+1,tmp.r,getmin(rt,1,n,tmp.v.x+1,tmp.r)&#125;); &#125; if(tp&lt;z)printf("-1"); else for(k=1;k&lt;=tp;k++)printf("%d ",ans[k]); puts(""); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THUWC2017 在美妙的数学王国中畅游（LCT）]]></title>
    <url>%2F2018%2F09%2F14%2FTHUWC2017-%E5%9C%A8%E7%BE%8E%E5%A6%99%E7%9A%84%E6%95%B0%E5%AD%A6%E7%8E%8B%E5%9B%BD%E4%B8%AD%E7%95%85%E6%B8%B8%EF%BC%88LCT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述数字和数学规律主宰着这个世界。 机器的运转， 生命的消长， 宇宙的进程， 这些神秘而又美妙的过程无不可以用数学的语言展现出来。 这印证了一句古老的名言： “学好数理化，走遍天下都不怕。” 学渣小R被大学的数学课程虐得生活不能自理，微积分的成绩曾是他在教室里上的课的最低分。然而他的某位陈姓室友却能轻松地在数学考试中得到满分。为了提升自己的数学课成绩，有一天晚上（在他睡觉的时候），他来到了数学王国。 数学王国中，每个人的智商可以用一个属于 $[0,1]$ 的实数表示。数学王国中有 $n$ 个城市，编号从 $0$ 到 $n-1$ ，这些城市由若干座魔法桥连接。每个城市的中心都有一个魔法球，每个魔法球中藏有一道数学题。每个人在做完这道数学题之后都会得到一个在 $[0,1]$ 区间内的分数。一道题可以用一个从 $[0,1]$ 映射到 $[0,1]$ 的函数 $f(x)$ 表示。若一个人的智商为 $x$ ，则他做完这道数学题之后会得到 $f(x)$ 分。函数 $f$ 有三种形式： 正弦函数 $\sin(a x + b)\ (a \in [0,1], b \in [0,\pi],a+b\in[0,\pi])$ 指数函数 $e^{ax+b}\ (a\in [-1,1], b\in [-2,0], a+b\in [-2,0])$ 一次函数 $ax + b\ (a\in [-1,1],b\in[0,1],a+b\in [0,1])$ 数学王国中的魔法桥会发生变化，有时会有一座魔法桥消失，有时会有一座魔法桥出现。但在任意时刻，只存在至多一条连接任意两个城市的简单路径（即所有城市形成一个森林）。在初始情况下，数学王国中不存在任何的魔法桥。 数学王国的国王拉格朗日很乐意传授小R数学知识，但前提是小R要先回答国王的问题。这些问题具有相同的形式，即一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$ （即经过 $u$ 到 $v$ 这条路径上的所有城市，包括 $u$ 和 $v$ ）且做了所有城市内的数学题后，他所有得分的总和是多少。 输入格式第一行两个正整数 $n,m$ 和一个字符串 $type$ 。表示数学王国中共有 $n$ 座城市，发生了 $m$ 个事件，该数据的类型为 $type$ 。 $type$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入。其具体含义在【数据范围与提示】中有解释。 接下来 $n$ 行，第 $i$ 行表示初始情况下编号为 $i$ 的城市的魔法球中的函数。一个魔法用一个整数 $f$ 表示函数的类型，两个实数 $a,b$ 表示函数的参数，若 $f=1$ ,则函数为 $f(x)=\sin(ax+b)(a \in [0,1], b \in [0,\pi],a+b\in[0,\pi])$ $f=2$ ,则函数为 $f(x)=e^{ax+b}(a\in[-1,1],b\in[-2,0],a+b\in[-2,0])$ $f=3$ ,则函数为 $f(x)=ax+b(a\in[-1,1],b\in[0,1],a+b\in[0,1])$ 接下来 $m$ 行，每行描述一个事件，事件分为四类。 appear u v 表示数学王国中出现了一条连接 $u$ 和 $v$ 这两座城市的魔法桥 $(0\le u,v &lt; n, u\ne v)$ ，保证连接前 $u$ 和 $v$ 这两座城市不能互相到达。 disappear u v 表示数学王国中连接 $u$ 和 $v$ 这两座城市的魔法桥消失了，保证这座魔法桥是存在的。 magic c f a b 表示城市 $c$ 的魔法球中的魔法变成了类型为 $f$ ，参数为 $a,b$ 的函数 travel u v x 表示询问一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$ （即经过 $u$ 到 $v$ 这条路径上的所有城市，包括 $u$ 和 $v$ ）后，他得分的总和是多少。若无法从 $u$ 到达 $v$ ，则输出一行一个字符串 unreachable。 输出格式对于每个询问，输出一行实数，表示得分的总和。 样例输入12345678910113 7 C11 1 03 0.5 0.53 -0.5 0.7appear 0 1travel 0 1 0.3appear 0 2travel 1 2 0.5disappear 0 1appear 1 2travel 1 2 0.5 样例输出1239.45520207e-0011.67942554e+0001.20000000e+000 提示【小R教你学数学】若函数 $f(x)$ 的 $n$ 阶导数在 $[a,b]$ 区间内连续，则对 $f(x)$ 在 $x_0(x_0\in[a,b])$ 处使用 $n$ 次拉格朗日中值定理可以得到带拉格朗日余项的泰勒展开式 $f(x)=f(x_0)+\frac{f’(x_0)(x-x_0)}{1!}+\frac{f’’(x_0)(x-x_0)^2}{2!}+ \cdots +\frac{f^{(n-1)}(x_0)(x-x_0)^{n-1}}{(n-1)!}+\frac{f^{(n)}(\xi)(x-x_0)^n}{n!},x\in[a,b]$ 其中，当 $x&gt;x_0$ 时，$\xi\in[x_0,x]$。当 $x&lt;x_0$ 时，$\xi\in[x,x_0]$。 $f^{(n)}$表示函数 $f$ 的 $n$ 阶导数 【数据范围】对于 $100\%$ 的数据，$1\leq n \leq 100000, 1\leq m \leq 200000$ 。 本题共有20个数据点，每个数据点5分。 对于 $5\%$ 的数据，$n\le 100,m\le 2000$，数据类型为C1；对于另外 $20\%$ 的数据，数据类型为A0；对于另外 $5\%$ 的数据，数据类型为B0；对于另外 $10\%$ 的数据，数据类型为D0；对于另外 $30\%$ 的数据，数据类型为A1；对于另外 $15\%$ 的数据，数据类型为C1； 数据类型的含义： A：不存在 disappear 事件，且所有appear事件中的 $u=v-1$ B：不存在 disappear 事件 C：所有的 travel 事件经过的城市总数 $\leq 5000000$（不可到达的城市对不计入在内） D：无限制 0：所有 travel 事件中，$x=1$（即所有人的智商均为 $1$ ） 1：无限制 【评分标准】如果你的答案与标准答案的相对误差在 $10^{-7}$ 以内或绝对误差在 $10^{-7}$ 以内，则被判定为正确。 如果你的所有答案均为正确，则得满分，否则得0分。 请注意输出格式：每行输出一个答案，答案只能为 unreachable 或者一个实数（建议使用科学计数法表示）。每行的长度不得超过50。错误输出格式会被判定为0分。 提示里已经将做法点明了，直接将题给的函数在 $x_0=0$ 处展开成一个多项式，然后就可以直接上 $LCT$ 维护了 注意到展开位数越多则精度越高，但运行速度越慢，所以展开十几位就差不多了 剩下的都是 $LCT$ 的基本操作了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 100005#define db doubleusing namespace std;const int K=11;struct poly&#123;db a[K];&#125;v[N],sum[N];poly operator+(poly a,poly b)&#123; poly c; for(int i=0;i&lt;K;i++)c.a[i]=a.a[i]+b.a[i]; return c;&#125;db getval(poly a,db x)&#123; db sum=0,t=1.0; for(int i=0;i&lt;K;i++,t*=x)sum+=a.a[i]*t; return sum;&#125;poly trans(int f,db a,db b)&#123; poly c; if(f==1) &#123; db S=sin(b),C=cos(b),t=1.0; for(int i=0;i&lt;K;i++,t=t/i*a) &#123; if(i&amp;1)c.a[i]=((i&amp;3)==1)?t*C:-t*C; else c.a[i]=((i&amp;3)==0)?t*S:-t*S; &#125; return c; &#125; if(f==2) &#123; db t=exp(b); for(int i=0;i&lt;K;i++,t=t/i*a)c.a[i]=t; return c; &#125; if(f==3) &#123; memset(c.a,0,sizeof(c.a)); c.a[0]=b;c.a[1]=a;return c; &#125;&#125;int n,m,ls[N],rs[N],fa[N],tot,rt,rev[N],S[N],tp;bool isroot(int x)&#123;return ls[fa[x]]!=x&amp;&amp;rs[fa[x]]!=x;&#125;void update(int x)&#123;sum[x]=v[x]+sum[ls[x]]+sum[rs[x]];&#125;void zig(int x)&#123; int y=fa[x],z=fa[y]; if(!isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; update(y);update(x);&#125;void zag(int x)&#123; int y=fa[x],z=fa[y]; if(!isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; update(y);update(x);&#125;void putdown(int x)&#123; if(rev[x]) &#123; swap(ls[x],rs[x]); rev[ls[x]]^=1; rev[rs[x]]^=1; rev[x]=0; &#125;&#125;void splay(int x)&#123; int i,y,z;S[tp=1]=x; for(i=x;!isroot(i);i=fa[i])S[++tp]=fa[i]; while(tp)putdown(S[tp--]); while(!isroot(x)) &#123; y=fa[x],z=fa[y]; if(!isroot(y)) &#123; if(y==ls[z])x==ls[y]?(zig(y),zig(x)):(zag(x),zig(x)); else x==rs[y]?(zag(y),zag(x)):(zig(x),zag(x)); &#125; else x==ls[y]?zig(x):zag(x); &#125;&#125;void access(int x)&#123; for(int t=0;x;x=fa[x]) &#123; splay(x); rs[x]=t; update(x);t=x; &#125;&#125;void makeroot(int x)&#123; access(x); splay(x); rev[x]^=1;&#125;int findroot(int x)&#123; access(x); splay(x); while(ls[x])x=ls[x]; return x;&#125;void link(int x,int y)&#123; makeroot(x); fa[x]=y;&#125;void cut(int x,int y)&#123; makeroot(x); access(y); splay(y); ls[y]=fa[x]=0;&#125;void modify(int x,poly d)&#123; makeroot(x); splay(x); v[x]=d;update(x);&#125;db getans(int x,int y,db d)&#123; makeroot(x); access(y); splay(y); return getval(sum[y],d);&#125;int main()&#123; int i,j,k,x,y;double a,b,d;char s[12]; scanf("%d%d%s",&amp;n,&amp;m,s); for(i=1;i&lt;=n;i++) &#123; scanf("%d%lf%lf",&amp;k,&amp;a,&amp;b); v[i]=sum[i]=trans(k,a,b); &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%s",s); if(s[0]=='a') &#123; scanf("%d%d",&amp;x,&amp;y); link(x+1,y+1); &#125; if(s[0]=='d') &#123; scanf("%d%d",&amp;x,&amp;y); cut(x+1,y+1); &#125; if(s[0]=='m') &#123; scanf("%d%d%lf%lf",&amp;x,&amp;k,&amp;a,&amp;b); modify(x+1,trans(k,a,b)); &#125; if(s[0]=='t') &#123; scanf("%d%d%lf",&amp;x,&amp;y,&amp;d); if(findroot(x+1)==findroot(y+1))printf("%.10lf\n",getans(x+1,y+1,d)); else puts("unreachable"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2015 脑洞治疗仪（线段树）]]></title>
    <url>%2F2018%2F09%2F14%2FSHOI2015-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述曾经发明了自动刷题机的发明家 SHTSC 又公开了他的新发明：脑洞治疗仪——一种可以治疗他因为发明而日益增大的脑洞的神秘装置。 为了简单起见，我们将大脑视作一个 01 序列。$1$ 代表这个位置的脑组织正常工作，$0$ 代表这是一块脑洞。 1010001110 脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？） 例如，用上面第 $8$ 号位置到第 $10$ 号位置去修补第 $1$ 号位置到第 $4$ 号位置的脑洞，我们就会得到： 1111001000 如果再用第 $1$ 号位置到第 $4$ 号位置去修补第 $8$ 号位置到第 $10$ 号位置： 0000001111这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。 如果再用第 $7$ 号位置到第 $10$ 号位置去填补第 $1$ 号位置到第 $6$ 号位置： 1111000000这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。 假定初始时 SHTSC 并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答 SHTSC 的问题：在大脑某个区间中最大的连续脑洞区域有多大。 输入格式第一行两个整数 $n$、$m$，表示 SHTSC 的大脑可分为从 $1$ 到 $n$ 编号的 $n$ 个连续区域，有 $m$ 个操作。 以下 $m$ 行每行是下列三种格式之一： $0\quad l\quad r$：SHTSC 挖了一个范围为 $[l, r]$ 的脑洞。 $1\quad l_0\quad r_0\quad l_1\quad r_1$：SHTSC 进行了一次脑洞治疗，用从 $l_0$ 到 $r_0$ 的脑组织修补 $l_1$ 到 $r_1$ 的脑洞。 $2\quad l\quad r$：SHTSC 询问 $[l, r]$ 区间内最大的脑洞有多大。 上述区间均在 $[1, n]$ 范围内。 输出格式对于每个询问，输出一行一个整数，表示询问区间内最大连续脑洞区域有多大。 样例输入123456789101110 100 2 20 4 60 10 102 1 101 8 10 1 42 1 101 1 4 8 102 1 101 7 10 1 62 1 10 样例输出12343366 提示对于 $20\%$ 的数据，$n, m \leq 100$；对于 $50\%$ 的数据，$n, m \leq 20000$；对于 $100\%$ 的数据，$n, m \leq 200000$。 唯一特殊的操作就是治疗操作，但是容易发现，只需要先查询 $[l_0,r_0]$ 的脑组织数量，填的时候就是先填左边，再填右边，如果当前区间能填完，就打个区间覆盖标记然后返回，或者脑组织填完了也返回，容易发现这样复杂度就是一个 $\log $ 的了 剩下的就只需要写一个维护区间最大连续0的线段树就好了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x=0; while(t&lt;48||t&gt;57)t=GC; for(;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;int n,m;struct data&#123;int Lmax,Rmax,Max,sum,len;&#125;;data operator+(data a,data b)&#123; data c=(data)&#123;0,0,0,0&#125;; if(a.sum==a.len)c.Lmax=a.len+b.Lmax; else c.Lmax=a.Lmax; if(b.sum==b.len)c.Rmax=b.len+a.Rmax; else c.Rmax=b.Rmax; c.Max=max(max(a.Max,b.Max),a.Rmax+b.Lmax); c.sum=a.sum+b.sum; c.len=a.len+b.len; return c;&#125;struct node&#123; node *ls,*rs; data v;int lazy;&#125;seg[N&lt;&lt;1],*rt,*tl,*null;void Init()&#123; rt=tl=null=seg;null-&gt;lazy=-1; null-&gt;ls=null-&gt;rs=null;&#125;void build(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;lazy=-1; p-&gt;ls=p-&gt;rs=null; if(l==r)&#123;p-&gt;v=(data)&#123;0,0,0,0,1&#125;;return;&#125; int mid=l+r&gt;&gt;1; build(p-&gt;ls,l,mid); build(p-&gt;rs,mid+1,r); p-&gt;v=p-&gt;ls-&gt;v+p-&gt;rs-&gt;v;&#125;void putdown(node *p)&#123; node *l=p-&gt;ls,*r=p-&gt;rs; l-&gt;lazy=r-&gt;lazy=p-&gt;lazy; int dl=l-&gt;v.len,dr=r-&gt;v.len; if(p-&gt;lazy==1) &#123; l-&gt;v=(data)&#123;0,0,0,0,dl&#125;; r-&gt;v=(data)&#123;0,0,0,0,dr&#125;; &#125; else &#123; l-&gt;v=(data)&#123;dl,dl,dl,dl,dl&#125;; r-&gt;v=(data)&#123;dr,dr,dr,dr,dr&#125;; &#125; p-&gt;lazy=-1;&#125;void cover(node *p,int l,int r,int x,int y)&#123; if(p-&gt;lazy!=-1)putdown(p); if(x&lt;=l&amp;&amp;y&gt;=r) &#123; int d=p-&gt;v.len; p-&gt;v=(data)&#123;d,d,d,d,d&#125;; p-&gt;lazy=0;return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)cover(p-&gt;ls,l,mid,x,y); if(y&gt;mid)cover(p-&gt;rs,mid+1,r,x,y); p-&gt;v=p-&gt;ls-&gt;v+p-&gt;rs-&gt;v;&#125;int repair(node *p,int l,int r,int x,int y,int d)&#123; if(p-&gt;lazy!=-1)putdown(p); if(d==0)return 0; if(x&lt;=l&amp;&amp;y&gt;=r&amp;&amp;d&gt;=p-&gt;v.sum) &#123; int d=p-&gt;v.sum; p-&gt;v=(data)&#123;0,0,0,0,r-l+1&#125;; p-&gt;lazy=1;return d; &#125; int mid=l+r&gt;&gt;1,sum=0; if(x&lt;=mid)sum+=repair(p-&gt;ls,l,mid,x,y,d); if(y&gt;mid)sum+=repair(p-&gt;rs,mid+1,r,x,y,d-sum); p-&gt;v=p-&gt;ls-&gt;v+p-&gt;rs-&gt;v; return sum;&#125;int getsum(node *p,int l,int r,int x,int y)&#123; if(p-&gt;lazy!=-1)putdown(p); if(x&lt;=l&amp;&amp;y&gt;=r)return p-&gt;v.sum; int mid=l+r&gt;&gt;1,sum=0; if(x&lt;=mid)sum+=getsum(p-&gt;ls,l,mid,x,y); if(y&gt;mid)sum+=getsum(p-&gt;rs,mid+1,r,x,y); return sum;&#125;data getmax(node *p,int l,int r,int x,int y)&#123; if(p-&gt;lazy!=-1)putdown(p); if(x&lt;=l&amp;&amp;y&gt;=r)return p-&gt;v; int mid=l+r&gt;&gt;1; if(x&gt;mid)return getmax(p-&gt;rs,mid+1,r,x,y); if(y&lt;=mid)return getmax(p-&gt;ls,l,mid,x,y); return getmax(p-&gt;ls,l,mid,x,y)+getmax(p-&gt;rs,mid+1,r,x,y);&#125;int main()&#123; int i,j,k,x,y,a,b; n=_R();m=_R(); Init();build(rt,1,n); for(i=1;i&lt;=m;i++) &#123; k=_R();x=_R();y=_R(); if(k==0)cover(rt,1,n,x,y); if(k==1) &#123; a=_R();b=_R(); j=y-x+1-getsum(rt,1,n,x,y); cover(rt,1,n,x,y); repair(rt,1,n,a,b,j); &#125; if(k==2)printf("%d\n",getmax(rt,1,n,x,y).Max); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2016 随机序列（线段树）]]></title>
    <url>%2F2018%2F09%2F14%2FSHOI2016-%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述你的面前有 $n$ 个数排成一行，分别为 $a_1, a_2, \dots, a_n$。你打算在每相邻的两个 $a_i$ 和 $a_{i+1}$ 间都插入一个加号、减号或者乘号。那么一共有 $3^{n-1}$ 种可能的表达式。 你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个 $a_i$ 的值。 你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。 输入格式第一行包含两个正整数 $n$ 和 $Q$，为数的个数和询问的个数。第二行包含 $n$ 个非负整数，依次表示 $a_1, a_2, \dots, a_n$。接下来 $Q$ 行，每行包含两个非负整数 $t$ 和 $v$，表示要将 $a_t$ 修改为 $v$，其中 $1 \leq t \leq n$。 保证对于 $1 \leq j \leq n, 1 \leq i \leq Q$，都有 $a_j, v_i \leq 10^4$。 输出格式输出 $Q$ 行。对于每个修改输出一行，包含一个整数，表示修改之后所有可能表达式的和，对 $10^9 + 7$ 取模。 样例输入12345675 59384 887 2778 6916 77942 83365 4933 14221 284 60 样例输出12345890543652252923708942282590228728040608998099 提示 Case # $n, Q$ 1, 2 $\leq 10$ 3 - 5 $\leq 1\,000$ 6 - 10 $\leq 100\,000$ 观察一下能够发现，会对答案产生贡献的只有第一个非乘号的位置之前的部分，也就是开始的连续一段乘号 那么考虑用线段树维护，每个点存三个值，区间内的答案，区间内的总方案数，区间乘积 合并的时候讨论左右区间之间放什么，如果放加减，那么贡献是左区间答案乘以右区间方案数 如果放乘号，当左区间全放乘号时，贡献是右区间答案乘以左区间乘积和，否则还是左区间答案乘右区间方案数 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x=0; while(t&lt;48||t&gt;57)t=GC; for(;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;const int mod=1e9+7;int add(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;int sub(int a,int b)&#123;a-=b;return a&lt;0?a+mod:a;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int n,q,a[N];struct node&#123; node *ls,*rs; int b,l,m;&#125;seg[N&lt;&lt;1],*rt,*tl,*null;void Init()&#123; rt=tl=null=seg; null-&gt;ls=null-&gt;rs=null;&#125;void update(node *p)&#123; node *l=p-&gt;ls,*r=p-&gt;rs; p-&gt;l=add(mul(mul(l-&gt;l,r-&gt;b),3),mul(l-&gt;m,sub(r-&gt;l,r-&gt;b))); p-&gt;m=mul(l-&gt;m,r-&gt;m);&#125;void build(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;ls=p-&gt;rs=null; if(l==r)&#123;p-&gt;l=p-&gt;m=a[l];p-&gt;b=1;return;&#125; int mid=l+r&gt;&gt;1; build(p-&gt;ls,l,mid); build(p-&gt;rs,mid+1,r); update(p); p-&gt;b=mul(3,mul(p-&gt;ls-&gt;b,p-&gt;rs-&gt;b));&#125;void modify(node *p,int l,int r,int x,int d)&#123; if(l==r)&#123;p-&gt;l=p-&gt;m=d;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)modify(p-&gt;ls,l,mid,x,d); else modify(p-&gt;rs,mid+1,r,x,d); update(p);&#125;int main()&#123; int i,j,k,x,y; n=_R();q=_R(); for(i=1;i&lt;=n;i++)a[i]=_R(); Init();build(rt,1,n); for(i=1;i&lt;=q;i++) &#123; x=_R();y=_R(); modify(rt,1,n,x,y); printf("%d\n",rt-&gt;l); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3065 带插入区间Ｋ小值（替罪羊树套线段树）]]></title>
    <url>%2F2018%2F09%2F04%2FBZOJ3065-%E5%B8%A6%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4K%E5%B0%8F%E5%80%BC%EF%BC%88%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E5%A5%97%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述从前有n只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力a[i]。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间k小值。 他每次向它的随从伏特提出这样的问题: 从左往右第x个到第y个跳蚤中，a[i]第k小的值是多少。 这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。 这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。 这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树） 这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。 请你帮一帮伏特吧。 快捷版题意：带插入、修改的区间k小值在线查询。 输入格式第一行一个正整数n，表示原来有n只跳蚤排成一行做早操。 第二行有n个用空格隔开的非负整数，从左至右代表每只跳蚤的弹跳力。 第三行一个正整数q，表示下面有多少个操作。 下面一共q行，一共三种操作对原序列的操作：（假设此时一共m只跳蚤） Q x y k: 询问从左至右第x只跳蚤到从左至右第y只跳蚤中，弹跳力第k小的跳蚤的弹跳力是多少。(1 &lt;= x &lt;= y &lt;= m, 1 &lt;= k &lt;= y - x + 1) M x val: 将从左至右第x只跳蚤的弹跳力改为val。 (1 &lt;= x &lt;= m) I x val: 在从左至右第x只跳蚤的前面插入一只弹跳力为val的跳蚤。即插入后从左至右第x只跳蚤是我刚插入的跳蚤。 (1 &lt;= x &lt;= m + 1) 为了体现在线操作，设lastAns为上一次查询的时候程序输出的结果，如果之前没有查询过，则lastAns = 0。 则输入的时候实际是： Q _x _y _k ——&gt; 表示 Q _x^lastAns _y^lastAns _k^lastAns M _x _val ——&gt; 表示 M _x^lastAns _val^lastAns I _x _val ——&gt; 表示 I _x^lastAns _val^lastAns 简单来说就是操作中输入的整数都要异或上一次询问的结果进行解码。 输出格式对于每个询问输出回答，每行一个回答。 样例输入1010 5 8 28 0 19 2 31 1 2230I 6 9M 1 11I 8 17M 1 31M 6 26Q 2 7 6I 23 30M 31 7I 22 27M 26 18Q 26 17 31I 5 2I 18 13Q 3 3 3I 27 19Q 23 23 30Q 5 13 5I 3 0M 15 27Q 0 28 13Q 3 29 11M 2 8Q 12 5 7I 30 19M 11 19Q 17 8 29M 29 4Q 3 0 12I 7 18M 29 27 样例输出282310141514271514 提示原序列长度 &lt;= 35000 插入个数 &lt;= 35000，修改个数 &lt;= 70000，查询个数 &lt;= 70000 ,0 &lt;= 每时每刻的权值 &lt;= 70000 这是一道经典题了，推荐看 $\rm vfk$ 官方题解 我写的替罪羊树套权值线段树的做法 具体的说就是用替罪羊树维护序列，每个节点上挂一颗权值线段树记该节点及子节点中出现的权值 那么建树的时候直接拍扁之后暴力建就行了，一次建树是 $n\log^2n$ 的，可以接受，据说可以线段树合并少一个 $\log$ 然后修改就直接做， $O(\log^2n)$ 插入的话也是直接在平衡树里找位置，然后沿着链往线段树里修改就行了， $O(\log^2n)$ 然后过于不平衡的时候就直接重建就行了，均摊下来 $O(n\log^3 n)$ 询问的时候像主席树那样把所有会用到的线段树的根先提出来，然后在线段树上二分， $O(\log^2 n)$ 然后要特别注意垃圾回收，不然很容易爆掉 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 70005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x=0; while(t&lt;48||t&gt;57)t=GC; for(;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;inline char _C()&#123; char t=GC; while(t&lt;'A'||t&gt;'Z')t=GC; return t;&#125;const int U=70000;int n,q,a[N],tot;struct node&#123; node *ls,*rs; int v;&#125;seg[N*128],*seg_tl,*seg_null,*seg_pool[N*128],*use[N];int ty[N],dt,seg_tp;struct nodd&#123; nodd *ls,*rs;node *rt; int v,sz;&#125;scape[N],**Rt,*rt,*tl,*null,*pool[N];int tp;void Init()&#123; seg_tl=seg_null=seg; seg_null-&gt;ls=seg_null-&gt;rs=seg_null; rt=tl=null=scape;Rt=&amp;null; null-&gt;ls=null-&gt;rs=null; null-&gt;rt=seg_null;&#125;//segnode *New()&#123; node *p=seg_tp?seg_pool[seg_tp--]:++seg_tl; p-&gt;ls=p-&gt;rs=seg_null;p-&gt;v=0;return p;&#125;void del(node *&amp;p)&#123; if(p==seg_null)return; seg_pool[++seg_tp]=p; del(p-&gt;ls);del(p-&gt;rs); p=seg_null;&#125;void modify(node *&amp;p,int l,int r,int x,int d)&#123; if(p==seg_null)p=New();p-&gt;v+=d; if(p-&gt;v==0)&#123;del(p);return;&#125; if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid)modify(p-&gt;ls,l,mid,x,d); else modify(p-&gt;rs,mid+1,r,x,d);&#125;//scapenodd *New(int x)&#123; nodd *p=tp?pool[tp--]:++tl; p-&gt;ls=p-&gt;rs=null; p-&gt;sz=1;p-&gt;v=x; p-&gt;rt=seg_null; return p;&#125;void update(nodd *p)&#123;p-&gt;sz=p-&gt;ls-&gt;sz+p-&gt;rs-&gt;sz+1;&#125;int modify(nodd *p,int x,int k)&#123; modify(p-&gt;rt,0,U,k,1);int t; if(x==p-&gt;ls-&gt;sz+1) &#123; modify(p-&gt;rt,0,U,p-&gt;v,-1); int t=p-&gt;v;p-&gt;v=k;return t; &#125; if(x&lt;=p-&gt;ls-&gt;sz)t=modify(p-&gt;ls,x,k); else t=modify(p-&gt;rs,x-p-&gt;ls-&gt;sz-1,k); modify(p-&gt;rt,0,U,t,-1);return t;&#125;void build(nodd *&amp;p,int l,int r)&#123; int mid=l+r&gt;&gt;1; p=New(a[mid]); for(int i=l;i&lt;=r;i++)modify(p-&gt;rt,0,U,a[i],1); if(l&lt;mid)build(p-&gt;ls,l,mid-1); if(mid&lt;r)build(p-&gt;rs,mid+1,r); update(p);&#125;void del(nodd *p)&#123; if(p==null)return; del(p-&gt;ls); a[++tot]=p-&gt;v;del(p-&gt;rt); pool[++tp]=p; del(p-&gt;rs);&#125;void rebuild()&#123; tot=0;del(*Rt); build(*Rt,1,tot); Rt=&amp;null;&#125;void insert(nodd *&amp;p,int x,int k)&#123; if(p==null)&#123;p=New(k);modify(p-&gt;rt,0,U,k,1);return;&#125; if(p-&gt;ls-&gt;sz&gt;=x) &#123; insert(p-&gt;ls,x,k); if(p-&gt;ls-&gt;sz&gt;=3*p-&gt;sz&gt;&gt;2)Rt=&amp;p; &#125; else &#123; insert(p-&gt;rs,x-p-&gt;ls-&gt;sz-1,k); if(p-&gt;rs-&gt;sz&gt;=3*p-&gt;sz&gt;&gt;2)Rt=&amp;p; &#125; modify(p-&gt;rt,0,U,k,1);update(p);&#125;void getrt(nodd *p,int k,int f)&#123; if(p==null||k==0)return; if(k==p-&gt;sz)&#123;use[++dt]=p-&gt;rt;ty[dt]=f;return;&#125; if(k&lt;=p-&gt;ls-&gt;sz)getrt(p-&gt;ls,k,f); else &#123; use[++dt]=p-&gt;rt;ty[dt]=f; use[++dt]=p-&gt;rs-&gt;rt;ty[dt]=-f; getrt(p-&gt;rs,k-p-&gt;ls-&gt;sz-1,f); &#125;&#125;int getans(int x,int y,int k)&#123; int l=0,r=U;dt=0; getrt(rt,y,1);getrt(rt,x-1,-1); while(l&lt;r) &#123; int mid=l+r&gt;&gt;1;int sum=0; for(int i=1;i&lt;=dt;i++)sum+=ty[i]*use[i]-&gt;ls-&gt;v; if(sum&gt;=k) &#123; for(int i=1;i&lt;=dt;i++)use[i]=use[i]-&gt;ls; r=mid; &#125; else &#123; for(int i=1;i&lt;=dt;i++)use[i]=use[i]-&gt;rs; k-=sum;l=mid+1; &#125; &#125; return l;&#125;int main()&#123; int i,j,k,x,y,z,las=0;char c; n=_R(); for(i=1;i&lt;=n;i++)a[i]=_R(); q=_R(); Init();build(rt,1,n); for(i=1;i&lt;=q;i++) &#123; c=_C(); if(c=='M') &#123; x=_R();y=_R(); x^=las;y^=las; modify(rt,x,y); &#125; if(c=='Q') &#123; x=_R();y=_R();z=_R(); x^=las;y^=las;z^=las; printf("%d\n",las=getans(x,y,z)); &#125; if(c=='I') &#123; x=_R();y=_R(); x^=las;y^=las;x--; insert(rt,x,y); if(*Rt!=null)rebuild(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC 2018 青蕈领主（CDQ分治+NTT+单调栈）]]></title>
    <url>%2F2018%2F05%2F09%2FCTSC-2018-%E9%9D%92%C2%96%E8%95%88%E9%A2%86%E4%B8%BB%EF%BC%88CDQ%E5%88%86%E6%B2%BB-NTT-%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CTSC2018 青蕈领主问题描述 “也许，我的生命也已经如同风中残烛了吧。”小绿如是说。 小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 ${1,3,2}$ 是连续的，而 ${1,3}$ 不是连续的。 某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \le i \le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。 做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。 可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。 由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。 我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。 输入格式 输入的第一行包含两个整数 $T,n$，分别表示板老大给小绿的排列个数、以及每个排列的长度。 接下来 $T$ 行，每行描述一组信息，包含 $n$ 个正整数，第 $i$ 组信息的从左往右第 $j$ 个整数 $L_{i,j}$ 表示第 $i$ 个排列中右端点为第 $j$ 个数的最长“连续”区间的长度。 对于每一行，如果行内包含多个数，则用单个空格将它们隔开。 输出格式 对于每组信息，输出一行一个整数表示可能的排列个数对 $998244353$ 取模的结果。由于是计算机帮你算，所以我们不给你犯错的机会。 样例输入 5 101 1 1 1 1 6 1 1 1 21 1 1 3 1 1 1 1 1 101 1 1 1 1 1 7 1 1 101 1 1 1 1 1 1 1 1 101 1 1 1 1 1 1 7 9 10 样例输出 0960024004432962400 提示 测试点编号 $n\le$ $T\le$ 特殊性质 1~2 $10$ 1 无 3~4 $10$ 100 无 5 $300$ 1 $ L_{i,j}=j$ 6 $300$ 1 $L_{i,j}=1$ 且 $j&lt;n$ 7~8 $300$ 100 无 9 $1000$ 1 $L_{i,j}=1$ 且 $j&lt;n$ 10~12 $1000$ 100 无 13~16 $5000$ 100 无 17~20 $50000$ 100 无 对于所有测试数据，$1 \le T \le 100$，$1 \le N \le 50000$, $1 \le L_{i,j} \le j$。本题部分测试点的输入规模较大，请注意读入效率。 首先容易发现所有连续区间只存在相离和内含的关系，不会出现交叉，这个很容易证明 因此无解的条件就是最后一个数不为n，或区间出现了交叉 然后考虑有解的情况，容易发现如果将每个位置的极大连续区间看成一个点，那么每个区间向包含它的最小的区间连边之后会形成一棵树 对于根来说，每个子树都是一个编号连续的区间，然后如果将每个子树看成一个整体，即缩成一个点，那么只需要缩点后的序列满足不存在长度大于1的连续区间即可，这个缩点过程是可以递归的 因此最后只需要求解形如$1\ 1\ 1\ 1\ 1…n+1$的方案数，也就是特殊数据6和9，令其为$f[n]$ 一般的，假设每个点的儿子个数分别是$D[1],D[2],…,D[n]$，那么答案就是$\Pi_{i=1}^{n}f[D[i]]$ 计算$D$可以用单调栈简单解决，主要问题是求解$f[n]$，这个存在一个$O(n^3)/O(n^2)$的容斥解法，可以打表得到80分，然而并不能解决本题。 然后假设我们打了个表，$1,2,2,4,16,88,600,4800,43680,443296$，然后尝试寻找递推式。 反正我是没找到，翻了题解之后得到$f[n]=(n-1)f[n-1]+\sum_{i=2}^{n-2}(i-1)f[i]f[n-i]$ 注意到$f[n]$的意思是长为$n+1$的序列，删去最后一位之后不存在长度大于1的连续区间的排列数 那么上面的递推式是什么意思呢 直接从这个定义去推很难解释，考虑一个满足条件的排列，$a_1,a_2,a_3,a_4$，那么我们将他置换一下，将$i$填到第$a_i$个位置上，即得到序列$b_{a_i}=i$ 考虑新的排列满足的条件，那么$a_{n+1}$对应了$b_i$中的元素$n+1$，可以发现$b$序列满足：不存在不经过最大值的连续区间，证明比较简单，考虑$b_i$的连续区间在$a_i$中的位置即可。 并且$a$序列和$b$序列是一一对应的，因此可以转而计算满足不存在不经过最大值的连续区间的排列数 考虑从长为$n$的合法序列$p$中添加一个元素得到长为$n+1$的合法序列$q$ 不妨认为$p$的编号从$2-n+1$，其方案数仍为$f[n-1]$，然后向其中添加一个最小值，只需要不与2相邻即可，因此有$n-1$种填法，因此总共有$(n-1)f[n-1]$种方案 再考虑从长为$n$的不合法序列$p$中添加一个元素得到长为$n+1$的合法序列$q$，依然考虑添加最小值 容易发现p中至多只能有一个不经过最大值的连续区间，那么枚举这个区间的长度$l(2&lt;=l&lt;=n-2)$，将这个连续区间视为整体后不能再存在不经过最大值的连续区间，方案数为$f[n-l]$ 考虑这个连续区间的值域为$[x,x+l-1]$，那么因为加入一个元素1之后能够使得它不存在连续区间，那么$x&gt;2且x+l-1&lt;n+1$，那么合法的$x$有$n-l+1-3+1=n-l-1$个 再考虑这样的连续区间个数，由于1与这个区间的值域不相邻，因此加入1后不存在连续区间与加入$x+l$后不存在不经过最大值的连续区间等价，因此这样的区间数就是$f[l]$，并且可以认为插入方法唯一 因此这样可以得到的序列$q$的总数目就是$\sum_{i=2}^{n-2}(n-i-1)f[i]f[n-i]=\sum_{i=1}^{n-2}(i-1)f[i]f[n-i]$ 那么上面的递推式得证。 然后这个递推式可以用分治$NTT$优化，处理的时候注意一下偏序关系和$NTT$的长度就行了。复杂度$O(n log^2 n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 300005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125; const int mod=998244353,g=3;int add(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;int sub(int a,int b)&#123;a-=b;return a&lt;0?a+mod:a;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int ksm(int a,int b)&#123;int o;for(o=1;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)o=mul(o,a);return o;&#125;int ntt_wi[N];void NTT(int C[],int n,int ty)&#123; int i,j,k,m,t0,t1; for(i=j=0;i&lt;n;i++) &#123; if(i&lt;j)swap(C[i],C[j]); for(k=(n&gt;&gt;1);(j^=k)&lt;k;k&gt;&gt;=1); &#125; ntt_wi[0]=1; for(m=1;m&lt;n;m&lt;&lt;=1) &#123; t0=ksm(g,mod-1+ty*(mod-1)/(m&lt;&lt;1)); for(i=1;i&lt;m;i++)ntt_wi[i]=mul(ntt_wi[i-1],t0); for(k=0;k&lt;n;k+=m&lt;&lt;1) for(i=k;i&lt;k+m;i++) &#123; t0=C[i];t1=mul(C[i+m],ntt_wi[i-k]); C[i]=add(t0,t1);C[i+m]=sub(t0,t1); &#125; &#125; if(ty==1)return;t0=ksm(n,mod-2); for(i=0;i&lt;n;i++)C[i]=mul(C[i],t0);&#125;int A[N],D[N],f[N],dc_A[N],dc_B[N],dc_C[N],S[N],top;void DC(int l,int r)&#123; if(l==r)&#123;f[l]=add(f[l],mul(f[l-1],l-1));return;&#125; int mid=l+r&gt;&gt;1,i; DC(l,mid); if(3&lt;=l) &#123; int lp=2,rp=min(l-1,r-l),L=1; while(L&lt;=rp+mid-l)L&lt;&lt;=1; fill(dc_A,dc_A+L,0); fill(dc_B,dc_B+L,0); for(i=lp;i&lt;=rp;i++)dc_A[i]=f[i]; for(i=l;i&lt;=mid;i++)dc_B[i-l]=f[i]; NTT(dc_A,L,1);NTT(dc_B,L,1); for(i=0;i&lt;L;i++)dc_C[i]=mul(dc_A[i],dc_B[i]); NTT(dc_C,L,-1); for(i=mid+1;i&lt;=r;i++)if(i&gt;=l)f[i]=add(f[i],mul(dc_C[i-l],i-2)); &#125; int L=1;while(L&lt;=mid-l+mid-l)L&lt;&lt;=1; fill(dc_A,dc_A+L,0); fill(dc_B,dc_B+L,0); for(i=l;i&lt;=mid;i++)dc_A[i-l]=f[i]; for(i=l;i&lt;=mid;i++)dc_B[i-l]=mul(i-1,f[i]); NTT(dc_A,L,1);NTT(dc_B,L,1); for(i=0;i&lt;L;i++)dc_C[i]=mul(dc_A[i],dc_B[i]); NTT(dc_C,L,-1); for(i=mid+1;i&lt;=r;i++)if(i&gt;=l+l)f[i]=add(f[i],dc_C[i-l-l]); DC(mid+1,r);&#125;int Solve(int n)&#123; int i,j,k,ans=1;top=0; if(A[n]!=n)return 0; S[++top]=n; fill(D,D+n+1,0); for(i=n-1;i&gt;=1;i--) &#123; while(S[top]-A[S[top]]+1&gt;i)top--; if(i-A[i]&lt;S[top]-A[S[top]])return 0; D[S[top]]++; while(top&amp;&amp;i-A[i]&lt;=S[top]-A[S[top]])top--; S[++top]=i; &#125; for(i=1;i&lt;=n;i++)ans=mul(ans,f[D[i]]); return ans;&#125;int main()&#123; int T,n,i,j,k,x,y; _R(T);_R(n); f[0]=1;f[1]=2;DC(2,n); while(T--) &#123; for(i=1;i&lt;=n;i++)_R(A[i]); printf("%d\n",Solve(n)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>数学</category>
        <category>分治法</category>
        <category>单调栈</category>
        <category>CDQ分治</category>
        <category>NTT</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 毒瘤（动态规划）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E6%AF%92%E7%98%A4%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI / HNOI2018」毒瘤问题描述 从前有一名毒瘤。 毒瘤最近发现了量产毒瘤题的奥秘。考虑如下类型的数据结构题：给出一个数组，要求支持若干种奇奇怪怪的修改操作（例如给一个区间内的数同时加上 $c$，或者将一个区间内的数同时开平方根），并且支持询问区间的和。毒瘤考虑了 $n$ 个这样的修改操作,并将它们编号为 $1 … n$。当毒瘤要出数据结构题的时候，他就将这些修改操作中选若干个出来，然后出成一道题。 当然了，这样出的题有可能不可做。通过精妙的数学推理，毒瘤揭露了这些修改操作之间的关系：有 $m$ 对“互相排斥”的修改操作，第 $i$ 对是第 $u_i$ 个操作和第 $v_i$ 个操作。当一道题中同时含有 $u_i$ 和 $v_i$ 这两个操作时，这道题就会变得不可做。另一方面，当一道题中不包含任何“互相排斥”的操作时，这个题就是可做的。此外，毒瘤还发现了一个规律：$m − n$ 是一个很小的数字（参见“数据范围”中的说明），且任意两个修改操作都是连通的。两个修改操作 $a, b$ 是连通的，当且仅当存在若干操作 $t_0, t_1, … , t_l$，使得 $t_0 = a,t l = b$，且对任意 $1 \le i \le l$，$t_{i−1}$ 和 $t_i$ 都是“互相排斥”的修改操作。 一对“互相排斥”的修改操作称为互斥对。现在毒瘤想知道，给定值 $n$ 和 $m$ 个互斥对，他一共能出出多少道可做的不同的数据结构题。两个数据结构题是不同的，当且仅当其中某个操作出现在了其中一个题中，但是没有出现在另一个题中。 输入格式 第一行为正整数 $n, m$。 接下来 $m$ 行，每行两个正整数 $u, v$，代表一对“互相排斥”的修改操作。 输出格式 输出一行一个整数，表示毒瘤可以出的可做的不同的数据结构题的个数。这个数可能很大，所以只输出模 $998244353$ 后的值。 样例输入 3 21 22 3 样例输出 5 提示 出题人说的很好 貌似还可以虚树上来搞，意思差不多，也是处理系数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#define N 100005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;const int mod=998244353;int add(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;int sub(int a,int b)&#123;a-=b;return a&lt;0?a+mod:a;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;struct edge&#123;int a[2][2];&#125;I,tmp;struct Edge&#123;int u,v;edge val;&#125;G[N];int n,m,deg[N],c[N][2],id[N],V[N],totv,tote;map&lt;int,edge&gt;E[N];map&lt;int,edge&gt;::iterator it;queue&lt;int&gt;Q;int main()&#123; register int i,j,k,x,y,ans=0; I.a[0][0]=I.a[1][0]=I.a[0][1]=1; _R(n);_R(m); for(i=1;i&lt;=n;++i)c[i][0]=c[i][1]=1; for(i=1;i&lt;=m;++i) &#123; _R(x);_R(y); ++deg[x];E[x][y]=I; ++deg[y];E[y][x]=I; &#125; for(i=1;i&lt;=n;++i)if(deg[i]==1||deg[i]==2)Q.push(i); while(Q.size()) &#123; x=Q.front();Q.pop(); if(deg[x]==1) &#123; y=(*E[x].begin()).first; tmp=(*E[x].begin()).second; E[y].erase(x); c[y][0]=mul(c[y][0],add(mul(tmp.a[0][0],c[x][0]),mul(tmp.a[1][0],c[x][1]))); c[y][1]=mul(c[y][1],add(mul(tmp.a[0][1],c[x][0]),mul(tmp.a[1][1],c[x][1]))); if(--deg[y]==2)Q.push(y); &#125; else if(deg[x]==2) &#123; int p1,p2;edge e1,e2; it=E[x].begin(); p1=(*it).first;e1=(*it).second;++it; p2=(*it).first;e2=(*it).second; E[p1].erase(x);E[p2].erase(x); for(i=0;i&lt;2;i++) for(j=0;j&lt;2;j++)tmp.a[i][j]=add(mul(c[x][0],mul(e1.a[0][i],e2.a[0][j])),mul(c[x][1],mul(e1.a[1][i],e2.a[1][j]))); if(E[p1].count(p2)) &#123; for(i=0;i&lt;2;i++) for(j=0;j&lt;2;j++) &#123; E[p1][p2].a[i][j]=mul(E[p1][p2].a[i][j],tmp.a[i][j]); E[p2][p1].a[i][j]=mul(E[p2][p1].a[i][j],tmp.a[j][i]); &#125; if(--deg[p1]==2)Q.push(p1); if(--deg[p2]==2)Q.push(p2); &#125; else &#123; E[p1][p2]=tmp; swap(tmp.a[0][1],tmp.a[1][0]); E[p2][p1]=tmp; &#125; &#125; &#125; for(i=1;i&lt;=n;++i) if(deg[i]!=1&amp;&amp;deg[i]!=2) &#123; V[id[i]=++totv]=i; for(it=E[i].begin();it!=E[i].end();++it) if((*it).first&gt;i)G[++tote]=(Edge)&#123;i,(*it).first,(*it).second&#125;; &#125; for(i=0;i&lt;(1&lt;&lt;totv);++i) &#123; int res=1; for(j=1;j&lt;=totv;++j)res=mul(res,c[V[j]][i&gt;&gt;j-1&amp;1]); for(j=1;j&lt;=tote;++j)res=mul(res,G[j].val.a[i&gt;&gt;id[G[j].u]-1&amp;1][i&gt;&gt;id[G[j].v]-1&amp;1]); ans=add(ans,res); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>神仙dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 转盘（线段树）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E8%BD%AC%E7%9B%98%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI / HNOI2018」转盘问题描述 一次小 G 和小 H 原本准备去聚餐，但由于太麻烦了于是题面简化如下： 一个转盘上有摆成一圈的 $n$ 个物品（编号 $1$ 至 $n$）其中第 $i$ 个物品会在 $T_i$ 时刻出现。 在 $0$ 时刻时,小 G 可以任选 $n$ 个物品中的一个，我们将其编号记为 $s_0$ 。并且如果 $i$ 时刻选择了物品 $s_i$ ，那么 $i + 1$ 时刻可以继续选择当前物品或者选择下一个物品。当 $s_i$ 为 $n$ 时，下一个物品为物品 $1$，否则下一个物品为 $s_{i + 1}$。在每一时刻（包括 $0$ 时刻），如果小 G 所选择的物品已经出现了，那么小 G 将会标记它。小 H 想知道，在物品选择的最优策略下，小 G 什么时候能标记所有物品？ 但麻烦的是，物品的出现时间会不时修改。我们将其描述为 $m$ 次修改，每次修改将改变其中一个物品的出现时间。每次修改之后，你也需要求出当前局面的答案。对于其中部分测试点，小 H 还追加了强制在线的要求。 输入格式 第一行三个非负整数 $n,m,p$，代表一共有 $n$ 个物品，$m$ 次修改。$p$ 只有 $0$ 或 $1$ 两种取值，强制在线时 $p$ 为 $1$，否则为 $0$。本节后面将解释如何使用 $p$。 接下来一行，有 $n$ 个用空格隔开的非负整数，第 $i$ 个数 $T_i$ 代表物品 $i$ 的出现时间。 接下来 $m$ 行，每行两个非负整数 $x,y$，代表一次修改及询问。修改方式如下： 如果 $p = 0$，则表示物品 $x$ 的出现时间 $T_x$ 修改为 $y$。 如果 $p = 1$，则先将 $x$ 和 $y$ 分别异或 $LastAns$ 得到 $x′$ 和 $y′$：即 $x′ = x \oplus LastAns, y′ = y \oplus LastAns$。然后将物品 $x′$ 的出现时间 $T_{x′}$ 修改为 $y′$ 。其中的 $LastAns$ 是前一个询问的答案；特别的，第一次修改时的 $LastAns$ 为初始局面的答案。其中的 $\oplus$ 为按位异或运算，例如 $1 \oplus 2 = 3,4 \oplus 5 = 1,6 \oplus 11 = 13$。 保证输入合法。 输出格式 第一行一个整数代表初始局面的答案。 接下来 $m + 1$ 行每行一个整数分别代表每次修改后的答案。 样例输入 5 3 01 2 3 4 53 55 01 4 样例输出 5767 提示 首先可以发现一定存在一种最优解是从某个点开始，等一段时间，然后一步不停的走完一圈。 那么将序列倍长，我们要求的答案即是$Min_{i=1}^{n}{Max_{j=i}^{2n}{T_j-j+i+n-1}}$ 化简一下得到$Min_{i=1}^{n}{Max_{j=i}^{2n}{T_j-j}+i}+n-1$，考虑用线段树来维护。 每个节点上分别维护$Max$和$Min$，其中$Max=Max_{j=l}^{r}{T_j-j}$，$Min=Min_{i=l}^{mid}{Max_{j=i}^{r}{T_j-j}+i}$ Max很容易维护，主要考虑维护Min 可以通过一个查询$Query(l,mid,Rmax)$来实现这一点，每次比较一下右儿子的$Max$和$Rmax$的大小关系，如果$Max&gt;=Rmax$那么返回左儿子的$Min$与右儿子查询的结果的较小者。否则返回左儿子查询结果与$mid+1$处答案的较小者。 这样做的时间复杂度是$O(n \log^2 n)$，可以接受。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,m,ty,T[N];struct node&#123; node *ls,*rs; int Max,Min;&#125;Seg[N&lt;&lt;2],*rt,*tl,*null;void Init()&#123; rt=tl=null=&amp;Seg[0]; null-&gt;ls=null-&gt;rs=null;&#125;int GM(node *p,int l,int r,int k)&#123; if(l==r)return l+max(k,p-&gt;Max); int mid=l+r&gt;&gt;1; if(k&gt;=p-&gt;rs-&gt;Max)return min(mid+1+k,GM(p-&gt;ls,l,mid,k)); return min(p-&gt;Min,GM(p-&gt;rs,mid+1,r,k));&#125;void MT(node *p,int l,int r)&#123; p-&gt;Max=max(p-&gt;ls-&gt;Max,p-&gt;rs-&gt;Max); p-&gt;Min=GM(p-&gt;ls,l,l+r&gt;&gt;1,p-&gt;rs-&gt;Max);&#125;void MD(node *p,int l,int r,int k)&#123; if(l==r)&#123;p-&gt;Max=T[l]-l;p-&gt;Min=T[l];return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)MD(p-&gt;ls,l,mid,k); else MD(p-&gt;rs,mid+1,r,k); MT(p,l,r);&#125;void BT(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;ls=p-&gt;rs=null; if(l==r)&#123;p-&gt;Max=T[l]-l;p-&gt;Min=T[l];return;&#125; int mid=l+r&gt;&gt;1; BT(p-&gt;ls,l,mid); BT(p-&gt;rs,mid+1,r); MT(p,l,r);&#125;int main()&#123; int i,j,k,x,y,ans; _R(n);_R(m);_R(ty); for(i=1;i&lt;=n;i++)_R(T[i]),T[i+n]=T[i]; Init();BT(rt,1,n+n); printf("%d\n",ans=rt-&gt;Min+n-1); for(i=1;i&lt;=m;i++) &#123; _R(x);_R(y); x^=ty*ans;y^=ty*ans; T[x]=T[x+n]=y; MD(rt,1,n+n,x); MD(rt,1,n+n,x+n); printf("%d\n",ans=rt-&gt;Min+n-1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 寻宝游戏（乱搞）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI / HNOI2018」寻宝游戏问题描述 某大学每年都会有一次 Mystery Hunt 的活动，玩家需要根据设置的线索解谜，找到宝藏的位置，前一年获胜的队伍可以获得这一年出题的机会。 作为新生的你对这个活动非常感兴趣。你每天都要从西向东经过教学楼一条很长的走廊，这条走廊是如此的长，以至于它被人戏称为 infinite corridor。一次，你经过这条走廊的时，注意到在走廊的墙壁上隐藏着 $n$ 个等长的二进制的数字，长度均为 $m$。你从西向东将这些数字记录了下来，形成一个含有 $n$ 个数的二进制数组 $a_1, a_2, …, a_n$。很快，在最新的一期 Voo Doo 杂志上，你发现了 $q$ 个长度也为 $m$ 的二进制串 $r_1, r_2, …, r_q$。聪明的你很快发现了这些数字的含义。保持数组 $a_1, a_2, …, a_n$ 的元素顺序不变,你可以在它们之间插入 $\wedge$（按位与运算）或者 $\vee$（按位或运算）两种二进制运算符。例如：$11011 \wedge 00111=00011,11011 \vee 00111=11111$。 你需要插入恰好 $n$ 个运算符,相邻两个数之间恰好一个，在第一个数的左边还有一个。如果我们在第一个运算符的左边补入一个 $0$，这就形成了一个运算式，我们可以计算它的值。与往常一样,运算顺序是从左往右。有趣的是,出题人已经告诉你这个值的可能的集合——Voo Doo 杂志里的那一些二进制数 $r_1, r_2, …, r_q$，而解谜的方法,就是对 $r_1, r_2, …, r_q$ 中的每一个值 $r_i$，分别计算出有多少种方法填入这 $n$ 个运算符,使得这个运算式的值是 $r_i$ 。然而，infinite corridor 真的很长，这意味着数据范围可能非常大。因此，答案也可能非常大，但是你发现由于谜题的特殊性，你只需要求答案模 $1000000007$ （$10^9 + 7$，一个质数）的值。 输入格式 第一行三个数 $n, m, q$，含义如题所述。 接下来 $n$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制串，左边是最高位，表示 $a_i$ 。 接下来 $q$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制串，左边是最高位，表示 $r_i$ 。 输出格式 输出 $q$ 行，每行一个数,其中第 $i$ 行表示对应于 $r_i$ 的答案。 样例输入 5 5 1011101101110000010100010000100 样例输出 6 提示 对于 $10\%$ 的数据，$n \le 20, m \le 30$，$q = 1$ 对于另外 $20\%$ 的数据，$n \le 1000$，$m \le 16$ 对于另外 $40\%$ 的数据，$n \le 500$，$m \le 1000$ 对于 $100\%$ 的数据，$1 \le n \le 1000$，$1 \le m \le 5000$，$1 \le q \le 1000$ 这题考验人类智慧。 按位考虑操作后的结果，把每一列压成一个二进制数$b_i$，最下面是最高位。 然后把操作序列也压成一个二进制数$x$，$\&amp;$为1，$|$为0，同样最后的操作是最高位。这样做了之后，发现第$i$为1当且仅当$x&lt;b_i$ 那么就可以确定$x$的取值范围了，为了方便，将$b_i$排序，然后分别找到$x$的上界和下界，答案就是$b_{up}-b_{low}$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int mod=1e9+7;int add(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;int sub(int a,int b)&#123;a-=b;return a&lt;0?a+mod:a;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int n,m,q,Rank[5005],val[5005],pow2[1005];struct node&#123;int id;char s[1005];&#125;B[5005];bool operator&lt;(node a,node b)&#123; for(int i=n;i&gt;=1;i--) if(a.s[i]!=b.s[i])return a.s[i]&lt;b.s[i]; return 0;&#125;char s[1005][5005],s0[5005];int Get(char t[])&#123; int ans=0; for(int i=1;i&lt;=n;i++)if(t[i]=='1')ans=add(ans,pow2[i-1]); return ans;&#125;int main()&#123; int i,j,k,Max,Min; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); pow2[0]=1; for(i=1;i&lt;=n;i++)pow2[i]=mul(2,pow2[i-1]); for(i=1;i&lt;=n;i++)scanf("%s",&amp;s[i][1]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)B[j].s[i]=s[i][j]; for(i=1;i&lt;=m;i++)B[i].id=i; sort(B+1,B+m+1); for(i=1;i&lt;=m;i++)val[i]=Get(B[i].s); val[m+1]=pow2[n]; for(i=1;i&lt;=m;i++)Rank[B[i].id]=i; for(i=1;i&lt;=q;i++) &#123; scanf("%s",&amp;s0[1]); Max=0;Min=m+1; for(j=1;j&lt;=m;j++) &#123; if(s0[j]=='1')Min=min(Min,Rank[j]); else Max=max(Max,Rank[j]); &#125; if(Max&gt;=Min)puts("0"); else printf("%d\n",sub(val[Min],val[Max])); &#125;&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 道路（树形dp）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E9%81%93%E8%B7%AF%EF%BC%88%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI/HNOI2018」道路问题描述 W 国的交通呈一棵树的形状。W 国一共有 $n − 1$ 个城市和 $n$ 个乡村，其中城市从 $1$ 到 $n − 1$ 编号，乡村从 $1$ 到 $n$ 编号，且 $1$ 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市 $i$，通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 $i$ 大的城市。没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。 W 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 $n − 1$ 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调查的数据，小 W 对每个乡村制定了三个参数，编号为 $i$ 的乡村的三个参数是 $a_i$，$b_i$ 和 $c_i$。假设从编号为 $i$ 的乡村走到首都一共需要经过 $x$ 条未翻修的公路与 $y$ 条未翻修的铁路，那么该乡村的不便利值为$$c_i \cdot (ai + x) \cdot (bi + y)$$在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 $n − 1$ 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。 输入格式 第一行为正整数 $n$。接下来 $n − 1$ 行，每行描述一个城市。其中第 $i$ 行包含两个数 $s_i, t_i$。$s_i$ 表示通向第 $i$ 座城市的公路的起点，$t_i$ 表示通向第 $i$ 座城市的铁路的起点。如果 $s_i &gt; 0$，那么存在一条从第 $s_i$ 座城市通往第 $i$ 座城市的公路，否则存在一条从第 $-s_i$ 个乡村通往第 $i$ 座城市的公路；$t_i$ 类似地，如果 $t_i &gt; 0$，那么存在一条从第 $t_i$ 座城市通往第 $i$ 座城市的铁路，否则存在一条从第 $-t_i$ 个乡村通往第 $i$ 座城市的铁路。 接下来 $n$ 行，每行描述一个乡村。其中第 $i$ 行包含三个数 $a_i, b_i, c_i$，其意义如题面所示。 输出格式 输出一行一个整数，表示最优翻修方案的不便利值。 样例输入 62 34 5-1 -2-3 -4-5 -61 2 31 3 22 1 32 3 13 1 23 2 1 样例输出 54 提示 共 $20$ 组数据，编号为 $1 ∼ 20$。 对于编号 $\le 4$ 的数据，$n \le 20$； 对于编号为 $5 ∼ 8$ 的数据，$a_i, b_i, c_i \le 5，n \le 50$； 对于编号为 $9 ∼ 12$ 的数据，$n \le 2000$； 对于所有的数据，$n \le 20000$，$1 \le a_i, b_i \le 60$，$1 \le c_i \le 10^9$，$s_i, t_i$ 是 $[−n, −1] \cap (i, n − 1]$ 内的整数，任意乡村可以通过不超过 $40$ 条道路到达首都。 挺裸的dp，令$f[i][x][y]$表示从根节点到$i$，翻修了$x$条公路，$y$条铁路，然后直接dp算一算就行了。注意到题目中的深度限制，因此可以每个深度开一个dp数组来优化空间。还可以直接定二维状态算。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 40010#define ll long longusing namespace std;int n,ls[N],rs[N],a[N],b[N],c[N];ll f[44][44][44];void DP(int x,int d)&#123; if(x&gt;=n) &#123; for(int i=0;i&lt;=d;i++) for(int j=0;j&lt;=d-i;j++)f[d][i][j]=1ll*c[x-n+1]*(a[x-n+1]+i)*(b[x-n+1]+j); return; &#125; DP(ls[x],d+1);ll g[44][44]; for(int i=0;i&lt;=d+1;i++) for(int j=0;j&lt;=d+1-i;j++)g[i][j]=f[d+1][i][j]; DP(rs[x],d+1); for(int i=0;i&lt;=d;i++) for(int j=0;j&lt;=d-i;j++)f[d][i][j]=min(g[i+1][j]+f[d+1][i][j],g[i][j]+f[d+1][i][j+1]);&#125;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(x&lt;0)x=n-1-x; if(y&lt;0)y=n-1-y; ls[i]=x;rs[i]=y; &#125; for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i]); DP(1,0);printf("%lld",f[0][0][0]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 排列（贪心+堆）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E6%8E%92%E5%88%97%EF%BC%88%E8%B4%AA%E5%BF%83-%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI / HNOI2018」排列问题描述 给定 $n$ 个整数 $a_1, a_2, …, a_n(0 \le a_i \le n)$，以及 $n$ 个整数 $w_1, w_2, …, w_n$。称 $a_1, a_2, …, a_n$ 的一个排列 $a_{p[1]}, a_{p[2]}, …, a_{p[n]}$ 为 $a_1, a_2, …, a_n$ 的一个合法排列，当且仅当该排列满足：对于任意的 $k$ 和任意的 $j$，如果 $j \le k$，那么 $a_{p[j]}$ 不等于 $p[k]$。（换句话说就是：对于任意的 $k$ 和任意的 $j$，如果 $p[k]$ 等于 $a_{p[j]}$，那么 $k&lt;j$。） 定义这个合法排列的权值为 $w_{p[1]} + 2w_{p[2]} + … + nw_{p[n]}$。你需要求出在所有合法排列中的最大权值。如果不存在合法排列，输出 $-1$。 样例解释中给出了合法排列和非法排列的实例。 输入格式 第一行一个整数 $n$。 接下来一行 $n$ 个整数，表示 $a_1,a_2,…, a_n$。 接下来一行 $n$ 个整数，表示 $w_1,w_2,…,w_n$。 输出格式 输出一个整数表示答案。 样例输入 30 1 15 7 3 样例输出 32 提示 对于前 $20\%$ 的数据，$1 \le n \le 10$； 对于前 $40\%$ 的数据，$1 \le n \le 15$； 对于前 $60\%$ 的数据，$1 \le n \le 1000$； 对于前 $80\%$ 的数据，$1 \le n \le 100000$； 对于 $100\%$ 的数据，$1 \le n \le 500000$，$0 \le a_i \le n (1 \le i \le n)$，$1 \le w_i \le 10^9$ ，所有 $w_i$ 的和不超过 $1.5 \times 10^{13}$。 弄清楚题意后发现，题目要求的就是$a_{a_i}$在新排列中必须在$a_i$之前，那么我们从$i\rightarrow a_i$连边，这样的话就变成一颗以0为根的树，那么要求就是必须先选父亲才能选儿子。 要求权值最大等价于先选权值小的，那么考虑全局最小值优先选。如果当前全局最小值的父亲为0，那么直接选。 否则它一定在选了父亲之后第一个选，因此可以将它和它的父亲缩到一起，考虑缩点后的权值是多少，这里比较巧妙，实际上权值给成$\frac{\sum w_i}{size}$就是对的，具体证明我们考虑假如先选缩点后的$(a_1,a_2,…,a_k)$比先选$a_{k+1},…,a_n$优，那么意味着 $$a_1+2a_2+…+ka_k+(k+1)a_{k+1}+…+na_n \geq a_{k+1}+…+(n-k)a_n+(n-k+1)a_1+…+na_k$$那么移项就得到 $$(n-k)(a_1+a_2+…+a_k)\leq k(a_{k+1}+…+a_n)$$那么容易发现这样做是对的。因此只需要用并查集+堆来维护就行了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define ll long long#define N 500005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;1)+(x&lt;&lt;3)+t-48;&#125;struct node&#123;ll v;int s,x;&#125;;bool operator&lt;(node a,node b)&#123;return a.v*b.s&gt;b.v*a.s;&#125;int n,a[N],fa[N],si[N];ll sum[N],ans;priority_queue&lt;node&gt;Q;int gf(int x)&#123;return x==fa[x]?x:fa[x]=gf(fa[x]);&#125;int main()&#123; register int i,j,k,x,y,fx,fy;_R(n); for(i=0;i&lt;=n;i++)fa[i]=i; for(i=1;i&lt;=n;i++) &#123; _R(a[i]); fx=gf(i);fy=gf(a[i]); if(fx==fy)return puts("-1"),0; fa[fx]=fy; &#125; for(i=1;i&lt;=n;i++)_R(x),sum[i]=x; for(i=0;i&lt;=n;i++)si[i]=1,fa[i]=i; for(i=1;i&lt;=n;i++)Q.push((node)&#123;sum[i],si[i],i&#125;); while(Q.size()) &#123; node tmp=Q.top(); Q.pop(); if(tmp.s!=si[tmp.x])continue; fx=gf(a[tmp.x]); ans+=tmp.v*si[fx]; fa[tmp.x]=fx; si[fx]+=tmp.s; sum[fx]+=tmp.v; if(fx)Q.push((node)&#123;sum[fx],si[fx],fx&#125;); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>贪心</category>
        <category>堆</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI/HNOI2018 游戏（乱搞/拓扑排序）]]></title>
    <url>%2F2018%2F05%2F03%2FAHOI-HNOI2018-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B9%B1%E6%90%9E-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「AHOI / HNOI2018」游戏问题描述 一次小 G 和小 H 在玩寻宝游戏，有 $n$ 个房间排成一列，编号为 $1,2,…,n$，相邻房间之间都有 $1$ 道门。其中一部分门上有锁（因此需要对应的钥匙才能开门），其余的门都能直接打开。 现在小 G 告诉了小 H 每把锁的钥匙在哪个房间里（每把锁有且只有一把钥匙），并作出 $p$ 次指示：第 $i$ 次让小 H 从第 $S_i$ 个房间出发，去第 $T_i$ 个房间寻宝。但是小 G 有时会故意在指令里放入死路，而小 H 也不想浪费多余的体力去尝试，于是想事先调查清楚每次的指令是否存在一条通路。 你是否能为小 H 作出解答呢？ 输入格式 第一行三个整数$n$，$m$，$p$，代表共有 $n$ 个房间，$m$ 道门上了锁，以及 $p$ 个询问。 接下来 $m$ 行每行有两个整数$x$，$y$，代表第 $x$ 到第 $x + 1$ 个房间的门上有把锁，并且这把锁的钥匙被放在了第 $y$ 个房间里。输入保证 $x$ 不重复。 接下来 $p$ 行，其中第 $i$ 行是两个整数 $S_i$，$T_i$，代表一次询问。 输出格式 输出 $m$ 行，每行一个大写的 YES 或 NO 分别代表能或不能到达。 样例输入 5 4 51 32 23 14 42 53 54 52 13 1 样例输出 YESNOYESYESNO 提示 测试点编号 n m 其他特性 1 $ \le 1000 $ $ \le 1000 $ 无 2 $ \le 1000 $ $ \le 1000 $ 无 3 $ \le 10^5 $ $ \le 10^5 $ $y \le x$ 恒成立 4 $ \le 10^5 $ $ \le 10^5 $ $y \le x$ 恒成立 5 $ \le 10^5 $ $ \le 10^5 $ 无 6 $ \le 10^5 $ $ \le 10^5 $ 无 7 $ \le 10^6 $ $ \le 10^6 $ $y \le x$ 恒成立 8 $ \le 10^6 $ $ \le 10^6 $ $y \le x$ 恒成立 9 $ \le 10^6 $ $ \le 10^6 $ 无 10 $ \le 10^6 $ $ \le 10^6 $ 无 对于所有数据，保证 $1 \le n,p \le 10^6$，$0 \le m &lt; n$，$1 \le x, y, S_i,T_i &lt; n$，保证 $x$ 不重复。 由于本题输入文件较大，建议在程序中使用读入优化。 显然需要处理出每个点能到的区间。一个显然的优化是到达某个点后将当前区间与该点能到的区间取并。 本题数据较水，略加优化的暴力即可AC。并且跑得比正解快。 正解是考虑每一扇门，假如$i$到$i+1$的门的钥匙在$i$的那一边，那么就只能是$i$走到$i+1$，因此从$i$向$i+1$连边，然后处理出拓扑关系，按照拓扑关系来暴力往两边拓展即可保证复杂度。 暴力代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,m,q,pos[N],L[N],R[N];bool In(int p,int i)&#123;return p&gt;=L[i]&amp;&amp;p&lt;=R[i];&#125; int main()&#123; int i,j,k,x,y; _R(n);_R(m);_R(q); for(i=1;i&lt;=m;i++)_R(x),_R(y),pos[x]=y; for(i=1;i&lt;=n;i++)L[i]=R[i]=i; for(i=n;i&gt;=1;i--) &#123; while(R[i]&lt;n) &#123; if(!pos[R[i]]||In(pos[R[i]],i))R[i]=R[R[i]+1]; else break; &#125; &#125; for(i=1;i&lt;=n;i++) &#123; while(1) &#123; bool ok=0; if(L[i]&gt;1&amp;&amp;(!pos[L[i]-1]||In(pos[L[i]-1],i))) &#123; L[i]=L[L[i]-1]; ok=1; &#125; if(R[i]&lt;n&amp;&amp;(!pos[R[i]]||In(pos[R[i]],i))) &#123; R[i]=R[R[i]+1]; ok=1; &#125; if(!ok)break; &#125; &#125; for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y); if(In(y,x))puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2015 道路修建（线段树）]]></title>
    <url>%2F2018%2F04%2F20%2FSDOI2015-%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[SDOI2015]道路修建问题描述 某国有2N个城市，这2N个城市构成了一个2行N列的方格网。现在该国政府有一个旅游发展计划，这个计划需要选定L、R两列(L&lt;=R)，修建若干条专用道路，使得这两列之间（包括这两列）的所有2(R-L+1)个城市中每个城市可以只通过专用道路就可以到达这2(R-L+1)个城市中的任何一个城市。这种专用道路只能在同一行相邻两列的城市或者同一列的两个城市之间修建，且修建需要花费一定的费用。由于该国政府决定尽量缩减开支，因此政府决定，选定L、R后，只修建2(R-L+1)-1条专用道路，使得这些专用道路构成一个树结构。现在你需要帮助该国政府写一个程序，完成这个任务。具体地，该任务包含M个操作，每个操作的格式如下： 1.C x0 y0 x1 y1 w：由于重新对第x0行第y0列的城市和第x1行第y1列的城市之间的情况进行了考察，它们之间修建一条专用道路的花费变成了w； 2.Q L R：若政府选定的两列分别为L、R，询问政府的最小开支。 输入格式 第一行，两个整数N、M。 第二行，N-1个整数，其中第i个整数表示初始时第1行第i列的城市和第1行第i+1列的城市之间修建一条专用道路的费用。 第三行，N-1个整数，其中第i个整数表示初始时第2行第i列的城市和第2行第i+1列的城市之间修建一条专用道路的费用。 第四行，N个整数，其中第i个整数表示初始时第1行第i列的城市和第2行第i列的城市之间修建一条专用道路的费用。 接下来的M行，每行一个操作。 输出格式 对于每个询问操作，输出一行，表示你计算出的政府的最小开支。 样例输入 3 3 1 2 2 1 3 1 2 Q 1 3 C 1 2 2 2 3 Q 2 3 样例输出 7 5 提示 对于40%的数据，1&lt;=N, M&lt;=600； 对于全部的数据，1&lt;=N, M&lt;=60000，任何时刻任何一条专用道路的修建费用不超过$10^4$ 观察可知，对于一个联通块，只需要维护它的四个角的联通情况就行了。因此对于一个联通块，最多存在$10$种可能联通情况，我们考虑用线段树维护区间联通信息，即每一种联通情况的最小费用，然后合并的时候讨论一下就行了。 然后观察转移发现实际上这$10$种情况本质不同的只有$5$种，并且合并时只需要考虑连$1$条边还是$2$条边，因此最多有$50$种转移，实际上没有这么多。然后询问就只需要将线段树上对应区间拿来合并就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 66666using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;const int inf=1e9;int n,m,UR[N],DR[N],D[N];struct nodd&#123; int v[6]; void Init() &#123; for(int i=0;i&lt;6;i++)v[i]=inf; &#125;&#125;;struct node&#123; node *ls,*rs; nodd v;&#125;Seg[N&lt;&lt;2],*rt,*tl,*null;void Init()&#123; rt=tl=null=&amp;Seg[0]; null-&gt;ls=null-&gt;rs=null; null-&gt;v.Init();&#125;void Update(nodd &amp;p,nodd &amp;l,nodd &amp;r,int a,int b)&#123; int c=min(a,b),d=a+b;p.Init(); p.v[1]=min(p.v[1],l.v[1]+r.v[1]+c); p.v[1]=min(p.v[1],l.v[1]+r.v[2]+d); p.v[3]=min(p.v[3],l.v[1]+r.v[3]+c); p.v[3]=min(p.v[3],l.v[1]+r.v[4]+c); p.v[1]=min(p.v[1],l.v[1]+r.v[4]+d); p.v[3]=min(p.v[3],l.v[1]+r.v[5]+d); p.v[2]=min(p.v[2],l.v[2]+r.v[1]+c); p.v[2]=min(p.v[2],l.v[2]+r.v[2]+d); p.v[5]=min(p.v[5],l.v[2]+r.v[3]+c); p.v[5]=min(p.v[5],l.v[2]+r.v[4]+c); p.v[2]=min(p.v[2],l.v[2]+r.v[4]+d); p.v[5]=min(p.v[5],l.v[2]+r.v[5]+d); p.v[1]=min(p.v[1],l.v[3]+r.v[1]+d); p.v[3]=min(p.v[3],l.v[3]+r.v[3]+d); p.v[3]=min(p.v[3],l.v[3]+r.v[4]+d); p.v[2]=min(p.v[2],l.v[4]+r.v[1]+c); p.v[1]=min(p.v[1],l.v[4]+r.v[1]+d); p.v[2]=min(p.v[2],l.v[4]+r.v[2]+d); p.v[5]=min(p.v[5],l.v[4]+r.v[3]+c); p.v[3]=min(p.v[3],l.v[4]+r.v[3]+d); p.v[5]=min(p.v[5],l.v[4]+r.v[4]+c); p.v[4]=min(p.v[4],l.v[4]+r.v[4]+d); p.v[5]=min(p.v[5],l.v[4]+r.v[5]+d); p.v[2]=min(p.v[2],l.v[5]+r.v[1]+d); p.v[5]=min(p.v[5],l.v[5]+r.v[3]+d); p.v[5]=min(p.v[5],l.v[5]+r.v[4]+d);&#125;void BT(node *&amp;p,int l,int r)&#123; p=++tl;p-&gt;ls=p-&gt;rs=null; if(l==r) &#123; p-&gt;v.v[1]=D[l]; p-&gt;v.v[2]=p-&gt;v.v[3]=inf; p-&gt;v.v[4]=0; p-&gt;v.v[5]=inf; return; &#125; int mid=l+r&gt;&gt;1; BT(p-&gt;ls,l,mid); BT(p-&gt;rs,mid+1,r); Update(p-&gt;v,p-&gt;ls-&gt;v,p-&gt;rs-&gt;v,UR[mid],DR[mid]);&#125;void MD(node *p,int l,int r,int k)&#123; if(l==r) &#123; p-&gt;v.v[1]=D[l]; p-&gt;v.v[2]=p-&gt;v.v[3]=inf; p-&gt;v.v[4]=0; p-&gt;v.v[5]=inf; return; &#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)MD(p-&gt;ls,l,mid,k); else MD(p-&gt;rs,mid+1,r,k); Update(p-&gt;v,p-&gt;ls-&gt;v,p-&gt;rs-&gt;v,UR[mid],DR[mid]);&#125;nodd Gans(node *p,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)return p-&gt;v; int mid=l+r&gt;&gt;1;nodd a,b,t; a.Init();b.Init();t.Init(); if(x&gt;mid)return Gans(p-&gt;rs,mid+1,r,x,y); if(y&lt;=mid)return Gans(p-&gt;ls,l,mid,x,y); a=Gans(p-&gt;ls,l,mid,x,y); b=Gans(p-&gt;rs,mid+1,r,x,y); Update(t,a,b,UR[mid],DR[mid]); return t;&#125;int main()&#123; int i,j,k,x1,y1,x2,y2; _R(n);_R(m);char s; for(i=1;i&lt;n;i++)_R(UR[i]); for(i=1;i&lt;n;i++)_R(DR[i]); for(i=1;i&lt;=n;i++)_R(D[i]); Init();BT(rt,1,n); for(i=1;i&lt;=m;i++) &#123; s=GC;while(s!='Q'&amp;&amp;s!='C')s=GC; if(s=='Q') &#123; _R(x1);_R(x2); printf("%d\n",Gans(rt,1,n,x1,x2).v[1]); &#125; else &#123; _R(x1);_R(y1);_R(x2);_R(y2);_R(k); if(y1&gt;y2)swap(y1,y2); if(x1==x2)x1==1?UR[y1]=k:DR[y1]=k; else D[y1]=k; MD(rt,1,n,y1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ4029 CodeChef COUNTARI（分块+FFT）]]></title>
    <url>%2F2018%2F04%2F20%2FNKOJ4029-CodeChef-COUNTARI%EF%BC%88%E5%88%86%E5%9D%97-FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4029 [CodeChef] COUNTARI问题描述 给定一个长度为N的数组A[]，求有多少对$i, j, k（1\leq i&lt;j&lt;k\leq N）$满足$A[k]-A[j]=A[j]-A[i]$ 输入格式 第一行一个整数$N（N&lt;=10^5）$。 接下来一行N个数$A[i]（A[i]&lt;=30000）$。 输出格式 一行一个整数。 样例输入 10 3 5 3 6 3 4 10 4 5 2 样例输出 9 容易想到一个朴素的暴力，枚举$j$的位置，然后两边卷积得到$A[i]+A[k]=2A[j]$的$(i,k)$的数量。考虑优化。 用分块处理，设块的大小为$K$，那么分三种情况来讨论。 当$i,j,k$在同一块内时，枚举$(i,k)$，同时维护$cnt[j]$，那么单块可以在$O(K^2)$内出解，总复杂度就是$O(NK)$的 当$i,j,k$有两个在同一块内时，同样枚举$(i,k)$，复杂度仍然是$O(NK)$ 当$i,j,k$均不在同一块时，枚举每一块，将左右两边的块卷积起来，复杂度就是$\frac{N}{K}M\log M$，$M=max{A[i]}$ 那么只需要一个比较优秀的$K$即可解决。似乎当$K=5.3\sqrt{N}$时效果不错。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;complex&gt;#define N 100005#define ll long longusing namespace std;struct com&#123; double r,v; com(double x=0,double y=0)&#123;r=x;v=y;&#125;&#125;B[N],D[N],w[2][N];com operator+(com &amp;a,com &amp;b)&#123;return com(a.r+b.r,a.v+b.v);&#125;com operator-(com &amp;a,com &amp;b)&#123;return com(a.r-b.r,a.v-b.v);&#125;com operator*(com &amp;a,com &amp;b)&#123;return com(a.r*b.r-a.v*b.v,a.r*b.v+a.v*b.r);&#125;int n,K,tot,lp[N],rp[N],A[N],Lcnt[N],Rcnt[N],cnt[N],L,rev[N];ll ans;const double pi=acos(-1.0);void FFT_pre()&#123; int i,j,k; com f=com(cos(2.0*pi/L),sin(2.0*pi/L)); com g=com(cos(2.0*pi/L),-sin(2.0*pi/L)); w[0][0]=w[1][0]=1; for(i=1;i&lt;L;i++) &#123; w[0][i]=w[0][i-1]*g; w[1][i]=w[1][i-1]*f; &#125;&#125;void FFT(com C[],int ty)&#123; register int i,j,k,m,t;com t0,t1; for(i=0;i&lt;L;i++)if(i&lt;rev[i])swap(C[i],C[rev[i]]); for(m=1,t;t=L/(m&lt;&lt;1),m&lt;L;m&lt;&lt;=1) for(k=0;k&lt;L;k+=m&lt;&lt;1) for(i=k,j=0;i&lt;k+m;i++,j+=t) &#123; t0=C[i];t1=C[i+m]*w[ty][j]; C[i]=t0+t1; C[i+m]=t0-t1; &#125; if(ty==1)return;t0=1.0/L; for(i=0;i&lt;L;i++)C[i]=C[i]*t0;&#125;int main()&#123; int i,j,k,x,y,Max=0,len=0; scanf("%d",&amp;n);K=5.3*sqrt(n); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;A[i]); Max=max(Max,A[i]); Rcnt[A[i]]++; rp[i/K]=i; if(!lp[i/K])lp[i/K]=i; &#125; tot=n/K;L=1;while(L&lt;=(Max&lt;&lt;1))L&lt;&lt;=1,len++;FFT_pre(); for(i=0;i&lt;L;i++)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;len&gt;&gt;1); for(i=0;i&lt;=tot;i++) &#123; for(j=lp[i];j&lt;=rp[i];j++)Rcnt[A[j]]--; for(j=lp[i];j&lt;rp[i];j++) &#123; for(k=j+1;k&lt;=rp[i];k++) &#123; if(A[j]+A[k]+1&amp;1)ans+=cnt[A[j]+A[k]&gt;&gt;1]; if((A[j]&lt;&lt;1)-A[k]&gt;=0)ans+=Lcnt[(A[j]&lt;&lt;1)-A[k]]; if((A[k]&lt;&lt;1)-A[j]&gt;=0)ans+=Rcnt[(A[k]&lt;&lt;1)-A[j]]; cnt[A[k]]++; &#125; for(k=j+1;k&lt;=rp[i];k++)cnt[A[k]]--; &#125; if(i!=0&amp;&amp;i!=tot) &#123; fill(B,B+L,0);fill(D,D+L,0); for(j=0;j&lt;L;j++)B[j]=Lcnt[j],D[j]=Rcnt[j]; FFT(B,1);FFT(D,1); for(j=0;j&lt;L;j++)B[j]=B[j]*D[j]; FFT(B,0); for(j=lp[i];j&lt;=rp[i];j++)ans+=floor(B[A[j]&lt;&lt;1].r+0.5); &#125; for(j=lp[i];j&lt;=rp[i];j++)Lcnt[A[j]]++; &#125; printf("%lld",ans); &#125;]]></content>
      <categories>
        <category>数学</category>
        <category>分治法</category>
        <category>分块</category>
        <category>FFT</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2016 区间（线段树）]]></title>
    <url>%2F2018%2F04%2F19%2FNOI2016-%E5%8C%BA%E9%97%B4%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2016】区间问题描述 在数轴上有 $n$ 个闭区间 $[l_1,r_1],[l_2,r_2],…,[l_n,r_n]$。现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i\leq x\leq r_i$。 对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 $[l_i,r_i]$ 的长度定义为 $r_i−l_i$，即等于它的右端点的值减去左端点的值。 求所有合法方案中最小的花费。如果不存在合法的方案，输出 $−1$。 输入格式 第一行包含两个正整数 $n,m$ 用空格隔开，意义如上文所述。保证 $1\leq m\leq n$。 接下来 $n$ 行，每行表示一个区间，包含用空格隔开的两个整数 $l_i$ 和 $r_i$ 为该区间的左右端点。 输出格式 只有一行，包含一个正整数，即最小花费。 样例输入 6 33 51 23 42 21 51 4 样例输出 2 提示 所有测试数据的范围和特点如下表所示： 测试点编号 $ n $ $ m $ $ l_i,r_i $ 1 $ 20 $ $ 9 $ $ 0 \le l_i \le r_i \le 100 $ 2 $ 10 $ 3 $ 199 $ $ 3 $ $ 0 \le l_i \le r_i \le 100000 $ 4 $ 200 $ 5 $ 1000 $ $ 2 $ 6 $ 2000 $ 7 $ 199 $ $ 60 $ $ 0 \le l_i \le r_i \le 5000 $ 8 $ 200 $ $ 50 $ 9 $ 0 \le l_i \le r_i \le 10^9 $ 10 $ 1999 $ $ 500 $ $ 0 \le l_i \le r_i \le 5000 $ 11 $ 2000 $ $ 400 $ 12 $ 500 $ $ 0 \le l_i \le r_i \le 10^9 $ 13 $ 30000 $ $ 2000 $ $ 0 \le l_i \le r_i \le 100000 $ 14 $ 40000 $ $ 1000 $ 15 $ 50000 $ $ 15000 $ 16 $ 100000 $ $ 20000 $ 17 $ 200000 $ $ 0 \le l_i \le r_i \le 10^9 $ 18 $ 300000 $ $ 50000 $ 19 $ 400000 $ $ 90000 $ 20 $ 500000 $ $ 200000 $ 首先将区间按照长度排序，那么不难发现最后答案一定可以由连续的一段区间给出。然后判断一段区间$[l,r]$是否合法就是判断将这些区间拿去做区间覆盖之后有一个位置的覆盖次数大于等于$m$，容易发现对于每一个$r$作为右端点的时候，最优的$l$的取值一定是单调不降的。 因此我们可以从左往右枚举$r$，然后维护最优的$l$的位置，当$[l,r]$满足条件时就更新答案。只需要用一颗线段树来维护区间覆盖就行了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define max(a,b) (a&gt;b?a:b)#define min(a,b) (a&lt;b?a:b)using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;struct nodd&#123; int l,r; bool operator&lt;(const nodd &amp;b)const &#123;return r-l&lt;b.r-b.l;&#125;&#125;K[N];int n,m,ans=1e9,T,Hash[N];int Max[N&lt;&lt;2],lazy[N&lt;&lt;2],ux,uy,ud;void ADD(register int p,register int l,register int r)&#123; if(ux&lt;=l&amp;&amp;uy&gt;=r)&#123;Max[p]+=ud;lazy[p]+=ud;return;&#125; register int mid=l+r&gt;&gt;1; if(ux&lt;=mid)ADD(p&lt;&lt;1,l,mid); if(uy&gt;mid)ADD(p&lt;&lt;1|1,mid+1,r); Max[p]=max(Max[p&lt;&lt;1],Max[p&lt;&lt;1|1]); Max[p]+=lazy[p];&#125;int main()&#123; int i,j,k,x,y; _R(n);_R(m); for(i=1;i&lt;=n;i++) &#123; _R(x);_R(y); Hash[++T]=x;Hash[++T]=y; K[i]=(nodd)&#123;x,y&#125;; &#125; sort(K+1,K+n+1); sort(Hash+1,Hash+T+1); T=unique(Hash+1,Hash+T+1)-Hash-1; for(i=1;i&lt;=n;i++) &#123; K[i].l=lower_bound(Hash+1,Hash+T+1,K[i].l)-Hash; K[i].r=lower_bound(Hash+1,Hash+T+1,K[i].r)-Hash; &#125; for(i=j=1;i&lt;=n;i++) &#123; ux=K[i].l;uy=K[i].r;ud=1; ADD(1,1,T); while(Max[1]&gt;=m) &#123; ans=min(ans,Hash[K[i].r]-Hash[K[i].l]-Hash[K[j].r]+Hash[K[j].l]); ux=K[j].l;uy=K[j].r;ud=-1; ADD(1,1,T);j++; &#125; &#125; printf("%d",ans==1e9?-1:ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2016 循环之美（莫比乌斯反演+杜教筛）]]></title>
    <url>%2F2018%2F04%2F19%2FNOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%9D%9C%E6%95%99%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2016】循环之美问题描述 牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。 现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\frac x y$ 表示，其中 $1\le x\le n,1\le y\le m$，且 $x,y$ 是整数。 一个数是纯循环的，当且仅当其可以写成以下形式：$$a.\dot{c_1} c_2 c_3 \ldots c_{p - 1} \dot{c_p}$$其中，$a$ 是一个整数，$p\ge1$；对于 $1\le i\le p$，$c_i$ 是 $k$ 进制下的一位数字。 例如，在十进制下，$0.45454545\dots=0.\dot{4}\dot{5}$ 是纯循环的，它可以用 $\frac 5 {11}$、$\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666\dots=0.1\dot{6}$ 则不是纯循环的，它可以用 $\frac 1 6$ 等分数表示。 需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。 输入格式 输入文件只有一行，包含三个十进制数 $n,m,k$，意义如题所述。 输出格式 只输出一行一个整数，表示满足条件的美的数的个数。 样例输入 1 2 6 10 样例输出 1 4 样例输入 2 23333 666666 310 样例输出 2 5089564081 提示 对于所有的测试点，保证 $1\le n\le 10^9$，$1\le m\le 10^9$，$2\le k\le2000$。 首先考虑什么样的分数$\frac{x}{y}$满足他在$k$进制下是纯循环的，结论是满足$gcd(\frac{y}{gcd(x,y)},k)=1$的分数都是纯循环的。 证明的话，我们只考虑$gcd(x,y)=1$的情况，不为1的情况类似。那么$\frac{x}{y}$的小数部分只和$x\mod y$有关，那么如果他是纯循环的，假设循环节长度为$a$，一定有$x\equiv k^ax\mod y$，那么由于$(x,y)=1$，得到$k^a\equiv1\mod y$ 上述方程有解当且仅当$gcd(k,y)=1$，这个可以用反证法轻易得证。 因此我们要求就是$\sum_{i=1}^{m}[gcd(i,k)=1]\sum_{j=1}^{n}[gcd(i,j)=1]$，注意到$[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)$，于是 $$\begin{align}Ans&amp;=\sum_{i=1}^{m}[gcd(i,k)=1]\sum_{j=1}^{n}\sum_{d|gcd(i,j)}\mu(d)=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{m}[gcd(i,k)=1]\sum_{j=1}^{n}[d|gcd(i,j)]\\&amp;=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(id,k)=1]\lfloor\frac{n}{d}\rfloor=\sum_{d=1}^{min(n,m)}\mu(d)[gcd(d,k)=1]\lfloor\frac{n}{d}\rfloor\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,k)=1]\end{align}$$ 我们显然想要分块处理后面的部分，因此考虑怎么求$\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,k)=1]$，令$g(n)=\sum_{i=1}^{n}[gcd(i,k)=1]$ $$g(n)=\sum_{i=1}^{n}[gcd(i,k)=1]=\sum_{i=1}^{n}\sum_{d|gcd(i,k)}\mu(d)=\sum_{d|k}\lfloor\frac{n}{d}\rfloor\mu(d)$$ 因此我们可以在$O(\sqrt{k})$的复杂度内求出$g(n)$，现在考虑如何求$f(n,k)=\sum_{i=1}^{n}\mu(i)[gcd(i,k)=1]$，那么 $$\begin{align}f(n,k)&amp;=\sum_{i=1}^{n}\mu(i)\sum_{d|gcd(i,k)}\mu(d)=\sum_{d|k}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(id)\\&amp;=\sum_{d|k}\mu^2(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)[gcd(i,d)=1]=\sum_{d|k}\mu^2(d)f(\lfloor\frac{n}{d}\rfloor,d)\end{align}$$ 那么递归处理就行了，求一次的复杂度大概是$O(\sigma_0^2(k)\sqrt{k})+n^{\frac{2}{3}}$，边界情况是当$k=1$的时候，直接用杜教筛求$\mu(i)$的前缀和就行了 还有另外一种更快的处理方法。令$k=p^tq$，$p$为质数$$\begin{align}f(n,p^tq)&amp;=\sum_{i=1}^{n}\mu(i)[gcd(i,p^tq)=1]=\sum_{i=1}^{n}\mu(i)[gcd(i,q)=1]-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(ip)[gcd(i,pq=1)]\\&amp;=\sum_{i=1}^{n}\mu(i)[gcd(i,q)=1]+\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)[gcd(i,pq)=1]=f(n,q)+f(\lfloor\frac{n}{p}\rfloor,pq)\end{align}$$然后同样递归处理就行了，复杂度由因数个数变成了质因数个数。同样边界的时候用杜教筛求就好了。当$n=0$时直接返回。 记得一定要记忆化$f(n,k)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#define ll long long#define N 1000005using namespace std;ll n,m,k,mu[N],P[N],tot;bool mark[N];unordered_map&lt;ll,ll&gt;Q,S[2005];ll Gmu(ll x)&#123; if(x&lt;N)return mu[x]; if(Q.count(x))return Q[x]; ll ans=1,i,j; for(i=2;i&lt;=x;i=j+1) &#123; j=x/(x/i); ans-=(j-i+1)*Gmu(x/i); &#125; return Q[x]=ans;&#125;ll Gsum(ll x,ll p)&#123; ll i,j; if(p==1)return Gmu(x); if(x&lt;=1)return x; if(S[p].count(x))return S[p][x]; for(i=1;P[i]&lt;=p;i++)if(p%P[i]==0)break; i=P[i];j=p;while(j%i==0)j/=i; return S[p][x]=Gsum(x,j)+Gsum(x/i,i*j);&#125;ll Get(ll x)&#123; ll i,j,ans=0; for(i=1;i*i&lt;=k;i++) &#123; if(k%i)continue;j=k/i; ans+=(x/i)*(mu[i]-mu[i-1]); if(j!=i)ans+=(x/j)*(mu[j]-mu[j-1]); &#125; return ans;&#125;void Liner()&#123; ll i,j;mu[1]=1; for(i=2;i&lt;N;i++) &#123; if(!mark[i])P[++tot]=i,mu[i]=-1; for(j=1;j&lt;=tot&amp;&amp;i*P[j]&lt;N;j++) &#123; mark[i*P[j]]=1; if(i%P[j])mu[i*P[j]]=-mu[i]; else break; &#125; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; ll i,j,x,y,z,ans=0;Liner(); scanf("%lld%lld%lld",&amp;m,&amp;n,&amp;k); for(i=1;i&lt;=n&amp;&amp;i&lt;=m;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); ans+=(Gsum(j,k)-Gsum(i-1,k))*(m/i)*Get(n/i); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2016 网格（Tarjan求割点）]]></title>
    <url>%2F2018%2F04%2F19%2FNOI2016-%E7%BD%91%E6%A0%BC%EF%BC%88Tarjan%E6%B1%82%E5%89%B2%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2016】网格问题描述 跳蚤国王和蛐蛐国王在玩一个游戏。 他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \leq c \leq nm)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。 我们称占据的格子有公共边的两只跳蚤是相邻的。 我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。 现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。 例如：我们用图表示一只跳蚤，用图表示一只蛐蛐，那么左图描述了一个 $n=4, \ m=4, \ c=2$的情况。 这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。 你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。 输入格式 每个输入文件包含多组数据。输入文件的第一行只有一个整数 $T$，表示数据的组数。接下来依次输入 $T$ 组数据，每组数据的第一行包含三个整数 $n, m, c$。接下来 $c$ 行，每行包含两个整数 $x, y$ 表示第 $x$ 行，第 $y$ 列的格子被一个蛐蛐占据。每一组数据当中，同一个蛐蛐不会被多次描述。同一行相邻的整数之间由一个空格隔开。 输出格式 对于每一组数据依次输出一行答案。 如果这组数据中，蛐蛐国王的希望不能被达成，输出-1。否则，输出被替换的跳蚤的个数的最小值。 样例输入 44 4 21 14 42 3 11 22 2 21 12 21 1 0 样例输出 210-1 提示 对于所有的数据，$1 \leq n,m \leq 10^9, \ 0 \leq c \leq \text{min}(nm,10^5),\ 1 \leq x \leq n,\ 1 \leq y \leq m,\ 1 \leq T \leq 20$。 我们记 $\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和，则保证 $\sum c≤10^5$。 这题乍一看感觉很麻烦，但思索一下就能发现答案显然只可能是$-1,0,1,2$之一。考虑依次判断。 容易发现答案为$-1$当且仅当图中跳蚤数量小于二，或跳蚤数量等于二且相邻。 否则答案为$0$当且仅当原图中存在至少两只不连通的跳蚤。 否则答案为$1$当且仅当图中存在割点，否则答案为$2$ 然后发现棋盘很大，不可能把完整的图建出来，考虑只把关键点拿出来讨论。 容易发现可能成为割点的点只可能是障碍格子八连通的点，考虑只将这些点拿出来，但容易发现当有一个障碍在棋盘边缘时，这样做会出问题，那么考虑再往外拓展一圈，即拿出24个点来。 然后只需要跑个Tarjan求割点就行了。注意到判断答案是否为$0$只需要将八连通的障碍合并后讨论它相邻的格子就行了。 最后需要注意，上面的建图还是有反例，就是当两个障碍刚好在对角，且中间有三个格子时。 这个只需要最后判断割点八连通格子中是否有障碍就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#define ll long long#define N 3000233using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;typedef pair&lt;int,int&gt; par;const int mul=1e9+1;const int dx4[4]=&#123;1,-1,0,0&#125;,dy4[4]=&#123;0,0,1,-1&#125;;const int dx8[8]=&#123;1,0,-1,1,-1,1,0,-1&#125;,dy8[8]=&#123;-1,-1,-1,0,0,1,1,1&#125;;int T,n,m,c,bel[N],Bel;bool ex_cp,cut[N];vector&lt;par&gt;P,Q;vector&lt;int&gt;around[N],G[N];int cnt,dfn[N],low[N],be[N],scc,VT;bool valid(int x,int y)&#123;return x&lt;=n&amp;&amp;y&lt;=m&amp;&amp;x&gt;0&amp;&amp;y&gt;0;&#125;struct Hash_table&#123; const static int MOD=666666; int tot,las[MOD],nex[N],val[N],stx[N],sty[N]; void clear() &#123; tot=0;memset(las,0,sizeof(las)); &#125; void ins(int x,int y,int k) &#123; int p=(1ll*x*mul+y)%MOD,i; val[++tot]=k; stx[tot]=x;sty[tot]=y; nex[tot]=las[p]; las[p]=tot; &#125; int find(int x,int y) &#123; int p=(1ll*x*mul+y)%MOD,i; for(i=las[p];i;i=nex[i])if(stx[i]==x&amp;&amp;sty[i]==y)return val[i]; return -1; &#125;&#125;A,B;void Tarjan(int x,int fa)&#123; int i,y,son=0; dfn[x]=low[x]=++VT;be[x]=scc; for(i=0;i&lt;G[x].size();i++) &#123; y=G[x][i];if(y==fa)continue; if(!dfn[y]) &#123; Tarjan(y,x);son++; low[x]=min(low[x],low[y]); if(dfn[x]&lt;=low[y])cut[x]=1; &#125; else low[x]=min(dfn[y],low[x]); &#125; if(fa==0&amp;&amp;son==1)cut[x]=0;&#125;void find_bel(int x,int y,int lab)&#123; bel[lab]=Bel; int i,tx,ty,p; for(i=0;i&lt;8;i++) &#123; tx=dx8[i]+x;ty=dy8[i]+y; p=A.find(tx,ty); if(p!=-1&amp;&amp;bel[p]==0)find_bel(tx,ty,p); &#125;&#125;bool Connect()&#123; int i,k,x,y,tx,ty,dx,dy,p,q; for(i=0;i&lt;c;i++)A.ins(P[i].first,P[i].second,i); for(i=0;i&lt;c;i++) if(bel[i]==0) &#123; Bel++; find_bel(P[i].first,P[i].second,i); &#125; for(i=1;i&lt;=Bel;i++)around[i].clear(); for(i=0;i&lt;c;i++) &#123; x=P[i].first;y=P[i].second; for(dx=-2;dx&lt;=2;dx++) for(dy=-2;dy&lt;=2;dy++) if(dx||dy) &#123; tx=dx+x;ty=dy+y; if(!valid(tx,ty))continue; if(A.find(tx,ty)!=-1||B.find(tx,ty)!=-1)continue; cnt++; Q.push_back(par(tx,ty)); around[bel[i]].push_back(cnt); B.ins(tx,ty,cnt); &#125; &#125; for(i=1;i&lt;=cnt;i++)G[i].clear(); for(i=0;i&lt;cnt;i++) &#123; x=Q[i].first;y=Q[i].second;p=i+1; for(k=0;k&lt;4;k++) &#123; tx=x+dx4[k]; ty=y+dy4[k]; q=B.find(tx,ty); if(q!=-1)G[p].push_back(q); &#125; &#125; fill(dfn,dfn+cnt+1,0); fill(low,low+cnt+1,0); fill(be,be+cnt+1,0); fill(cut,cut+cnt+1,0); for(i=1;i&lt;=cnt;i++)if(be[i]==0)scc++,Tarjan(i,0); for(i=0;i&lt;cnt;i++) if(cut[i+1]) &#123; x=Q[i].first;y=Q[i].second; for(k=0;k&lt;8;k++) &#123; tx=x+dx8[k]; ty=y+dy8[k]; if(A.find(tx,ty)!=-1)ex_cp=1; &#125; &#125; for(i=1;i&lt;=Bel;i++) &#123; p=-1; for(k=0;k&lt;around[i].size();k++) &#123; if(p==-1)p=be[around[i][k]]; else if(be[around[i][k]]!=p)return 0; &#125; &#125; return 1;&#125;void Clear()&#123; P.clear();Q.clear(); A.clear();B.clear(); fill(bel,bel+c+1,0); Bel=cnt=scc=VT=ex_cp=0;&#125;int tmain()&#123; int T;_R(T); while(T--) &#123; int i,x,y; _R(n);_R(m);_R(c); Clear(); for(i=1;i&lt;=c;i++) &#123; _R(x);_R(y); P.push_back(par(x,y)); &#125; if((ll)n*m-c&lt;2ll)&#123;puts("-1");continue;&#125; if(!Connect())&#123;puts("0");continue;&#125; if((ll)n*m-c==2ll) &#123; if(scc==1||!c)puts("-1"); else puts("0");continue; &#125; if(ex_cp||n==1||m==1)puts("1"); else puts("2"); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); tmain(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); &#125;]]></content>
      <categories>
        <category>图论</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2016 优秀的拆分（二分+哈希+差分数组）]]></title>
    <url>%2F2018%2F04%2F19%2FNOI2016-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86%EF%BC%88%E4%BA%8C%E5%88%86-%E5%93%88%E5%B8%8C-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2016】优秀的拆分问题描述 如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。 一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。 现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。 以下事项需要注意： 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。 字符串本身也是它的一个子串。 输入格式 每个输入文件包含多组数据。输入文件的第一行只有一个整数 $T$，表示数据的组数。接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。 输出格式 输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。 样例输入 4aabbbbccccccaabaabaabaabbaabaababaaba 样例输出 3547 提示 对于全部的测试点，$1 \leq T \leq 10, \ n \leq 30000$。 考虑枚举$AA$与$BB$的分界，令$A[i]$表示以$i$结尾的形如$AA$的串的个数，$B[i]$表示以$i$开头的形如$BB$的串的个数，那么$Ans=\sum A[i]\times B[i+1]$ 那么考虑如何求出$A[i]$和$B[i]$，下面只讨论$A[i]$，$B[i]$同理。 考虑一个长为$2L$的形如$AA$的串，那么该串一定经过形如了$s[iL]$和$s[(i+1)L]$两个位置，我们考虑先枚举$L$，再枚举$pos=iL$，那么算出$s[iL],s[(i+1)L]$往前后分别能匹配多长，假设往前能匹配的长度位$pre（包含iL）$，往后能匹配的长度为$suf（包含iL）$，那么可以发现在区间$[(i+1)L-pre+L,(i+1)L+suf-1]$都可以作为一个$AA$串的结尾。因此只需要区间$+1$即可。这里可以用差分数组来做。 但是注意到直接这样算会出现重复，因此最后的区间左端点应该是$max{(i+1)L-pre+L,(i+1)L}$，区间右端点应该是$min{(i+1)L+suf-1,(i+2)L-1}$ 最后，处理往前和往后的匹配长度时，可以用后缀自动机或后缀数组处理，也可以直接用哈希+二分解决，复杂度都差不多。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 30005#define ll long long#define ull unsigned long longusing namespace std;char buf[1&lt;&lt;20],*p11,*p22;#define GC (p11==p22&amp;&amp;(p22=(p11=buf)+fread(buf,1,1000000,stdin),p11==p22)?0:*p11++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;inline int _S(char *c)&#123; char *t=c,ch=GC; while(ch&lt;'a'||ch&gt;'z')ch=GC; for(;ch&gt;='a'&amp;&amp;ch&lt;='z';ch=GC)*t++=ch; *t=0;return t-c;&#125;const ull p1=1234321237;const ull p2=1313131312;ull Aash[N],Bash[N],Pow1[N],Pow2[N];long long ans;int T,n,A[N],B[N];char s[N];void Init()&#123; fill(Aash,Aash+n+2,0); fill(Bash,Bash+n+2,0); fill(A,A+n+2,0); fill(B,B+n+2,0);&#125;bool check(int x1,int y1,int x2,int y2)&#123; ull x=Aash[y1]-Aash[x1-1]*Pow1[y1-x1+1]; ull y=Aash[y2]-Aash[x2-1]*Pow1[y2-x2+1]; ull p=Bash[y1]-Bash[x1-1]*Pow2[y1-x1+1]; ull q=Bash[y2]-Bash[x2-1]*Pow2[y2-x2+1]; return x==y&amp;&amp;p==q;&#125;int Gpre(int x,int y,int L)&#123; int l=1,r=min(x,L),mid; while(l&lt;=r) &#123; mid=l+r&gt;&gt;1; if(check(x-mid+1,x,y-mid+1,y))l=mid+1; else r=mid-1; &#125; return r;&#125;int Gsuf(int x,int y,int L)&#123; int l=1,r=min(n-y+1,L),mid; while(l&lt;=r) &#123; mid=l+r&gt;&gt;1; if(check(x,x+mid-1,y,y+mid-1))l=mid+1; else r=mid-1; &#125; return r;&#125;void Get(int x,int y,int L)&#123; int i,j,k,pre,suf,l,r; pre=Gpre(x,y,L); suf=Gsuf(x,y,L); l=max(y-pre+L,y); r=min(y+suf-1,y+L-1); if(l&lt;=r) &#123; A[l]++;A[r+1]--; B[l-(L&lt;&lt;1)+1]++; B[r-(L&lt;&lt;1)+2]--; &#125;&#125;int main()&#123; int i,j,k,x,y; _R(T);Pow1[0]=Pow2[0]=1; while(T--) &#123; n=_S(s+1);Init();ans=0; for(i=1;i&lt;=n;i++)Pow1[i]=Pow1[i-1]*p1; for(i=1;i&lt;=n;i++)Pow2[i]=Pow2[i-1]*p2; for(i=1;i&lt;=n;i++)Aash[i]=Aash[i-1]*p1+s[i]; for(i=1;i&lt;=n;i++)Bash[i]=Bash[i-1]*p2+s[i]; for(i=1;i&lt;=(n&gt;&gt;1);i++) for(j=1;j+i&lt;=n;j+=i)if(s[j]==s[j+i])Get(j,j+i,i); for(i=1;i&lt;=n;i++)A[i]+=A[i-1],B[i]+=B[i-1]; for(i=1;i&lt;n;i++)ans+=1ll*A[i]*B[i+1]; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>分治法</category>
        <category>杂学</category>
        <category>二分答案</category>
        <category>哈希</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>二分答案</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2017 蔬菜（贪心+并查集+堆）]]></title>
    <url>%2F2018%2F04%2F19%2FNOI2017-%E8%94%AC%E8%8F%9C%EF%BC%88%E8%B4%AA%E5%BF%83-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「NOI2017」蔬菜问题描述 小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。在蔬菜仓库中，共存放有 $n$ 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。在计算销售蔬菜的收益时，每销售一个单位第 $i$ 种蔬菜，就可以获得 $a_i$ 的收益。特别地，由于政策鼓励商家进行多样化销售，第一次销售第 $i$ 种蔬菜时，还会额外得到 $s_i$ 的额外收益。在经营开始时，第 $i$ 种蔬菜的库存为 $c_i$ 个单位。然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 $i$ 种蔬菜，存在保鲜值 $x_i$，每天结束时会 有 $x_i$ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固 定的，不随销售发生变化）形式化地：对于所有的满足条件 $d\times x_i \leq c_i$ 的正整数 $d$ ，有 $x_i$ 个单位的蔬菜将在 第 $d$ 天结束时变质。特别地，若 $(d−1)\times x_i \leq c_i &lt; d\times x_i$ ，则有 $c_i−(d−1)\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。同时，每天销售的蔬菜 . 总量也是有限的，最多不能超过 $m$ 个单位。现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益？ 输入格式 第一行包含三个正整数 $n,m,k$，分别表示蔬菜的种类数目、每天能售出蔬菜总量上限、小 N 提出的问题的个数。接下来 $n$ 行，每行输入四个非负整数，描述一种蔬菜的特点，依次为 $a_i,s_i,c_i,x_i$ ， 意义如上文所述。接下来 $k$ 行，每行输入一个非负整数 $p_j$ ，意义如上文所述。 输出格式 输出 $k$ 行，每行包含一个整数，第 $i$ 行的数表示第 $i$ 个问题的答案。 样例输入 2 3 23 3 3 32 5 8 313 样例输出 1627 提示 $n \leq 10^5, m \leq 10, p_j \leq 10^5, 0 &lt; a_i,c_i \leq 10^9 , 0 \leq s_i,x_i \leq10^9 $ 首先这题容易想到费用流，即将每天看成一个点，从源点往每天连边，容量为$m$，然后对每种蔬菜，将他拆成$\lceil \frac{C}{x}\rceil$天卖出，每天卖$x$，然后最后一天处理一下$a_i+s_i$即可。 然而费用流显然是过不了大数据的。正解考虑贪心。 我们考虑一个朴素的贪心，如果能卖菜的天数确定，那么将蔬菜的权值从大到小排序，用堆维护，然后一个一个卖，然后显然如果要卖这个蔬菜，就应该安排到他最后能卖的一天卖，这个时间由$\lceil \frac{C}{x}\rceil$给出，那么我们就将他安排一单位到这一天卖，其他的放回堆中。如果这一天已经卖了$m$个，那就要往前找到第一个没有卖到$m$个的位置。这个可以用并查集来实现，如果某一天已经卖了$m$个，就将他和前一天合并。这样并查集的根就是他往前第一个还能卖菜的位置。 然后我们考虑处理多组询问，实际上，当我们求出了$p$的卖菜方案$S_p$之后，$p-1$的卖菜方案$S_{p-1}$一定是$S_p$的一个子集，因为$S_p$中的所有元素都可以在前$p-1$天卖出。因此只需要从$S_p$中取$(p-1)m$个元素就行了。 因此我们只需要处理出$p_{max}$的答案，然后记录下$ans[i]$表示选$i$个蔬菜的最优答案就行了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define N 100005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;struct node&#123;int val,id;&#125;;bool operator&lt;(node a,node b)&#123;return a.val&lt;b.val;&#125;priority_queue&lt;node&gt;Q;int sum,n,m,q,a[N],s[N],c[N],x[N],fa[N],cnt[N],qry[N],Max;ll ans[N*10];int GF(int x)&#123;return x==fa[x]?x:fa[x]=GF(fa[x]);&#125;int main()&#123; int i;_R(n);_R(m);_R(q); for(i=1;i&lt;=n;i++) &#123; _R(a[i]);_R(s[i]);_R(c[i]);_R(x[i]); Q.push((node)&#123;a[i]+s[i],i&#125;); &#125; for(i=1;i&lt;=q;i++) &#123; _R(qry[i]); Max=max(Max,qry[i]); &#125; for(i=1;i&lt;=Max;i++)fa[i]=i,cnt[i]=m; while(Q.size()) &#123; node tmp=Q.top();Q.pop(); int t=x[tmp.id]?(c[tmp.id]-1)/x[tmp.id]+1:Max; if(t&gt;Max)t=Max; t=GF(t);if(!cnt[t])continue; cnt[t]--;sum++;c[tmp.id]--; if(!cnt[t])fa[t]=fa[t-1]; ans[sum]=ans[sum-1]+tmp.val; if(c[tmp.id])Q.push((node)&#123;a[tmp.id],tmp.id&#125;); &#125; for(i=1;i&lt;=q;i++)printf("%lld\n",ans[min(sum,qry[i]*m)]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>贪心</category>
        <category>堆</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2017 蚯蚓排队（哈希）]]></title>
    <url>%2F2018%2F04%2F17%2FNOI2017-%E8%9A%AF%E8%9A%93%E6%8E%92%E9%98%9F%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「NOI2017」蚯蚓排队问题描述 蚯蚓幼儿园有$n$只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。 所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。 神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种： 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$ ，询问所有这些$f(t)$的乘积对 $998244353$ 取模后的结果。其中$f(t)$的定义如下： 对于当前的蚯蚓队伍，定义某个蚯蚓的向后 $k$ 数字串为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有向后$k$数字串。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的向后 $3$ 数字串为456， $22$ 号蚯蚓没有向后 $3$ 数字串，但其向后 $2$ 数字串为56，其向后 $1$ 数字串为5。 而 $f(t)$ 表示所有蚯蚓中，向后 $k$ 数字串恰好为 $t$ 的蚯蚓只数。 输入格式 从标准输入读入数据。 输入文件的第一行有两个正整数 $n,m$ ，分别表示蚯蚓的只数与操作次数。 第二行包含 $n$ 个不超过 $6$ 的正整数，依次表示编号为 $1,2,\dots,n$ 的蚯蚓的长度。 接下来 $m$ 行，每行表示一个操作。每个操作的格式可以为： 1 $i$ $j$（$1 \leq i, j \leq n$）表示：令 $i$ 号与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，新队伍中， $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后。保证在此操作之前， $i$ 号蚯蚓在某个队伍的队尾， $j$ 号蚯蚓在某个队伍的队首，且两只蚯蚓不在同一个队伍中。 2 $i$（$1 \leq i \leq n$）表示：令 $i$ 号蚯蚓与紧挨其后一个蚯蚓分离为两个队伍。保证在此操作之前， $i$ 号蚯蚓不是某个队伍的队尾。 3 $s$ $k$（$k$为正整数，$s$为一个长度至少为$k$的数字串）表示：询问 $s$ 的每个长度为 $k$ 的子串 $t$ 的 $f(t)$ 的乘积，对998244353取模的结果。 $f(t)$ 的定义见题目描述。 同一行输入的相邻两个元素之间，用恰好一个空格隔开。 输入文件可能较大，请不要使用过于缓慢的读入方式。 输出格式 输出到标准输出。 依次对于每个形如3 $s$ $k$的操作，输出一行，仅包含一个整数，表示询问的结果。 样例输入 5 93 1 3 5 33 333135 23 333135 11 1 31 2 51 3 21 5 43 333135 23 333135 13 333135 3 样例输出 0811810 提示 保证 $n \leq 2 \times 10^{5}$，$m \leq 5 \times 10^{5}$，$k \leq 50$ 。 设 $\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\sum |s| \leq 10^{7}$ 。 设 $c$ 为某个输入文件中形如2 $i$的操作的次数，则 $c \leq 10^{3}$ 。 每个测试点的详细信息见下表： 测试点编号 $n$ $m$ $k$ $\sum |s|$ $c$ 全为$\texttt{1}$ 1 $=1$ $\leq 10^{3}$ $=1$ $\leq 10^{3}$ $=0$ No 2 $\leq 20$ $\leq 40$ $\leq 10$ 3 $\leq 150$ $\leq 2,000$ $\leq 50$ $\leq 10^{3}$ 4 $\leq 500$ $\leq 600$ $=0$ 5 $\leq 10^{3}$ $\leq 2,000$ $\leq 10^{3}$ 6 $\leq 5 \times 10^{4}$ $\leq 6 \times 10^{4}$ $\leq 5$ $\leq 5 \times 10^{4}$ 7 $\leq 50$ $=0$ Yes 8 No 9 $\leq 10^{3}$ 10 $\leq 8 \times 10^{4}$ $\leq 2.5 \times 10^{6}$ $=0$ 11 $\leq 10^{3}$ 12 $\leq 10^{5}$ $\leq 1.1 \times 10^{5}$ $\leq 6$ $\leq 10^{5}$ 13 $\leq 50$ $=0$ Yes 14 No 15 $\leq 10^{3}$ 16 $\leq 1.5 \times 10^{5}$ $\leq 5 \times 10^{6}$ $=0$ 17 $\leq 10^{3}$ 18 $\leq 2 \times 10^{5}$ $\leq 5 \times 10^{5}$ $=1$ $\leq 10^{7}$ $=0$ 19 $\leq 10^{3}$ 20 $\leq 2.5 \times 10^{5}$ $\leq 7$ $\leq 2 \times 10^{5}$ 21 $\leq 50$ $=0$ Yes 22 No 23 $\leq 10^{3}$ 24 $\leq 3 \times 10^{5}$ $\leq 10^{7}$ $=0$ 25 $\leq 10^{3}$ 如果一个测试点的“全为1”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为1，并且所有询问串$s$的每一位也均为1。 注意到这个题$k\leq 50$，那么我们考虑直接暴力维护所有长度在$[1,50]$之间的每种子串的数量，那么考虑用哈希+哈希表来维护每个子串的出现次数。然后修改用链表来实现，每次暴力维护跨过修改位置的子串即可。 这样做的复杂度可以参考知乎lzz的回答 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005#define M 100000000#define ull unsigned long longusing namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;inline int _S(char *c)&#123; char *t=c,ch=GC; while(ch&lt;48||ch&gt;57)ch=GC; for(;ch&gt;47&amp;&amp;ch&lt;58;ch=GC)*t++=ch; *t=0;return t-c;&#125;const int Mod=1e7+233;const int mod=998244353;const ull pi=1234321237;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int n,m,A[N],pre[N],nex[N];ull Pow[N];char s[N];struct Hash_table&#123; int tot,las[Mod],nex[M],val[M];ull state[M]; int&amp; operator[](ull v) &#123; int p=v%Mod; for(int i=las[p];i;i=nex[i]) if(state[i]==v)return val[i]; state[++tot]=v; nex[tot]=las[p]; las[p]=tot; return val[tot]; &#125;&#125;Q;int main()&#123; int i,j,k,x,y,p,q,ans,l;ull v1,v2;Pow[0]=1; _R(n);_R(m); for(i=1;i&lt;=n;i++)_R(A[i]); for(i=1;i&lt;=50;i++)Pow[i]=Pow[i-1]*pi; for(i=1;i&lt;=n;i++)Q[A[i]]++; while(m--) &#123; _R(k); if(k==1) &#123; _R(x);_R(y); pre[y]=x;nex[x]=y;v1=0; for(i=1,p=x;p&amp;&amp;i&lt;50;i++,p=pre[p]) &#123; v1*=pi;v1+=A[p];v2=0; for(j=1,q=y;q&amp;&amp;i+j&lt;=50;j++,q=nex[q]) v2+=Pow[i+j-1]*A[q],Q[v1+v2]++; &#125; &#125; else if(k==2) &#123; _R(x);y=nex[x]; pre[y]=nex[x]=0;v1=0; for(i=1,p=x;p&amp;&amp;i&lt;50;i++,p=pre[p]) &#123; v1*=pi;v1+=A[p];v2=0; for(j=1,q=y;q&amp;&amp;i+j&lt;=50;j++,q=nex[q]) v2+=Pow[i+j-1]*A[q],Q[v1+v2]--; &#125; &#125; else &#123; l=_S(s+1);_R(x);v1=0;ans=1; for(i=l;i&gt;l-x+1;i--)v1=v1*pi+s[i]-48; for(i=l-x+1;i&gt;0;i--)v1=v1*pi+s[i]-48,ans=mul(ans,Q[v1]),v1-=Pow[x-1]*(s[i+x-1]-48); printf("%d\n",ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2017 整数（线段树）]]></title>
    <url>%2F2018%2F04%2F17%2FNOI2017-%E6%95%B4%E6%95%B0%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「NOI2017」整数问题描述 在人类智慧的山巅，有着一台字长为 $1048576$ 位的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你…… P 博士将他的计算任务抽象为对一个整数的操作。 具体来说，有一个整数 $x$ ，一开始为 $0$。 接下来有 $n$ 个操作，每个操作都是以下两种类型中的一种： 1 $a$ $b$ ：将 $x$ 加上整数 $a \cdot 2 ^ b$，其中 $a$ 为一个整数，$b$ 为一个非负整数 2 $k$ ：询问 $x$ 在用二进制表示时，位权为 $2 ^ k$ 的位的值（即这一位上的 $1$ 代表 $2 ^ k$ ） 保证在任何时候，$x \ge 0$。 输入格式 从标准输入读入数据。 输入的第一行包含四个正整数 $n, t_1, t_2, t_3$，$n$ 的含义见题目描述，$t_1, t_2, t_3$ 的具体含义见子任务。 接下来 $n$ 行，每行给出一个操作，具体格式和含义见题目描述。 同一行输入的相邻两个元素之间，用恰好一个空格隔开。 输出格式 输出到标准输出。 对于每个询问操作，输出一行，表示该询问的答案（$0$ 或 $1$）。 对于加法操作，没有任何输出。 样例输入 10 3 1 21 100 01 2333 01 -233 02 52 72 151 5 152 151 -1 122 15 样例输出 01010 提示 子任务在所有测试点中，$1 \le t_1 \le 3, 1 \le t_2 \le 4, 1 \le t_3 \le 2$。不同的 $t_1, t_2, t_3$ 对应的特殊限制如下： 对于 $t_1 = 1$ 的测试点，满足 $a = 1$ 对于 $t_1 = 2$ 的测试点，满足 $|a| = 1$ 对于 $t_1 = 3$ 的测试点，满足 $|a| \le 10 ^ 9$ 对于 $t_2 = 1$ 的测试点，满足 $0 \le b,k \le 30$ 对于 $t_2 = 2$ 的测试点，满足 $0 \le b,k \le 100$ 对于 $t_2 = 3$ 的测试点，满足 $0 \le b,k \le n$ 对于 $t_2 = 4$ 的测试点，满足 $0 \le b,k \le 30 n$ 对于 $t_3 = 1$ 的测试点，保证所有询问操作都在所有修改操作之后 对于 $t_3 = 2$ 的测试点，不保证询问操作和修改操作的先后顺序 本题共 25 个测试点，每个测试点 4 分。各个测试点的数据范围如下： 测试点编号 $n \le$ $t_1$ $t_2$ $t_3$ $1$ $10$ $3$ $1$ $2$ $2$ $100$ $2$ $3$ $2000$ $4$ $4000$ $1$ $3$ $5$ $6000$ $3$ $1$ $6$ $8000$ $2$ $2$ $7$ $9000$ $3$ $4$ $8$ $10000$ $3$ $9$ $30000$ $4$ $10$ $50000$ $1$ $11$ $60000$ $3$ $2$ $12$ $65000$ $2$ $4$ $13$ $70000$ $3$ $14$ $200000$ $15$ $300000$ $2$ $16$ $400000$ $3$ $17$ $500000$ $3$ $18$ $600000$ $4$ $19$ $700000$ $20$ $800000$ $1$ $21$ $900000$ $2$ $22$ $930000$ $3$ $3$ $23$ $960000$ $4$ $1$ $24$ $990000$ $3$ $2$ $25$ $1000000$ $4$ 首先容易想到如果只有加法，那么可以暴力的维护每个二进制位模拟进位，根据势能分析$(?)$可知，复杂度是均摊$O(1)$的。 考虑减法，由于保证了任意时刻结果非负，那么可以将加和减分开存成两个数$s1$和$s2$，这样就只用做加法了。然后判断答案的时候由于非负，那么$x$位更高的部分是不用管的，只考虑$0-x$位即可。 然后发现只需要比较$[0,x-1]$位的大小就行了。如果$s1&gt;s2$，那么答案就是$s1[x]\ xor\ s2[x]$，否则答案就是$s1[x]==s2[x]$，这个用线段树维护一下$s1[i]\ xor\ s2[i]$的值就能解决了。 复杂度$O(n\log N)$需要优秀的常数才能通过。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC;bool f=0; while(t!='-'&amp;&amp;(t&lt;48||t&gt;57))t=GC; if(t=='-')f=1,t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; x=f?-x:x;&#125;const int N=1&lt;&lt;25;int n,t1,t2,t3,a,b,L,R;bitset&lt;N&gt;s1,s2;bitset&lt;N&lt;&lt;1&gt;v;void CHA()&#123; if(!a)return; int w=a&gt;0?a:-a,t[32],i,cnt=0,p; for(i=0;i&lt;31;i++)if(w&gt;&gt;i&amp;1)t[++cnt]=i; L=b+t[1];R=b+t[cnt]; if(a&gt;0) &#123; for(i=1;i&lt;=cnt;i++) &#123; p=t[i]+b; while(s1[p])s1[p++]=0,R=max(R,p); s1[p]=1; &#125; &#125; else &#123; for(i=1;i&lt;=cnt;i++) &#123; p=t[i]+b; while(s2[p])s2[p++]=0,R=max(R,p); s2[p]=1; &#125; &#125;&#125;void MD()&#123; for(int i=L;i&lt;=R;i++)v[i+N]=s1[i]^s2[i]; for(L=(L+N)&gt;&gt;1,R=(R+N)&gt;&gt;1;L;L&gt;&gt;=1,R&gt;&gt;=1) for(int i=L;i&lt;=R;i++)v[i]=v[i&lt;&lt;1]|v[i&lt;&lt;1|1];&#125;int find(int k)&#123; for(k+=N;k;k&gt;&gt;=1) if(k&amp;1&amp;v[k^1]) &#123; for(k^=1;k&lt;N;k=k&lt;&lt;1|v[k&lt;&lt;1|1]); return k-N; &#125; return -1;&#125;int main()&#123; int i,j,k,x,y; _R(n);_R(t1);_R(t2);_R(t3); for(i=1;i&lt;=n;i++) &#123; _R(k); if(k==1)_R(a),_R(b),CHA(),MD(); else &#123; _R(a);x=find(a); if(x==-1||s1[x]&gt;s2[x])printf("%d\n",s1[a]^s2[a]); else printf("%d\n",s1[a]==s2[a]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2017模拟 原谅（凸包+数学期望）]]></title>
    <url>%2F2018%2F04%2F16%2FNOI2017%E6%A8%A1%E6%8B%9F-%E5%8E%9F%E8%B0%85%EF%BC%88%E5%87%B8%E5%8C%85-%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2017模拟】原谅问题描述 终其一生，我们在寻找一个原谅。 犯下了太多错，要原谅的那个人，永远都是自己。 Samjia在深夜中望见了没有边界的人生，他没有想到过自己犯下了这么多的错误，他想在他的一生中寻求一个原谅。 他的人生是一个没有边界的平面，平面上有n个错误，每个错误是一个点，每个点i有一定的坐标(x[i],y[i])，有一个参数p 表示每个点有p的概率出现在平面上，注意两个不同的点的出现互相没有影响，Samjia可以在两个点之间连一条线段，两条线段不能在除了端点以外的地方相交，现在Samjia想知道他最多可以连的线段数的期望。 温馨提示：请看最后面的提示：） 本题的答案在mod 100000007意义下计算 输入格式 第一行两个正整数n和p表示平面上有n个点以及每个点出现概率为p 接下来n行第i行两个实数x[i]和y[i]表示一个点的坐标 保证不存在三点共线 输出格式 一行一个正整数表示Samjia最多可以连的线段数的期望 样例输入 3 10000001 0 1 1 0 0 0 样例输出 39000003 提示： 数据中的p为0.3 1×3×(0.3×0.3×0.7)+3×0.3×0.3×0.3=0.27 贡献为1的情况有三种 贡献为3的情况有一种 对于20%的数据，p=1,1&lt;=n&lt;=5 对于40%的数据，p=1,1&lt;=n&lt;=1000 对于70%的数据，1&lt;=n&lt;=200 对于100%的数据，1&lt;=n&lt;=1000 坐标的绝对值小于等于10^4 保证0&lt;=p&lt;100000007 欧拉公式 在一个平面图内，设点数为V，边数为E，有界面数为F 一定满足：V+F-E=1 首先考虑对于一个给定的图，如何连边是最优的，答案是先求出凸包，然后从凸包上一个点往其他凸包上的点连边，然后做三角剖分就是最优解。 然后可以得到边数和凸包上的点存在关系。假设凸包上有$k$个点，总共有$V$个点，$E$条边，那么可以得到$$E=k+(k-3)+3(V-k)=3V-k-3$$那么我们有$E(E)=3E(V)+E(k)-3$ 那么问题变成如何求期望点数和凸包上期望点数，$E(V)$很好求，主要考虑$E(k)$ 注意到凸包上的点数可以通过规定边的方向从而等效于凸包上的有向线段数量。 那么我们考虑求出每条有向线段在凸包上的概率，这个比较容易求，只要求在他外边的点都不出现且两个端点出现就行了。然后就可以极角排序之后算一算了。 最后注意到当所有点都没出现的时候，会多减一个$3$，加回去就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 2005#define int long longusing namespace std;const double eps=1e-10;const int mod=100000007;int n,p[N],q[N],ans,tot;int add(int x,int y)&#123;x+=y;return x&gt;=mod?x-mod:x;&#125;int sub(int x,int y)&#123;x-=y;return x&lt;0?x+mod:x;&#125;int mul(int x,int y)&#123;return 1ll*x*y%mod;&#125;struct node&#123;double x,y,angle;&#125;P[N],T[N];bool operator&lt;(node a,node b)&#123;return a.angle&lt;b.angle;&#125;node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;double operator*(node a,node b)&#123;return a.x*b.y-a.y*b.x;&#125;void Work(int x)&#123; int i,j,k,cnt;tot=0; for(i=1;i&lt;=n;i++)if(i!=x)T[++tot]=P[i]-P[x],T[tot].angle=atan2(T[tot].y,T[tot].x);// for(i=1;i&lt;=tot;i++)// &#123;// k=0;// for(j=1;j&lt;=tot;j++)if(T[i]*T[j]&lt;0)k++;// ans=sub(ans,mul(q[k],p[2]));// &#125; sort(T+1,T+tot+1);j=1;cnt=0; for(i=1;i&lt;=tot;i++) &#123; while ((T[i]*T[j%tot+1])&gt;0)j=j%tot+1,cnt++; ans=sub(ans,mul(q[n-2-cnt],p[2])); if(cnt)cnt--; else j++; &#125;// sort(T+1,T+tot+1);// for(i=1;i&lt;=tot;i++)T[tot+i]=T[i];// i=tot+1;j=1;// while(i&lt;=tot+tot)// &#123;// while(j&lt;i&amp;&amp;)j++;// ans=sub(ans,mul(q[i-j],p[2]));i++;// &#125;&#125;main()&#123; int i,j,k; scanf("%lld%lld",&amp;n,&amp;p[1]); p[0]=1;q[0]=1;q[1]=sub(1,p[1]); for(i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;P[i].x,&amp;P[i].y); for(i=2;i&lt;=n;i++)p[i]=mul(p[i-1],p[1]); for(i=2;i&lt;=n;i++)q[i]=mul(q[i-1],q[1]); ans=mul(mul(3,n),p[1]);ans=sub(ans,3); ans=add(ans,mul(3,q[n])); for(i=1;i&lt;=n;i++)Work(i); ans%=mod;ans+=mod;ans%=mod; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>概率与期望</category>
        <category>计算几何</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FJ集训2015 签到题（旋转卡壳）]]></title>
    <url>%2F2018%2F04%2F16%2FFJ%E9%9B%86%E8%AE%AD2015-%E7%AD%BE%E5%88%B0%E9%A2%98%EF%BC%88%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【FJ集训2015】签到题问题描述给定一个n个点的严格凸多边形（各个内角&lt;180°），现在要切出两个非退化三角形（三点不共线），要求两个三角形顶点必须是凸多边形的顶点，且三角形不可相交（但是点或边可以重合）。求两个三角形面积之差的最大值。 输入格式第一行，一个整数N。 第二到N+1行，每行两个整数xi,yi，表示多边形的一个点，保证顶点按顺时针或逆时针顺序给出。 输出格式输出答案，精确到小数点后1位。 样例输入 1 4 0 0 0 1 1 2 1 0 样例输出 1 0.5 样例输入 2 5 0 0 -1 6 0 7 2 8 7 7 样例输出 2 24.0 提示 对于15%的数据，$N&lt;=10$ 对于45%的数据，$N&lt;=307$ 对于100%的数据，$4&lt;=N&lt;=5000， 0&lt;=|xi|,|yi|&lt;=10^8$ 为了使面积之差最大，我们考虑枚举面积较大的一个三角形，那么当该三角形确定的时候，容易发现此时面积最小的三角形一定是三个相邻的顶点构成的，因此只需要在旋转卡壳的时候记录一下底边下面的三角形最小面积就行了。卡完一圈就能算出答案了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 10005#define ll long longusing namespace std;struct node&#123;ll x,y;&#125;P[N];node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;ll operator*(node a,node b)&#123;return a.x*b.y-a.y*b.x;&#125;ll n,Ans=-9e18;ll Area(ll i,ll j,ll k)&#123; node w=P[j]-P[i],v=P[k]-P[i]; return abs(w*v);&#125;int main()&#123; ll i,j,k,x,y,Max,Min; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%lld%lld",&amp;x,&amp;y); P[i]=(node)&#123;x,y&#125;;P[n+i]=P[i]; &#125; P[0]=P[n]; for(i=1;i&lt;=n;i++) for(j=i+2,k=i+3,Min=9e18;j&lt;i+n&amp;&amp;k&lt;i+n;j++) &#123; while(k&lt;i+n-1&amp;&amp;Area(k+1,i,j)&gt;=Area(k,i,j))k++; Min=min(Min,Area(j,j-1,j-2)); Max=Area(i,j,k);Ans=max(Ans,Max-Min); &#125; if(Ans&amp;1)printf("%lld.5",Ans&gt;&gt;1); else printf("%lld.0",Ans&gt;&gt;1);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>旋转卡壳</category>
      </categories>
      <tags>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2016 妖怪（三分+凸包）]]></title>
    <url>%2F2018%2F04%2F15%2FSCOI2016-%E5%A6%96%E6%80%AA%EF%BC%88%E4%B8%89%E5%88%86-%E5%87%B8%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【Scoi2016】妖怪问题描述 邱老师是妖怪爱好者，他有n只妖怪，每只妖怪有攻击力atk和防御力dnf两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。环境对妖怪的战斗力有很大影响，在某种环境中，妖怪可以降低自己k×a点攻击力，提升k×b点防御力或者，提升自己k×a点攻击力，降低k×b点防御力，a，b属于正实数，k为任意实数，但是atk和dnf必须始终非负。妖怪在环境(a,b)中的战斗力为妖怪在该种环境中能达到的最大攻击力和最大防御力之和。strength(a,b)=max(atk(a,b))+max(dnf(a,b))环境由a，b两个参数定义，a，b的含义见前文描述。 比如当前环境a=3，b=2，那么攻击力为6，防御力为2的妖怪，能达到的最大攻击力为9，最大防御力为6。所以该妖怪在a=3，b=2的环境下战斗力为15。因此，在不同的环境，战斗力最强的妖怪可能发生变化。作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在最为不利的情况下，他的n只妖怪能够达到的最强战斗力值，即存在一组正实数(a,b)使得n只妖怪在该环境下最强战斗力最低。 输入格式 第一行一个n，表示有n只妖怪。接下来n行，每行两个整数atk和dnf，表示妖怪的攻击力和防御力。 $1≤n≤10^6, 0＜atk,dnf≤10^8$ 输出格式 输出在最不利情况下最强妖怪的战斗力值，保留4位小数。 样例输入 3 1 1 1 2 2 2 样例输出 8.0000 推导一下容易发现题目要求的就是$\frac{b}{a}x+y+\frac{a}{b}y+x$的最值。注意到$a,b$为正实数，不妨令$k=\frac{b}{a}$，那么所求即$f(k)=x+y+kx+\frac{1}{k}y$的最值，不难发现这是个下凸函数，那么直接三分$k$的值。这个方法需要反复实验才能通过。 再观察一下发现，当$k$为定值的时候，假设$x&gt;x’$可以发现类似斜率优化的式子，得到有用的点一定是在上凸包上，因此可以先预处理凸包再三分。 代码（裸三分）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;const double eps=1e-12;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,A[N],B[N];inline double f(double x)&#123; double Max=-9e18,y=1/x; for(register int i=1;i&lt;=n;i++) &#123; double t=x*A[i]+y*B[i]+A[i]+B[i]; Max=Max&lt;t?t:Max; &#125; return Max;&#125;double DC(double l,double r)&#123; double res; while(r-l&gt;=eps) &#123; double lmid=l+(r-l)/3,lans=f(lmid); double rmid=r-(r-l)/3,rans=f(rmid); if(lans&gt;rans)l=lmid,res=rans; else r=rmid,res=lans; &#125; return res;&#125;int main()&#123; _R(n); for(register int i=1;i&lt;=n;i++)_R(A[i]),_R(B[i]); printf("%.4lf",DC(eps,10));&#125; 代码（凸包+三分）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define ll long longusing namespace std;const double eps=1e-12;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;struct node&#123;int x,y;&#125;P[N],S[N];node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;ll operator*(node a,node b)&#123;return 1ll*a.x*b.y-1ll*a.y*b.x;&#125;bool operator&lt;(node a,node b)&#123; if(a.x!=b.x)return a.x&gt;b.x; return a.y&lt;b.y;&#125;int n,top;inline double f(double x)&#123; double Max=-9e18,y=1/x; for(register int i=1;i&lt;=top;i++) &#123; double t=x*S[i].x+y*S[i].y+S[i].x+S[i].y; Max=Max&lt;t?t:Max; &#125; return Max;&#125;double DC(double l,double r)&#123; double res; while(r-l&gt;=eps) &#123; double lmid=l+(r-l)/3,lans=f(lmid); double rmid=r-(r-l)/3,rans=f(rmid); if(lans&gt;rans)l=lmid,res=rans; else r=rmid,res=lans; &#125; return res;&#125;int main()&#123; _R(n); for(register int i=1;i&lt;=n;i++)_R(P[i].x),_R(P[i].y); sort(P+1,P+n+1); for(register int i=1;i&lt;=n;i++) &#123; while(top&gt;1&amp;&amp;(P[i]-S[top-1])*(S[top]-S[top-1])&gt;=0)top--; S[++top]=P[i]; &#125; printf("%.4lf",DC(eps,10));&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>计算几何</category>
        <category>三分</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JLOI2014 镜面通道（计算几何+网络流）]]></title>
    <url>%2F2018%2F04%2F15%2FJLOI2014-%E9%95%9C%E9%9D%A2%E9%80%9A%E9%81%93%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【JLOI2014】镜面通道问题描述 在一个二维平面上，有一个镜面通道，由镜面AC，BD组成，AC，BD长度相等，且都平行于x轴，B位于（0，0）。通道中有n个外表面为镜面的光学元件，光学元件α为圆形，光学元件β为矩形（这些元件可以与其他元件和通道有交集，具体看下图）。光线可以在AB上任一点以任意角度射入通道，光线不会发生削弱。当出现元件与元件，元件和通道刚好接触的情况视为光线无法透过（比如两圆相切）。现在给出通道中所有元件的信息（α元件包括圆心坐标和半径xi，yi，ri，β元件包括左下角和右上角坐标x1，y1，x2，y2） .jpg.gif) 如上图，S到T便是一条合法线路。 .jpg.gif) 当然，显然存在光线无法透过的情况，现在交给你一个艰巨的任务，请求出至少拿走多少个光学元件后，存在一条光线线路可以从CD射出。 下面举例说明： 现在假设，取走中间那个矩形，那么就可以构造出一条穿过通道的光路，如图中的S到T。 输入格式 第一行包含两个整数，x，y，表示C点坐标 第二行包含一个数字，n，表示有n个光学元件 接下来n行 第一个数字如果是1，表示元件α，后面会有三个整数xi，yi，ri分别表示圆心坐标和半径 第一个数字如果是2，表示元件β，后面会有四个整数x1，y1，x2，y2分别表示左下角和右上角坐标（矩形都平行，垂直于坐标轴） 输出格式 输出包含一行，至少需要拿走的光学元件个数m 样例输入 1000 100 6 1 500 0 50 2 10 10 20 100 2 100 10 200 100 2 300 10 400 100 2 500 10 600 100 2 700 0 800 100 样例输出 2 提示 x&lt;=100000，y&lt;=1000，n&lt;=300 首先，你需要知道一些物理知识。根据神奇的反射定律，那么只要上下两块板之间还有空隙，那么光线一定可以穿过去。 也就是说光线无法透过当且仅当由圆和矩形构成了一条连接上下两板的通路。 那么这题就比较显然了，相交的元件连边，每个元件拆点限制用的次数，然后跑一个最小割就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define ll long longusing namespace std;struct node&#123;int x,y,r,id;&#125;C[N];struct nodd&#123;int x1,y1,x2,y2,id;&#125;D[N];int X,Y,n,tot1,tot2,S,T;int TOT=1,LA[N],NE[N],EN[N],G[N],La[N];int Dis[N],cnt[N],ans;void ADD(int x,int y,int z)&#123; TOT++; G[TOT]=z; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=La[x]=TOT;&#125;void Link(int x,int y,int z)&#123; ADD(x,y,z); ADD(y,x,0);&#125;ll dis(int x1,int y1,int x2,int y2)&#123; ll x=x1-x2,y=y1-y2; return x*x+y*y;&#125;bool Cross1(int i,int j)&#123; ll d=C[i].r+C[j].r; return d*d&gt;=dis(C[i].x,C[i].y,C[j].x,C[j].y);&#125;bool Cross2(int i,int j)&#123; ll d=1ll*C[i].r*C[i].r; if(dis(D[j].x1,D[j].y1,C[i].x,C[i].y)&lt;=d)return 1; if(dis(D[j].x1,D[j].y2,C[i].x,C[i].y)&lt;=d)return 1; if(dis(D[j].x2,D[j].y1,C[i].x,C[i].y)&lt;=d)return 1; if(dis(D[j].x2,D[j].y2,C[i].x,C[i].y)&lt;=d)return 1; if(C[i].y&lt;=D[j].y2&amp;&amp;C[i].y&gt;=D[j].y1) &#123; if(C[i].x&gt;=D[j].x1&amp;&amp;C[i].x&lt;=D[j].x2)return 1; if(max(C[i].x-D[j].x2,D[j].x1-C[i].x)&lt;=C[i].r)return 1; &#125; if(C[i].x&gt;=D[j].x1&amp;&amp;C[i].x&lt;=D[j].x2) &#123; if(C[i].y&gt;=D[j].y1&amp;&amp;C[i].y&lt;=D[j].y2)return 1; if(max(C[i].y-D[j].y2,D[j].y1-C[i].y)&lt;=C[i].r)return 1; &#125; return 0;&#125;bool Cross3(int i,int j)&#123; if(D[i].x2&lt;D[j].x1)return 0; if(D[i].x1&gt;D[j].x2)return 0; if(D[i].y1&gt;D[j].y2)return 0; if(D[i].y2&lt;D[j].y1)return 0; return 1;&#125;int SAP(int x,int f)&#123; if(x==T)return f; int i,y,tmp,d=0; for(i=LA[x];i;i=LA[x]=NE[i]) &#123; y=EN[i]; if(!G[i]||Dis[x]!=Dis[y]+1)continue; tmp=SAP(y,min(f-d,G[i])); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(d==f||Dis[S]&gt;T)return LA[x]=La[x],d; &#125; if(!--cnt[Dis[x]])Dis[S]=T+1; cnt[++Dis[x]]++; return LA[x]=La[x],d;&#125;int main()&#123; int i,j,k,x,y,z,p,q; scanf("%d%d%d",&amp;X,&amp;Y,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;k); if(k==1) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); C[++tot1]=(node)&#123;x,y,z,i&#125;; &#125; else &#123; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;p,&amp;q); D[++tot2]=(nodd)&#123;x,y,p,q,i&#125;; &#125; &#125; S=n+n+1;T=S+1; for(i=1;i&lt;=tot1;i++) &#123; if(C[i].y&lt;=C[i].r)Link(S,C[i].id,1); if(C[i].y+C[i].r&gt;=Y)Link(C[i].id+n,T,1); &#125; for(i=1;i&lt;=tot2;i++) &#123; if(D[i].y1&lt;=0)Link(S,D[i].id,1); if(D[i].y2&gt;=Y)Link(D[i].id+n,T,1); &#125; for(i=1;i&lt;=tot1;i++) &#123; for(j=1;j&lt;=tot1;j++)if(i!=j&amp;&amp;Cross1(i,j))Link(C[i].id+n,C[j].id,1); for(j=1;j&lt;=tot2;j++)if(Cross2(i,j))Link(C[i].id+n,D[j].id,1); &#125; for(i=1;i&lt;=tot2;i++) &#123; for(j=1;j&lt;=tot2;j++)if(i!=j&amp;&amp;Cross3(i,j))Link(D[i].id+n,D[j].id,1); for(j=1;j&lt;=tot1;j++)if(Cross2(j,i))Link(D[i].id+n,C[j].id,1); &#125; for(i=1;i&lt;=n;i++)Link(i,i+n,1); while(Dis[S]&lt;=T)ans+=SAP(S,1e9); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
        <category>计算几何</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2011 防线修建（动态凸包）]]></title>
    <url>%2F2018%2F04%2F15%2FHAOI2011-%E9%98%B2%E7%BA%BF%E4%BF%AE%E5%BB%BA%EF%BC%88%E5%8A%A8%E6%80%81%E5%87%B8%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HAOI2011 Day1】防线修建问题描述 近来A国和B国的矛盾激化，为了预防不测，A国准备修建一条长长的防线，当然修建防线的话，肯定要把需要保护的城市修在防线内部了。可是A国上层现在还犹豫不决，到底该把哪些城市作为保护对象呢？又由于A国的经费有限，所以希望你能帮忙完成如下的一个任务： 1.给出你所有的A国城市坐标 2.A国上层经过讨论，考虑到经济问题，决定取消对i城市的保护，也就是说i城市不需要在防线内了 3.A国上层询问对于剩下要保护的城市，修建防线的总经费最少是多少 你需要对每次询问作出回答。注意单位1长度的防线花费为1。 A国的地形是这样的，形如下图，x轴是一条河流，相当于一条天然防线，不需要你再修建 A国总是有两个城市在河边，一个点是(0,0)，一个点是(n,0)，其余所有点的横坐标均大于0小于n，纵坐标均大于0。A国有一个不在(0,0)和(n,0)的首都。(0,0),(n,0)和首都这三个城市是一定需要保护的。 上图中，A,B,C,D,E点为A国城市，且目前都要保护，那么修建的防线就会是A-B-C-D，花费也就是线段AB的长度+线段BC的长度+线段CD的长度 如果，这个时候撤销B点的保护，那么防线变成下图 输入格式 第一行，三个整数n,x,y分别表示河边城市和首都是(0,0)，(n,0)，(x,y)。 第二行，一个整数m。 接下来m行，每行两个整数a,b表示A国的一个非首都非河边城市的坐标为(a,b)。 再接下来一个整数q，表示修改和询问总数。 接下来q行每行要么形如1 i，要么形如2，分别表示撤销第i个城市的保护和询问。 输出格式 对于每个询问输出1行，一个实数v，表示修建防线的花费，保留两位小数 样例输入 4 2 1 2 1 2 3 2 5 2 1 1 2 1 2 2 样例输出 6.47 5.84 4.47 数据范围： 30%的数据m&lt;=1000,q&lt;=1000 100%的数据m&lt;=100000,q&lt;=200000,n&gt;1 所有点的坐标范围均在10000以内, 数据保证没有重点 动态凸包裸题，用set维护一下就好了，每次就查找前后的点判断一下凸性质，不满足就弹掉。 代码 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;cmath&gt;#define N 100005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;struct node&#123;int x,y;&#125;P[N],Q[N];int n,X,Y,m,q;bool use[N];set&lt;node&gt;S;double ans,Ans[N];bool operator&lt;(node a,node b)&#123; if(a.x!=b.x)return a.x&lt;b.x; return a.y&lt;b.y;&#125;node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;int operator*(node a,node b)&#123;return a.x*b.y-a.y*b.x;&#125;double dis(node a,node b)&#123; double x=a.x-b.x; double y=a.y-b.y; return sqrt(x*x+y*y);&#125;bool judge(node a,node b,node c)&#123; return (c-b)*(a-b)&gt;=0;&#125;set&lt;node&gt;::iterator Gpre(node p)&#123; set&lt;node&gt;::iterator it=S.lower_bound(p); if(it!=S.begin())return --it; return it;&#125;set&lt;node&gt;::iterator Gsuc(node p)&#123; set&lt;node&gt;::iterator it=S.upper_bound(p); if(it!=S.end())return it; return --it;&#125;bool PopF(node p)&#123; set&lt;node&gt;::iterator p1=Gpre(p); set&lt;node&gt;::iterator p2=Gpre(*p1); if(p1==p2)return 0; if(judge(*p2,*p1,p)) &#123; ans-=dis(*p2,*p1); ans-=dis(*p1,p); ans+=dis(*p2,p); S.erase(p1);return 1; &#125; return 0;&#125;bool PopB(node p)&#123; set&lt;node&gt;::iterator p1=Gsuc(p); set&lt;node&gt;::iterator p2=Gsuc(*p1); if(p1==p2)return 0; if(judge(p,*p1,*p2)) &#123; ans-=dis(*p1,*p2); ans-=dis(p,*p1); ans+=dis(p,*p2); S.erase(p1);return 1; &#125; return 0;&#125;void Ins(node p)&#123; set&lt;node&gt;::iterator suc=Gsuc(p); set&lt;node&gt;::iterator pre=Gpre(p); if(judge(*pre,p,*suc))return; S.insert(p);ans-=dis(*pre,*suc); ans+=dis(*pre,p)+dis(p,*suc); while(PopF(p));while(PopB(p));&#125;int main()&#123; int i,j,k,x,y; _R(n);_R(X);_R(Y);_R(m); for(i=1;i&lt;=m;i++)_R(P[i].x),_R(P[i].y); _R(q); for(i=1;i&lt;=q;i++) &#123; _R(k); if(k==2)Q[i]=(node)&#123;2,0&#125;; else &#123; _R(x);use[x]=1; Q[i]=(node)&#123;1,x&#125;; &#125; &#125; S.insert((node)&#123;0,0&#125;); S.insert((node)&#123;n,0&#125;); S.insert((node)&#123;X,Y&#125;); ans=dis((node)&#123;0,0&#125;,(node)&#123;X,Y&#125;)+dis((node)&#123;X,Y&#125;,(node)&#123;n,0&#125;); for(i=1;i&lt;=m;i++)if(!use[i])Ins(P[i]); for(i=q;i&gt;=1;i--) &#123; if(Q[i].x==2)Ans[i]=ans; else Ins(P[Q[i].y]); &#125; for(i=1;i&lt;=q;i++)if(Q[i].x==2)printf("%.2lf\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2011 数矩形（计算几何）]]></title>
    <url>%2F2018%2F04%2F15%2FHNOI2011-%E6%95%B0%E7%9F%A9%E5%BD%A2%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HNOI2011】数矩形问题描述 最近某歌手在研究自己的全国巡回演出，他将所有心仪的城市都用平面上一个点来表示，并打算从中挑选出4个城市作为这次巡回演出的地点。 为了显示自己与众不同，他要求存在一个矩形使得挑选出的4个点恰好是这个矩形的4个顶点，并且希望这个矩形的面积最大。 这可急坏了经纪人，于是他向全球歌迷征集方案，当然你这位歌迷一定不会错过这个机会。 输入格式 第一行是一个正整数N，表示平面上点的个数（即某歌手心仪的城市数）。 接下来N行，每行是两个整数Xi,Yi，表示对应点的坐标。 输出格式 输出一个数，表示最大矩形面积。 样例输入 8 -2 3 -2 -1 0 3 0 -1 1 -1 2 1 -3 1 -2 1 样例输出 10 提示 $1&lt;=N&lt;=1500 , -10^8&lt;=Xi,Yi&lt;=10^8$ 求矩形数量，枚举对角线，先暴力计算两点连线长度和中点，然后将这些存到结构体里面按中点坐标和长度排序。 两条对角线要构成矩形必须满足中点重合且长度相等，排完序后暴力往前找符合条件的边就行了。想一想就能发现暴力找并不会被卡，因此复杂度就是$O(n^2\log n)$的。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 10000000#define ll long longusing namespace std;struct node&#123;ll x1,y1,x2,y2,xmid,ymid,len;&#125;L[N];bool operator&lt;(node a,node b)&#123; if(a.len!=b.len)return a.len&lt;b.len; if(a.xmid!=b.xmid)return a.xmid&lt;b.xmid; return a.ymid&lt;b.ymid;&#125;bool operator==(node a,node b)&#123; if(a.len!=b.len)return 0; if(a.xmid!=b.xmid)return 0; if(a.ymid!=b.ymid)return 0; return 1;&#125;ll n,X[N],Y[N],tot,ans;ll Gdis(ll a,ll b)&#123; ll x=X[a]-X[b]; ll y=Y[a]-Y[b]; return x*x+y*y;&#125;ll Garea(ll a,ll b)&#123; ll x1=L[a].x1-L[b].x1; ll x2=L[a].x2-L[b].x1; ll y1=L[a].y1-L[b].y1; ll y2=L[a].y2-L[b].y1; return abs(x1*y2-x2*y1);&#125;int main()&#123; ll i,j,k,x,y; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld%lld",&amp;X[i],&amp;Y[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;i;j++)L[++tot]=(node)&#123;X[i],Y[i],X[j],Y[j],X[i]+X[j],Y[i]+Y[j],Gdis(i,j)&#125;; sort(L+1,L+tot+1); for(i=2;i&lt;=tot;i++) for(j=i-1;j&gt;=1&amp;&amp;L[i]==L[j];j--) ans=max(ans,Garea(i,j)); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI2014 信号增幅仪（最小圆覆盖）]]></title>
    <url>%2F2018%2F04%2F15%2FSHOI2014-%E4%BF%A1%E5%8F%B7%E5%A2%9E%E5%B9%85%E4%BB%AA%EF%BC%88%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【SHOI2014】信号增幅仪问题描述 无线网络基站在理想状况下有效信号覆盖范围是个圆形。而无线基站的功耗与圆的半径的平方成正比。 现给出平面上若干网络用户的位置,请你选择一个合适的位置建设无线基站…. 就在你拿起键盘准备开始敲代码的时候,你的好朋友发明家 SHTSC 突然出现了。SHTSC 刚刚完成了他的新发明——无线信号增幅仪。增幅仪能够在不增加无线基站功耗的前提下,使得有效信号的覆盖范围在某一特定方向上伸长若干倍。即:使用了增幅仪的无线基站覆盖范围是个椭圆,其功耗正比于半短轴长的平方。现给出平面上若干网络用户的位置,请你选择一个合适的位置建设无线基站,并在增幅仪的帮助下使所有的用户都能接收到信号,且无线基站的功耗最小。 注意:由于SHTSC 增幅仪的工作原理依赖地磁场,增幅的方向是恒定的。 输入格式 第一行一个整数:n。平面内的用户个数。 之后的 n 行每行两个整数 x, y,表示一个用户的位置。 第 n+2 行一个整数:a。表示增幅仪的增幅方向,单位是度。表示增幅仪的方向是从 x 正方向逆时针转 a 度。 第 n+3 行一个整数:p。表示增幅仪的放大倍数。 输出格式 输出一行一个实数,为能够覆盖所有用户的最小椭圆的半短轴长,四舍五入到三位小数。 样例输入 2 1 0 -1 0 0 2 样例输出 0.500 提示 对于 100%的数据,$n≤50000,0≤a&lt;180,1≤p≤100,|x|,|y|≤2×10^8$。 一道高中数学题，先旋转一下坐标系，再做一下伸缩变换，于是就变成了一个标准的圆。 于是只要打一个最小圆覆盖的板就行了。 关于最小圆覆盖，就是做三重增量法，详见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#define N 55555using namespace std;const double eps=1e-10;const double pi=4.0*atan(1.0);struct node&#123;double x,y;&#125;P[N],O;double Sin,Cos,r;double dis(node a,node b)&#123; double x=a.x-b.x; double y=a.y-b.y; return sqrt(x*x+y*y);&#125;bool Incircle(node p)&#123;return r&gt;=dis(O,p);&#125;void Getcir(node a,node b,node c)&#123; O.y=((b.x-c.x)*(a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y)-(a.x-b.x)*(b.x*b.x-c.x*c.x+b.y*b.y-c.y*c.y))/((a.y-b.y)*(b.x-c.x)-(b.y-c.y)*(a.x-b.x))/2.0; O.x=(a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y)/(a.x-b.x)/2.0-(a.y-b.y)/(a.x-b.x)*O.y; r=dis(O,a);&#125;int main()&#123; int i,j,k,n;double x,y,a,p; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;P[i].x,&amp;P[i].y); scanf("%lf%lf",&amp;a,&amp;p);a=-a; Sin=sin(pi*a/180.0); Cos=cos(pi*a/180.0); for(i=1;i&lt;=n;i++) &#123; x=P[i].x;y=P[i].y; P[i].x=Cos*x-Sin*y; P[i].y=Sin*x+Cos*y; P[i].x/=1.0*p; &#125; random_shuffle(P+1,P+n+1); for(i=1;i&lt;=n;i++) &#123; if(Incircle(P[i]))continue; O.x=P[i].x;O.y=P[i].y;r=0; for(j=1;j&lt;i;j++) &#123; if(Incircle(P[j]))continue; O.x=(P[i].x+P[j].x)/2.0; O.y=(P[i].y+P[j].y)/2.0; r=dis(P[i],P[j])/2.0; for(k=1;k&lt;j;k++) &#123; if(Incircle(P[k]))continue; Getcir(P[i],P[j],P[k]); &#125; &#125; &#125; printf("%.3lf",r);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>最小圆覆盖</category>
      </categories>
      <tags>
        <tag>最小圆覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2008 下落的圆盘（计算几何）]]></title>
    <url>%2F2018%2F04%2F15%2FHAOI2008-%E4%B8%8B%E8%90%BD%E7%9A%84%E5%9C%86%E7%9B%98%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HAOI2008】下落的圆盘问题描述 有n个圆盘从天而降，后面落下的可以盖住前面的。求最后形成的封闭区域的周长。看下面这副图, 所有的红色线条的总长度即为所求. 输入格式 第一行为1个整数n,N&lt;=1000 接下来n行每行3个实数,ri,xi,yi,表示下落时第i个圆盘的半径和圆心坐标. 输出格式 最后的周长，保留三位小数 样例输入 1 2 1 0 0 1 1 0 样例输出 1 10.472 样例输入 2 6 9.960 -10.180 19.140 4.370 -3.500 18.740 9.030 -8.060 -12.500 3.830 -14.160 -16.940 7.190 -5.860 8.260 7.270 8.900 17.720 样例输出 2 229.401 这道题比较好像，直接从前往后依次讨论每个圆对答案的贡献，就枚举一下在他后面的圆，然后算一下圆交，得到两个交点之间的弧度，然后把所有的这些弧度区间拿来做线段覆盖就好了，注意处理相离和内含。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#define N 2005using namespace std;const double pi=4.0*atan(1.0);struct node&#123;double x,y;&#125;;struct circle&#123;node o;double r;&#125;C[N];node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;node operator*(node a,double k)&#123;return (node)&#123;a.x*k,a.y*k&#125;;&#125;node operator/(node a,double k)&#123;return (node)&#123;a.x/k,a.y/k&#125;;&#125;bool operator&lt;(node a,node b)&#123; if(a.x==b.x)return a.y&gt;b.y; return a.x&lt;b.x;&#125;int n;double dis(node a,node b)&#123; double x=a.x-b.x; double y=a.y-b.y; return sqrt(x*x+y*y);&#125;bool Cover(circle a,circle b)&#123; if(a.r&gt;b.r)return 0; return dis(a.o,b.o)&lt;=b.r-a.r;&#125;bool Apart(circle a,circle b)&#123; return dis(a.o,b.o)&gt;=a.r+b.r;&#125;node Get(circle a,circle b)&#123; double d=dis(a.o,b.o); double Cos=(a.r*a.r+d*d-b.r*b.r)/(2.0*a.r*d); double Sin=sqrt(1.0-Cos*Cos); node v=b.o-a.o,w=(node)&#123;-v.y,v.x&#125;; v=v/d;w=w/d;v=v*(a.r*Cos);w=w*(a.r*Sin); node p1=a.o+v+w,p2=a.o+v-w; node v1=p1-a.o,v2=p2-a.o; return (node)&#123;atan2(v2.y,v2.x),atan2(v1.y,v1.x)&#125;;&#125;double Cal(int t)&#123; int i,j,k;vector&lt;node&gt;S; for(i=t+1;i&lt;=n;i++) &#123; if(Cover(C[t],C[i]))return 0; if(Cover(C[i],C[t]))continue; if(Apart(C[i],C[t]))continue; node tmp=Get(C[t],C[i]); if(tmp.x&lt;tmp.y)S.push_back(tmp); else S.push_back((node)&#123;tmp.x,pi&#125;),S.push_back((node)&#123;-pi,tmp.y&#125;); &#125; sort(S.begin(),S.end()); double l=-pi,r=-pi,ans=0; for(i=0;i&lt;S.size();i++) &#123; if(S[i].x&gt;r)ans+=r-l,l=S[i].x,r=S[i].y; else if(S[i].y&gt;r)r=S[i].y; &#125; return (2*pi-ans-r+l)*C[t].r;&#125;int main()&#123; int i,j,k;double r,x,y,Ans=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%lf%lf%lf",&amp;r,&amp;x,&amp;y); C[i]=(circle)&#123;(node)&#123;x,y&#125;,r&#125;; &#125; for(i=1;i&lt;=n;i++)Ans+=Cal(i); printf("%.3lf",Ans);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI2018 游记]]></title>
    <url>%2F2018%2F04%2F15%2FCQOI2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这两天有幸参加了CQOI 2018，觉得非常的——，就来更一发博客。 今年的CQOI怕不是历年最惨的一次，题目全是一眼题以至于进队全靠NOIP？ Day1T1一眼BSGS，模板题，没有任何意思。 T2一眼矩阵树，模板题，没有任何意思。 T3一眼数学题，推一推发现了一个$O(n)$的算法，然后发现模数小没有逆元，就把质因子提出来预处理了一发。感觉$n=10^7$卡着$1s$非常的抖，觉得卡卡常应该能卡过，于是一直在卡常，然后就真被卡常了。果然开$10^7$就是坑啊，毕竟还是$naive$了，没有去考虑更优的方法。 Day2T1一眼状压dp，水过。 T2一眼高精度，水过。 T3一眼莫队，水过。 本来以为今天还能翻盘，结果白送300也是。 所以今年的锅谁来背呢，题目质量感觉很低啊，毫无游戏体验。 所以这场CQOI我还是天真了，以为$O(n)$能卡过结果就只能$565$，$Rank3$跑路了。 所以还是要说今年的题质量大不如往年啊。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI 2014 通配符匹配（动态规划+哈希）]]></title>
    <url>%2F2018%2F04%2F01%2FCQOI-2014-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【CQOI2014】通配符匹配问题描述 几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号“*”，可以匹配0个即以上任意的字符；另一个是问号“?”，可以匹配恰好一个任意字符。 现在需要你编写一个程序，对于给定文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。 输入格式 第一行是一个由小写字母和上述通配符组成的字符串。 第二行包含一个整数n，表示文件的个数。 接下来n行，每行为一个仅含小写字母的字符串，表示文件名列表。 输出格式 输出n行，每行为“YES”或“NO”，表示对应文件能否被通配符匹配。 样例输入 *abc?e**e 3 abcee ppabcqexe abcdefgee 样例输出 NO YES YES 提示 对于30%的数据，字符串长度不超过100 对于100%的数据，字符串长度不超过100000，1&lt;=n&lt;=100，通配符个数不超过10个。 通配符的个数比较少，考虑按照通配符来dp 令$F[i][j]$表示用完前$i$个通配符，能否匹配前$j$个字符。令$s$为含通配符串，$t$为文件串，$pos[i]$表示第$i$个通配符的位置。 那么根据通配符的类型来考虑$F[i][j]$的转移 如果第$i+1$个通配符是$”?”$ 那么需要判断$s[pos[i]+1],pos[i+1]-1]$和$t[j+1,j+pos[i+1]-pos[i]-1]$是否相同，如果相同，并且$F[i][j]$为真，那么$F[i+1][j+pos[i+1]-pos[i]]$为真。注意$”?”$必须匹配。 如果第$i+1$个通配符是$”*”$ 那么同样需要判断$s[pos[i]+1],pos[i+1]-1]$和$t[j+1,j+pos[i+1]-pos[i]-1]$是否相同，如果相同，且$F[i][j]$为真，那么$j+pos[i+1]-pos[i]-1$及之后的位置都为真了。此时只需要先将$F[i+1][j+pos[i+1]-pos[i]-1$置为真，然后最后跑一个$F[i+1][j]|=F[i+1][j-1]$即可。 注意到为了不讨论最后一个通配符后面的部分，可以在$s$后面加一个$”?”$，在$t$后面随便加一个字符即可。 复杂度$O(nklen)，k为通配符个数$ 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll unsigned long long#define N 200005using namespace std;const ll p=131;char A[N],B[N];bool F[12][N];int n,pos[12],L1,L2,cnt;ll Aash[N],Bash[N],Pow[N];ll Get(ll Hash[],int l,int r)&#123;return l&gt;r?0:Hash[r]-Hash[l-1]*Pow[r-l+1];&#125;int main()&#123; int k,x,y;ll t1,t2; scanf("%s%d",A+1,&amp;n); L1=strlen(A+1);A[++L1]='?';Pow[0]=1; for(register int i=1;i&lt;N;i++)Pow[i]=Pow[i-1]*p; for(register int i=1;i&lt;=L1;i++)Aash[i]=Aash[i-1]*p+A[i]; for(register int i=1;i&lt;=L1;i++)if(A[i]=='*'||A[i]=='?')pos[++cnt]=i; while(n--) &#123; scanf("%s",B+1);L2=strlen(B+1);B[++L2]='?'; for(register int i=1;i&lt;=L2;i++)Bash[i]=Bash[i-1]*p+B[i]; for(register int i=0;i&lt;=cnt;i++) for(register int j=0;j&lt;=L2;j++)F[i][j]=0; F[0][0]=1; for(register int i=0;i&lt;cnt;i++) &#123; for(register int j=0;j&lt;L2;j++)if(F[i][j])F[i+1][j+pos[i+1]-pos[i]-(A[pos[i+1]]!='?')]=Get(Aash,pos[i]+1,pos[i+1]-1)==Get(Bash,j+1,j+pos[i+1]-pos[i]-1); if(A[pos[i+1]]=='*')for(register int j=1;j&lt;=L2;j++)F[i+1][j]|=F[i+1][j-1]; &#125; F[cnt][L2]?puts("YES"):puts("NO"); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI 2014 数三角形（乱搞）]]></title>
    <url>%2F2018%2F04%2F01%2FCQOI-2014-%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【CQOI2014】数三角形问题描述 给定一个$n\times m$的网格，请计算三个点都在格点上的三角形共有多少个。下图为$4\times 4$的网格上的一个三角形。 注意三角形的三点不能共线。 输入格式 输入一行，包含两个空格分隔的正整数m和n。 输出格式 输出一个正整数，为所求三角形的数量。 样例输入： 1 1 样例输出： 4 提示 对于30%的数据，1&lt;=m,n&lt;=10 对于100%的数据，1&lt;=m,n&lt;=1000 这题直接考虑用$C_{(n+1)(m+1)}^{3}$减去三点共线的方案数。 考虑统计三点共线的方案数，我们考虑枚举两个点位置关系，然后算出两点间的整点数。然后乘上这样的两个点的数目就行了。两点间整点数就是$gcd(x_2-x_1,y_2-y_1)-1$ 代码： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll unsigned long longusing namespace std;ll n,m,ans;ll C(ll n,ll m)&#123; if(n&lt;m)return 0; if(m==2)return n*(n-1)/2; if(m==3)return n*(n-1)/2*(n-2)/3;&#125;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;int main()&#123; ll i,j,k,x,y; scanf("%lld%lld",&amp;n,&amp;m); ans=C((n+1)*(m+1),3); ans-=(n+1)*C(m+1,3)+(m+1)*C(n+1,3); for(i=1;i&lt;=n+1;i++) for(j=1;j&lt;=m+1;j++) &#123; k=gcd(i,j);if(k==1)continue; ans-=(n+1-i)*(m+1-j)*(k-1)*2; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI 2014 危桥（网络流）]]></title>
    <url>%2F2018%2F04%2F01%2FCQOI-2014-%E5%8D%B1%E6%A1%A5%EF%BC%88%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【CQOI2014】危桥问题描述 Alice和Bob居住在一个由N个岛屿组成的国家，岛屿被编号为0到N-1。某些岛屿之间有桥相连，桥上的道路都是双向的，但是一次只能供一人通行。其中一些桥由于年久失修成为危桥，最多只能通行两次。 Alice希望在岛屿a1和a2之间往返an次(从a1到a2再从a2到a1算一次往返)。同时，Bob希望在岛屿b1和b2之间往返bn次。这个过程中，所有危桥最多通行两次，其余桥可以无限次通行。请问Alice和Bob能完成他们的愿望吗？ 输入格式 本题有多组测试数据。 每组数据第一行包含7个空格隔开的整数，分别是N,a1,a2,an,b1,b2,bn。 接下来是一个N行N列的对称矩阵，由大写字母组成。矩阵的第i行第j列描述编号i-1和j-1的岛屿间连接情况，若为“O”则表示有危桥相连；为“N”表示有普通桥相连；为“X”表示没有桥相连。 输出格式 对每组测试数据输出一行，如果他们都能完成愿望输出“Yes”，否则输出“No”。 样例输入 4 0 1 1 2 3 1 XOXX OXOX XOXO XXOX 4 0 2 1 1 3 2 XNXO NXOX XOXO OXOX 样例输出 Yes No 提示 4&lt;=N&lt;=50 0&lt;=a1,a2,b1,b2&lt;=N-1 1&lt;=an,bn&lt;=50 考虑直接将源点连到a1,b1，将a2,b2连到汇点，然后按题意连边之后直接跑最大流，如果最大流是$an+bn$那么可行。 但是这样做的问题在于可能存在$a1\rightarrow b2$，$b1\rightarrow a2$的流。 处理方法是再跑一次，将a1,a2交换后再做一次最大流，如果最大流也是$an+bn$那么就可行。 证明的话，考虑第二次跑的时候是不存在$a1\rightarrow b2$，$b1\rightarrow a2$的流的，这说明不要这两种流也是可以满足条件的，结合第一次跑的结果，即可保证一定可行。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100000using namespace std;int n,a1,a2,an,b1,b2,bn,S,T,ans1,ans2,tot,id[55][55];int TOT,LA[N],NE[N],EN[N],G[N];int dis[N],cnt[N];char map[55][55];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; G[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int SAP(int x,int f)&#123; if(x==T)return f; int i,y,d=0,tmp; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(!G[i]||dis[x]!=dis[y]+1)continue; tmp=SAP(y,min(G[i],f-d)); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(d==f||dis[S]&gt;T)return d; &#125; if(!--cnt[dis[x]])dis[S]=T+1; cnt[++dis[x]]++; return d;&#125;void Build(int x1,int x2,int y1,int y2)&#123; memset(LA,0,sizeof(LA));TOT=0; int i,j; for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++) &#123; if(map[i][j]=='O') &#123; ADD(n+id[i][j],n+tot+id[i][j],2); ADD(n+tot+id[i][j],n+id[i][j],0); &#125; if(map[i][j]=='N') &#123; ADD(n+id[i][j],n+tot+id[i][j],1e9); ADD(n+tot+id[i][j],n+id[i][j],0); &#125; ADD(i,n+id[i][j],1e9);ADD(n+id[i][j],i,0); ADD(j,n+id[i][j],1e9);ADD(n+id[i][j],j,0); ADD(n+tot+id[i][j],i,1e9);ADD(i,n+tot+id[i][j],0); ADD(n+tot+id[i][j],j,1e9);ADD(j,n+tot+id[i][j],0); &#125; x1++;x2++;y1++;y2++; S=n+tot+tot+1;T=S+1; ADD(S,x1,an);ADD(x1,S,0); ADD(S,y1,bn);ADD(y1,S,0); ADD(x2,T,an);ADD(T,x2,0); ADD(y2,T,bn);ADD(T,y2,0); memset(dis,0,sizeof(dis)); memset(cnt,0,sizeof(cnt));&#125;int main()&#123; int i,j,k,x,y,z; while(scanf("%d%d%d%d%d%d%d",&amp;n,&amp;a1,&amp;a2,&amp;an,&amp;b1,&amp;b2,&amp;bn)!=EOF) &#123; ans1=ans2=tot=0; for(i=1;i&lt;=n;i++)scanf("%s",&amp;map[i][1]); for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++)id[i][j]=++tot; an&lt;&lt;=1;bn&lt;&lt;=1; Build(a1,a2,b1,b2); while(dis[S]&lt;T+1)ans1+=SAP(S,1e9); Build(a2,a1,b1,b2); while(dis[S]&lt;T+1)ans2+=SAP(S,1e9); if(ans1==an+bn&amp;&amp;ans2==an+bn)puts("Yes"); else puts("No"); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI 2017 供给侧改革（trie）]]></title>
    <url>%2F2018%2F04%2F01%2FHAOI-2017-%E4%BE%9B%E7%BB%99%E4%BE%A7%E6%94%B9%E9%9D%A9%EF%BC%88trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HAOI2017】供给侧改革问题描述 Anihc国提高社会生产力水平.落实好以人民为中心的发展思想。决定进行供给侧结构性改革。 为了提高供给品质.你调查了某个产业近来 $ n $ 个时期的供求关系平衡情况.每个时期的情况都用 $ 0 $ 或 $ 1 $ 中的一个数字来表示.于是这就是—个长度为 $ n $ 的 $ 01 $ 字符串 $S$ 。为了更好的了解这一些数据.你需要解决一些询问.我们令 $ data(l,r) $ 表示：在字符串 $S$ 中.起始位置在$ [l,r] $之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。 对于每一个询问 $ L $ , $ R $ .求 $ ans = \sum\limits_{ L \le i \lt R } data(i, R) $ 由于你其实根本没有时间调查，所以这些数据都是乱编的，即串S中的每一位都是在 $ 0 $ 和 $ 1 $ 之间随机产生的。 输入格式 第一行 $ 2 $ 个整数 $ n $ , $ Q $，表示字符串的长度，以及询问个数 接下来一行长度为 $n$ 的一个 $01$ 串 $S$ 接下来 $Q$ 行，每行 $2$ 个整数 $L,R$ .一个询问 $L.R$ 输出格式 共 $Q$ 行.每行一个整数.表示对应询问的答案。 样例输入 6 3 010110 2 5 1 6 1 2 样例输出 4 6 0 提示 对于所有的数据保证：$ n &lt;= 100000 $ , $ Q&lt;= 100000 $ , $ 1&lt;=L&lt;R&lt;=n $ , $01$ 串随机生成。 这题有一个强限制，$01$串随机生成。因此我们大胆猜测$LCP$的长度不会太大，估测个40差不多了。 那么可以怎么做的，我们考虑对询问按右端点排序，那么从左往右处理询问，每次将以当前右端点前的位置为开头的后缀加到trie里面去，只用加每个后缀的前40位，然后记录一个数组$Max[i]$表示长度为$i$的$LCP$的最后出现位置时一个长度为$i$的后缀倒数第二次出现的位置，这个可以在$trie$上记录每个串上次出现的位置，然后再访问到的时候就可以用上次的位置来更新$Max$ 然后对每个询问，枚举$Max[i]$，如果$Max[i]&gt;=l$，那么就存在长度为$i$的$LCP$在范围内。 复杂度$O(q\log q+40n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 100005#define M 4000005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;inline char _S()&#123; char t=GC; while(t!='0'&amp;&amp;t!='1')t=GC; return t;&#125;const int T=40;struct node&#123;int l,r,id;&#125;K[N];bool operator&lt;(node a,node b)&#123;return a.r&lt;b.r;&#125;int n,q,Ans[N];int rt=1,tot=1,son[M][2],las[M],Max[T+5];char s[N];void ADD(int x)&#123; int p=rt; for(register int i=1;i&lt;=T&amp;&amp;x+i-1&lt;=n;i++) &#123; int t=s[x+i-1]-48; if(!son[p][t])son[p][t]=++tot; p=son[p][t]; if(las[p])Max[i]=max(Max[i],las[p]); las[p]=x; &#125;&#125;int main()&#123; int x,y,ans; n=_R();q=_R(); for(register int i=1;i&lt;=n;i++)s[i]=_S(); for(register int i=1;i&lt;=q;i++) &#123; x=_R();y=_R(); K[i]=(node)&#123;x,y,i&#125;; &#125; sort(K+1,K+q+1); for(register int i=1,j=1;i&lt;=q;i++) &#123; while(j&lt;=K[i].r)ADD(j++); x=K[i].l;ans=0; for(register int k=T;k&gt;=1;k--) if(Max[k]&gt;=x)ans+=(Max[k]-x+1)*k,x=Max[k]+1; Ans[K[i].id]=ans; &#125; for(register int i=1;i&lt;=q;i++)printf("%d\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>trie</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI 2016 扭动的回文串（Manacher+二分答案+哈希）]]></title>
    <url>%2F2018%2F04%2F01%2FJSOI-2016-%E6%89%AD%E5%8A%A8%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88Manacher-%E4%BA%8C%E5%88%86-%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【JSOI2016】扭动的回文串问题描述 JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。 一个「扭动字符串」$S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。比如，若 $A=$’XYZ’，$B=$’UVW’，则扭动字符串 $S(1,2,3)=$’XYVW’。 JYY 定义一个「扭动的回文串」为如下情况中的一个： $A$ 中的一个回文串； $B$ 中的一个回文串； 或者某一个回文的扭动字符串$S(i,j,k)$ 现在 JYY 希望找出最长的扭动回文串。 输入格式 第一行包含一个正整数 $N$。 第二行包含一个长度为 $N$ 的由大写字母组成的字符串 $A$。 第三行包含一个长度为 $N$ 的由大写字母组成的字符串 $B$。 输出格式 输出的第一行一个整数，表示最长的扭动回文串。 样例输入 5 ABCDE BAECB 样例输出 5 提示 对于所有的数据，$1≤N≤10^5$ 情况1，2直接Manacher就完了。 考虑情况三，先考虑回文串中心在$A$串上的情况，那么画画图容易推导出扭动的位置必然是$A$串的一个极长回文子串的一端，因此可以考虑在$Manacher$过程中，每次算出以当前点为中心的左右边界后，二分枚举通过扭曲能够拓展的长度，然后可以用哈希来判断是否能构成回文串，长度为奇或偶可以通过添加特殊字符处理。 然后如果回文串中心在$B$串上，直接将A,B串交换并且$reverse$之后再跑一遍就行了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005#define ll long longusing namespace std;const ll mod=1e9+7;ll Aash[N],Bash[N],Pow[N],Inv[N];int n,Ans,rad[N];char s[N],A[N],B[N];ll QM(ll a,ll b)&#123; ll o=1; while(b) &#123; if(b&amp;1)o=o*a%mod; b&gt;&gt;=1;a=a*a%mod; &#125; return o;&#125;void Manacher(char x[],char y[])&#123; int i,j,k,Max=0,pos=0; Aash[0]=Bash[0]='$'; for(i=1;i&lt;=n+n;i++) &#123; Aash[i]=(x[i]*Pow[i]%mod+Aash[i-1])%mod; Bash[i]=(y[i]*Inv[i]%mod+Bash[i-1])%mod; &#125; for(i=1;i&lt;=n+n;i++) &#123; if(i&lt;=Max)rad[i]=min(Max-i+1,rad[2*pos-i]); else rad[i]=1; while(i-rad[i]&gt;0&amp;&amp;i+rad[i]&lt;=n+n&amp;&amp;x[i-rad[i]]==x[i+rad[i]])rad[i]++; if(Max&lt;i+rad[i]-1)Max=i+rad[i]-1,pos=i; int lp=i-rad[i],rp=i+rad[i]-2; int l=1,r=min(lp+1,n+n-rp+1); while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1; ll t1=lp-mid&gt;=0?(Aash[lp]-Aash[lp-mid])*Inv[lp-mid+1]%mod:Aash[lp]; ll t2=(Bash[rp+mid-1]-Bash[rp-1])*Pow[rp+mid-1]%mod; t1=(t1+mod)%mod;t2=(t2+mod)%mod; if(t1==t2)l=mid+1; else r=mid-1; &#125; Ans=max(Ans,rad[i]+r-1); &#125;&#125;int main()&#123; int i,j; scanf("%d",&amp;n); scanf("%s",&amp;s[1]); for(i=j=1;j&lt;=n;j++,i+=2)A[i]=s[j],A[i-1]=A[i+1]='$'; scanf("%s",&amp;s[1]); for(i=j=1;j&lt;=n;j++,i+=2)B[i]=s[j],B[i-1]=B[i+1]='$'; Pow[0]=Inv[0]=1;Inv[1]=QM(13131,mod-2); for(i=1;i&lt;=n+n;i++)Pow[i]=Pow[i-1]*13131ll%mod; for(i=2;i&lt;=n+n;i++)Inv[i]=Inv[i-1]*Inv[1]%mod; Manacher(A,B); reverse(A,A+n+n+1); reverse(B,B+n+n+1); Manacher(B,A); printf("%d",Ans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>分治法</category>
        <category>二分答案</category>
        <category>哈希</category>
        <category>Manacher</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>哈希</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI 2017 魔法咒语（AC自动机+动态规划+矩阵乘法）]]></title>
    <url>%2F2018%2F04%2F01%2FBJOI-2017-%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【BJOI2017】魔法咒语问题描述 Chandra 是一个魔法天才。 从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。 直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。 根据火之魔法规则，禁咒的构成单位是 N 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 L 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。 但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。 这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。 很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。 禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 M 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。 例如，若 ”banana” 是唯一的忌讳词语，“an”、”ban”、”analysis” 是基本词汇，禁咒长度须是 11，则“bananalysis” 是无效法术，”analysisban”、”anbanbanban”是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。 谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。 由于答案可能很大，你只需要输出答案模 1,000,000,007 的结果。 输入格式 第一行，三个正整数 N, M, L。 接下来 N 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。 接下来 M 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。 输出格式 仅一行，一个整数，表示答案（模 $10^9+7$）。 样例输入 4 2 10 boom oo ooh bang ob mo 样例输出 14 数据规模与约定 显然分数据范围考虑。 对于前$60\%$的数据，直接将禁忌串建成AC自动机，然后在自动机上用基本词汇来转移。 令$F[i][pos]$表示当前匹配长度为$i$，且在自动机上$pos$位置的方案数，那么预处理自动机上每个位置跑每个基本词汇后到的位置，那么直接转移就行了。答案就是$\sum F[L][i]$ 对于后$40\%$的数据，考虑矩阵乘法，考虑构造转移矩阵将$F[i][1]\dots F[i][tot],F[i+1][1]\dots F[i+1][tot]$转移到$F[i+1][1]\dots F[i+1][tot],F[i+2][1]\dots F[i+2][tot]$，这个跟刚才的dp是一样的，长度为1的基本词汇能从$F[i+1]\rightarrow F[i+2]$，长度为2的能从$F[i]\rightarrow F[i+2]$，左下部分直接给单位矩阵就行了。答案同样是$\sum F[L][i]$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 205using namespace std;struct ACM&#123; int tot,rt,fail[N],son[N][26],num[N]; ACM()&#123;tot=rt=1;&#125; void Ins(char *s) &#123; int i,p=rt,t,l=strlen(s); for(i=0;i&lt;l;i++) &#123; t=s[i]-'a'; if(!son[p][t])son[p][t]=++tot; p=son[p][t]; &#125; num[p]=1; &#125; void Build() &#123; int i,p=rt;queue&lt;int&gt;Q; for(i=0;i&lt;26;i++) if(son[p][i])fail[son[p][i]]=p,Q.push(son[p][i]); else son[p][i]=p; while(Q.size()) &#123; p=Q.front();Q.pop(); for(i=0;i&lt;26;i++) if(son[p][i]) &#123; fail[son[p][i]]=son[fail[p]][i],Q.push(son[p][i]); num[son[p][i]]|=num[fail[son[p][i]]]; &#125; else son[p][i]=son[fail[p]][i]; &#125; &#125;&#125;Avoid;const int mod=1e9+7;int n,m,L,to[N][N],F[N][N],Ans[N][N];char s1[N][N],s2[N][N];int l1[N],l2[N],ans;void Work1()&#123; int i,j,k,l,p; F[0][Avoid.rt]=1; for(i=0;i&lt;L;i++) for(j=1;j&lt;=Avoid.tot;j++) if(F[i][j]) &#123; for(k=1;k&lt;=n;k++) if(to[j][k]!=-1&amp;&amp;i+l1[k]&lt;=L)(F[i+l1[k]][to[j][k]]+=F[i][j])%=mod; &#125; for(i=1;i&lt;=Avoid.tot;i++)(ans+=F[L][i])%=mod; printf("%d",ans);&#125;void C(int x[N][N],int y[N][N])&#123; int i,j,k,z[N][N]; memset(z,0,sizeof(z)); for(i=1;i&lt;=Avoid.tot*2;i++) for(j=1;j&lt;=Avoid.tot*2;j++) for(k=1;k&lt;=Avoid.tot*2;k++)z[i][j]=(z[i][j]+1ll*x[i][k]*y[k][j]%mod)%mod; memcpy(x,z,sizeof(z));&#125;void QM(int b)&#123; for(int i=1;i&lt;=2*Avoid.tot;i++)Ans[i][i]=1; while(b) &#123; if(b&amp;1)C(Ans,F); b&gt;&gt;=1;C(F,F); &#125; memset(F,0,sizeof(F)); F[1][Avoid.tot+Avoid.rt]=1; C(F,Ans); for(int i=1;i&lt;=Avoid.tot;i++)(ans+=F[1][i+Avoid.tot])%=mod; printf("%d",ans);&#125;void Work2()&#123; int i,j,k; for(i=1;i&lt;=Avoid.tot;i++) for(j=1;j&lt;=n;j++) if(to[i][j]!=-1) &#123; if(l1[j]==1)F[i+Avoid.tot][Avoid.tot+to[i][j]]++; else F[i][Avoid.tot+to[i][j]]++; &#125; for(i=1;i&lt;=Avoid.tot;i++)F[i+Avoid.tot][i]=1; QM(L);&#125;main()&#123; int i,j,k,l,p; scanf("%d%d%d",&amp;n,&amp;m,&amp;L); for(i=1;i&lt;=n;i++)scanf("%s",s1[i]),l1[i]=strlen(s1[i]); for(i=1;i&lt;=m;i++)scanf("%s",s2[i]),l2[i]=strlen(s2[i]); for(i=1;i&lt;=m;i++)Avoid.Ins(s2[i]); Avoid.Build(); for(i=1;i&lt;=Avoid.tot;i++) for(j=1;j&lt;=n;j++) &#123; l=strlen(s1[j]); for(p=i,k=0;(!Avoid.num[p])&amp;&amp;k&lt;l;k++)p=Avoid.son[p][s1[j][k]-'a']; if(Avoid.num[p])to[i][j]=-1; else if(k&lt;l)to[i][j]=-1; else to[i][j]=p; &#125; if(L&lt;=100)Work1(); else Work2();&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数学</category>
        <category>AC自动机</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>动态规划</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HN Training 2015 Round9 Date（主席树+概率+组合数）]]></title>
    <url>%2F2018%2F03%2F28%2FHN-Training-2015-Round9-Date%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91-%E6%A6%82%E7%8E%87-%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先求出$[L,R]$中有多少个数比$F[i]$大，这个用主席树来处理就行。 然后问题就转化成了有$n$个数，其中有$k$个满足条件的数，然后随机取$x$个数，$x$随机产生，问选出的所有数都是满足条件的数的概率。 考虑枚举$x$，那么令$P[x]$表示选$x$个数都满足条件的概率,那么 $$Ans=\frac{1}{n}\sum_{x=1}^{k}P[x]=\frac{1}{n}\sum_{x=1}^{k}\frac{C_{k}^{x}}{C_{n}^{x}}=\frac{1}{n}\sum_{x=1}^{k}\frac{k!(n-x)!}{n!(k-x)!}=\frac{k!}{n\cdot n!}\sum_{x=1}^{k}\frac{(n-x)!}{(k-x)!}$$然后只需要计算$\sum_{x=1}^{k}\frac{(n-x)!}{(k-x)!}$即可。 $$Ans=\frac{k!}{n\cdot n!}\sum_{x=1}^{k}\frac{(n-x)!}{(k-x)!}=\frac{k!(n-k)!}{n\cdot n!}\sum_{x=1}^{k}\frac{(n-x)!}{(k-x)!(n-k)!}=\frac{\sum_{x=1}^{k}C_{n-x}^{k-x}}{n\cdot C_{n}^{k}}=\frac{\sum_{x=0}^{k}C_{n-x}^{k-x}}{n\cdot C_{n}^{k}}-\frac{1}{n}$$注意到$\sum_{x=0}^{k}C_{n-x}^{k-x}=C_{n+1}^{k}$，只需要将$C_{n-k}^{0}$换成$C_{n-k+1}^{0}$即得证。那么得到 $$Ans=\frac{C_{n+1}^{k}-C_{n}^{k}}{n\cdot C_{n}^{k}}=\frac{C_{n}^{k-1}}{n\cdot C_{n}^{k}}=\frac{k}{n\cdot(n-k+1)}$$最后乘上$10^5$就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005using namespace std;const int T=1e5;int n,m,A[N];int tot,rt[N&lt;&lt;5],ls[N&lt;&lt;5],rs[N&lt;&lt;5],v[N&lt;&lt;5];int CP(int p)&#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; v[o]=v[p]; return o;&#125;int ADD(int p,int l,int r,int k)&#123; int o=CP(p);v[o]++; if(l==r)return o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k); else rs[o]=ADD(rs[o],mid+1,r,k); return o;&#125;int Gans(int lp,int rp,int l,int r,int k)&#123; if(k&lt;=l)return v[rp]-v[lp]; int mid=l+r&gt;&gt;1,sum=0; if(k&lt;=mid)sum+=Gans(ls[lp],ls[rp],l,mid,k); sum+=Gans(rs[lp],rs[rp],mid+1,r,k); return sum;&#125;int main()&#123; int i,j,k,x,y,t; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); for(i=1;i&lt;=n;i++)rt[i]=ADD(rt[i-1],1,T,A[i]); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); t=y-x+1;k=Gans(rt[x-1],rt[y],1,T,k); double ans=1e5*k/(1.0*t)/(1.0*t+1.0-1.0*k); printf("%.3lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>数学</category>
        <category>主席树</category>
        <category>概率与期望</category>
        <category>组合数</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>概率与期望</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HN Training 2015 Round9 Homework（Gauss消元+数学期望）]]></title>
    <url>%2F2018%2F03%2F28%2FHN-Training-2015-Round9-Homework%EF%BC%88Gauss%E6%B6%88%E5%85%83-%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这题感觉比较奥妙重重，标解给了一个麻烦的状压dp，但是好像直接将每个位置的期望值代进去算行列式的值就行了。 具体原理大概是因为各个位置都是相互独立的随机变量，那么他们的期望可加也可乘，那么就可以直接将行列式求期望值的式子展开成各个位置的期望再求行列式了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 15using namespace std;const double eps=1e-9;int n,L[N][N],R[N][N];double C[N][N];double Gauss()&#123; int i,j,k,x,y,t=0,MR;double a,ans=1; for(x=1,y=1,MR=1;x&lt;=n&amp;&amp;y&lt;=n;x++,y++,MR=x) &#123; for(i=x+1;i&lt;=n;i++)if(fabs(C[i][y])&gt;fabs(C[MR][y]))MR=i; if(MR!=x)for(t++,i=1;i&lt;=n;i++)swap(C[x][i],C[MR][i]); if(fabs(C[x][y])&lt;eps)return 0; for(i=x+1;i&lt;=n;i++) &#123; if(fabs(C[i][y])&lt;eps)continue; a=C[i][y]/C[x][y]; for(j=y;j&lt;=n;j++)C[i][j]=C[i][j]-C[x][j]*a; &#125; ans*=C[x][x]; &#125; return t&amp;1?-ans:ans;&#125;int main()&#123; int i,j,k; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)scanf("%d",&amp;L[i][j]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)scanf("%d",&amp;R[i][j]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)C[i][j]=0.5*(R[i][j]+L[i][j]); printf("%.0lf",floor(Gauss()));&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
        <category>概率与期望</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HN Training 2015 Round9 Water（乱搞）]]></title>
    <url>%2F2018%2F03%2F28%2FHN-Training-2015-Round9-Water%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这个题比较简单，考虑先找到树中最高的节点$x$，那么水位有两种情况，要么各个子树的水位都不超过$H[x]$，要么大于$H[x]$就会让所有点的水位的一样，因此可以直接递归处理出子树的方案数$F[sub]$， 那么$F[x]=\prod F[sub]+m-H[x]$，直接暴力分治下去就行了。 这题可以用排序并查集或者一种快速查找区间最大值的数据结构优化成$O(n\log n)$，但是数据范围小，没有必要。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2005using namespace std;const int mod=1e9+7;void add(int &amp;x,int y)&#123;x+=y;x-=x&gt;=mod?mod:0;&#125;int mul(int x,int y)&#123;return 1ll*x*y%mod;&#125;int n,m,H[N],Max,rt;int TOT,LA[N],NE[N],EN[N];bool mark[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Grt(int x,int f)&#123; if(H[x]&gt;Max)Max=H[x],rt=x; for(int i=LA[x];i;i=NE[i]) &#123; int y=EN[i]; if(y!=f&amp;&amp;!mark[y])Grt(y,x); &#125;&#125;int Cal(int x,int y)&#123; int i,j,k,t,ans=1;mark[x]=1; for(i=LA[x];i;i=NE[i]) &#123; t=EN[i];if(mark[t])continue; Max=-1;Grt(t,x); ans=mul(ans,Cal(rt,H[x])); &#125; add(ans,y-H[x]); return ans;&#125;int main()&#123; int i,j,k,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; for(i=1;i&lt;=n;i++)scanf("%d",&amp;H[i]); Max=-1;Grt(1,0);printf("%d",Cal(rt,m));&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3681 Arietta（主席树+网络流）]]></title>
    <url>%2F2018%2F03%2F28%2FBZOJ-3681-Arietta%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91-%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Arietta问题描述 Arietta 的命运与她的妹妹不同,在她的妹妹已经走进学院的时候,她仍然留在山村中。 但是她从未停止过和恋人 Velding 的书信往来。一天,她准备去探访他。 对着窗外的阳光,临行前她再次弹起了琴。 她的琴的发声十分特殊。 让我们给一个形式化的定义吧。 所有的 $n$ 个音符形成一棵由音符 $C$ ( 1 号节点) 构成的有根树,每一个音符有一个音高$ H_i$ 。 Arietta 有 $m$ 个力度,第 $i$ 个力度能弹出 $D_i$ 节点的子树中,音高在$ [L_i,R_i]$ 中的任意一个音符。 为了乐曲的和谐,Arietta 最多会弹奏第 $i$ 个力度 $T_i$ 次。 Arietta 想知道她最多能弹出多少个音符。 输入格式 输入共 m + 3 行。 第一行两个整数 n, m ,意义如题目所述。 第二行 n - 1 个整数 $P_i$ ,表示节点$ i ( i = 2 . . . n ) $的父亲节点的编号。 第三行 n 个整数 $H_i$ 。 接下来的 m 行,每行四个整数 $L_i,R_i,D,T_i$ 输出格式 输出一个整数表示 Arietta 最多能弹奏多少音符。 样例输入 5 2 1 1 2 2 5 3 2 4 1 1 3 2 1 3 5 1 4 样例输出 4 数据范围与约定 对于 100% 的数据,$1 ≤ n, m ≤ 10000$ 。 对于所有数据$1&lt;=H_i,T_i,P_i&lt;=N,1&lt;=L_i&lt;=R_i&lt;=N$ 这个题容易发现就是一个简单的网络流，每次向子树中权值在$[L_i,R_i]$中的点连边，然后每个点只能用一次，求一个最大流。但是直接上边数的规模是$O(n^2)$级别的。肯定是不行的。 考虑优化，由于要求子树中权值在$[L_i,R_i]$中的点，启发我们想到建立线段树，然后进一步的考虑主席树。 我们在每个节点维护一颗主席树，这颗主席树的叶子节点连到该点子树中的对应权值的点，然后这样向$[L_i,R_i]$连边就只需要在主席树上向对应区间的点连边了，这样的边最多有$\log n$条。然后主席树上每个点往上一个版本对应点连边，同时向新建的儿子连边. 但是需要考虑如何得到每个点的主席树，这里考虑用轻重链剖分的思想，每个点的主席树直接继承重儿子的，然后将其他轻儿子子树中的点暴力插入进去。 考虑这样的时间复杂度，由于每个点往上最多经过$\log n$条重链，因此每个点最多被暴力添加$\log n$次。因此时空复杂度都是$O(n\log^2 n)$，容易发现边的规模也是$O(n\log^2n)$的。 但是还需要注意一个问题，就是每次构建主席树的时候，可以打一个时间标记，标记每个点是何时被新建的，如果当前在主席树中访问到的点已经是这次构建中新建的点了，就不用再新建节点了。能够少添加很多节点和边，省下时间和空间。 这样做实测空间消耗是$23M$左右，另外疑似这题基础的SAP过不了，需要bfs预处理来优化。 另外，这题也可以用线段树合并做，思路差不多，每次直接将儿子节点的线段树拿来合并得到当前节点的线段树即可。复杂度是一样的，但是需要注意细节，实现的好的话空间能到$20M$以下，时间好像差不多。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 10005#define M 400000#define K 1200000using namespace std;vector&lt;int&gt;to[N];int n,m,fa[N],H[N],S,T,ans;int son[N],si[N],dis[M],Q[M];int rt[M],tot,ls[M],rs[M],tim[M],Lim;int TOT=1,LA[M],NE[K],EN[K],G[K];void ADD(int x,int y,int z)&#123; TOT++; G[TOT]=z; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Link(int x,int y,int z)&#123; if(!x||!y)return; ADD(x,y,z); ADD(y,x,0);&#125;int CP(int p)&#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; tim[o]=Lim; return o;&#125;int Ins(int p,int l,int r,int x,int k)&#123; int o=tim[p]==Lim?p:CP(p); if(o!=p)Link(o,p,1e9); if(l==r)return Link(o,k,1e9),o; int ll,rr,mid=l+r&gt;&gt;1; if(x&lt;=mid) &#123; ll=ls[o];ls[o]=Ins(ls[o],l,mid,x,k); if(ll!=ls[o])Link(o,ls[o],1e9); &#125; else &#123; rr=rs[o];rs[o]=Ins(rs[o],mid+1,r,x,k); if(rr!=rs[o])Link(o,rs[o],1e9); &#125; return o;&#125;void Gedge(int p,int l,int r,int x,int y,int k)&#123; if(!p)return; if(x&lt;=l&amp;&amp;y&gt;=r)&#123;Link(k,p,1e9);return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)Gedge(ls[p],l,mid,x,y,k); if(x&lt;=r&amp;&amp;y&gt;mid)Gedge(rs[p],mid+1,r,x,y,k);&#125;void Merge(int x,int &amp;p)&#123; p=Ins(p,1,n,H[x],x); for(int i=0;i&lt;to[x].size();i++)Merge(to[x][i],p);&#125;void DFS(int x)&#123; int i,y;si[x]=1; for(i=0;i&lt;to[x].size();i++) &#123; y=to[x][i];DFS(y);si[x]+=si[y]; if(si[y]&gt;si[son[x]])son[x]=y; &#125; Lim=x;rt[x]=Ins(rt[son[x]],1,n,H[x],x); for(i=0;i&lt;to[x].size();i++) &#123; y=to[x][i]; if(y!=son[x])Merge(y,rt[x]); &#125;&#125;bool bfs()&#123; int i,x,y,hd,tl; for(i=1;i&lt;=T;i++)dis[i]=-1; hd=tl=1;Q[1]=S;dis[S]=0; while(hd&lt;=tl) &#123; x=Q[hd++]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(!G[i]||dis[y]!=-1)continue; dis[y]=dis[x]+1; Q[++tl]=y; if(y==T)return 1; &#125; &#125; return 0;&#125;int dfs(int x,int f)&#123; if(x==T)return f; int i,y,tmp,d=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(!G[i]||dis[y]!=dis[x]+1)continue; tmp=dfs(y,min(f-d,G[i])); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(d==f)break; &#125; if(!d)dis[x]=-1;return d;&#125;int main()&#123; int i,j,k,l,r,d,t; scanf("%d%d",&amp;n,&amp;m);tot=n+m; for(i=2;i&lt;=n;i++)scanf("%d",&amp;t),to[t].push_back(i); for(i=1;i&lt;=n;i++)scanf("%d",&amp;H[i]); DFS(1);S=tot+1;T=S+1; for(i=1;i&lt;=n;i++)Link(i,T,1); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;l,&amp;r,&amp;d,&amp;t); Link(S,n+i,t);Gedge(rt[d],1,n,l,r,n+i); &#125; while(bfs())ans+=dfs(S,1e9); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>主席树</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-865C-Gotta Go Fast（二分答案+期望dp）]]></title>
    <url>%2F2018%2F03%2F27%2FCodeforces-865C-Gotta-Go-Fast%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E6%9C%9F%E6%9C%9Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C. Gotta Go Fast You’re trying to set the record on your favorite video game. The game consists of N levels, which must be completed sequentially in order to beat the game. You usually complete each level as fast as possible, but sometimes finish a level slower. Specifically, you will complete the i-th level in either $F_i $seconds or $S_i$ seconds, where $F_i &lt; S_i$, and there’s a $P_i$ percent chance of completing it in $F_i$ seconds. After completing a level, you may decide to either continue the game and play the next level, or reset the game and start again from the first level. Both the decision and the action are instant. Your goal is to complete all the levels sequentially in at most R total seconds. You want to minimize the expected amount of time playing before achieving that goal. If you continue and reset optimally, how much total time can you expect to spend playing? Input The first line of input contains integers N and R $(1\leq N\leq50,\sum F_i\leq R\leq\sum S_i)$, the number of levels and number of seconds you want to complete the game in, respectively. N lines follow. The ith such line contains integers $F_i, S_i, P_i (1 ≤ F_i &lt; S_i ≤ 100, 80 ≤ P_i ≤ 99)$, the fast time for level i, the slow time for level i, and the probability (as a percentage) of completing level i with the fast time. Output Print the total expected time. Your answer must be correct within an absolute or relative error of $10 ^{- 9}$ Formally, let your answer be a, and the jury’s answer be b. Your answer will be considered correct, if$\frac{|a-b|}{max(1,|b|)}\leq 10^{-9}$ . input 1 8 2 8 81 output 3.14 Note In the first example, you never need to reset. There’s an 81% chance of completing the level in 2 seconds and a 19% chance of needing 8 seconds, both of which are within the goal time. The expected time is 0.81·2 + 0.19·8 = 3.14. In the second example, you should reset after the first level if you complete it slowly. On average it will take 0.25 slow attempts before your first fast attempt. Then it doesn’t matter whether you complete the second level fast or slow. The expected time is 0.25·30 + 20 + 0.85·3 + 0.15·9 = 31.4. 令$F[i][j]$表示完成前$i$个关卡，当前用了$j$秒，完成所有关卡还需要的期望时间。那么可以得到转移$$F[i][j]=min{F[0][0],(F[i+1][j+A_{i+1}]+A_{i+1})\times\frac{P_i}{100}+(F[i+1][j+B_{i+1}]+B_{i+1})\times\frac{100-P_i}{100}}$$注意到这个转移方程里面有一项$F[0][0]$导致我们不能直接递推，这里就需要一种新姿势，二分答案。 先二分$F[0][0]$的值，然后带到这个$dp$里面去算，如果算出来的$F[0][0]$比二分的值大，说明当前二分的值不可行，那么$l=mid$，否则$r=mid$ 另外要注意，初值不要给无穷大，全部赋成$mid$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 5555using namespace std;const double eps=1e-7;int n,m,A[N],B[N],C[N],P[N];double F[55][N];bool Get(double mid)&#123; int i,j; for(i=0;i&lt;=n;i++)fill(F[i],F[i]+N,mid); for(i=0;i&lt;=m;i++)F[n][i]=0; for(i=n-1;i&gt;=0;i--) for(j=m-A[i+1];j&gt;=0;j--) &#123; F[i][j]=1.0*P[i+1]/100.0*(F[i+1][j+A[i+1]]+A[i+1])+(100.0-P[i+1])/100.0*(F[i+1][j+B[i+1]]+B[i+1]); if(F[i][j]&gt;mid)F[i][j]=mid; &#125; return F[0][0]&lt;mid;&#125;double EF(double l,double r)&#123; while(r-l&gt;eps) &#123; double mid=(l+r)/2; if(Get(mid))r=mid; else l=mid; &#125; return r;&#125;int main()&#123; int i,j,k,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;A[i],&amp;B[i],&amp;P[i]); printf("%.7lf",EF(0,1e9));&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>分治法</category>
        <category>概率与期望</category>
        <category>一般dp</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 6031（雅礼集训2017 Day1）字符串（后缀自动机+倍增）]]></title>
    <url>%2F2018%2F03%2F27%2FLOJ-6031%EF%BC%88%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2017-Day1%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%80%8D%E5%A2%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「雅礼集训 2017 Day1」字符串问题描述 令 $ s $ 与 $ w $ 为两字符串，定义： $ w[l, r] $ 表示字符串 $ w $ 在区间 $ [l, r] $ 中的子串； $ w $ 在 $ s $ 中出现的频率定义为$ w $ 在 $ s $ 中出现的次数； $ f(s, w, l, r) $ 表示 $ w[l, r] $ 在 $ s $ 中出现的频率。 比如 $ f(\texttt{ababa}, \texttt{aba}, 1, 3) = 2 $。 现在给定串 $ s $，$ m $ 个区间 $ [l, r] $ 和长度 $ k $，你要回答 $ q $ 个询问，每个询问给你一个长度为 $ k $ 的字符串 $ w $ 和两个整数 $ a, b $，求： $$ \sum\limits_{i = a} ^ b f(s, w, l_i, r_i) $$ 输入格式 第一行四个整数 $ n, m, q, k $，$ n $ 表示 $ s $ 的长度。 接下来一行一个长为 $ s $ 的字符串 $ s $。 接下来 $ m $ 行，每行两个整数表示 $ l_i, r_i $。 接下来 $ q $ 行，每行一个字符串 $ w $，两个整数 $ a, b $。 输出格式 对于每个询问一行，输出答案。 样例输入 8 5 3 3 abacdaba 0 2 1 2 0 0 2 2 1 2 dab 1 4 bac 2 3 eeb 1 3 样例输出 7 3 2 提示 对于 $ 10\% $ 的数据，$ n, m, k, q \leq 10 $； 对于 $ 30\% $ 的数据，满足 $ n, m, k, q \leq 10 ^ 2 $； 对于 $ 50\% $ 的数据，满足 $ n, m, k, q \leq 10 ^ 4 $； 对于 $ 100\% $ 的数据，满足 $ n, m, k, q \leq 10 ^ 5, \sum w \leq 10 ^ 5 $，字符串由小写英文字母构成。 注意到这题给出的条件$\sum w\leq 10^5$，即$qk\leq10^5$，那么这个条件就是解题的关键了。 由于$q,k$不会同时很大，因此我们考虑设计两种算法，分别针对$q$很大和$k$很大的情况。 对于$q$很大的情况，此时$k$比较小，那么由于不同的区间最多有$k^2$个，那么$m$个区间中会存在一些重复，考虑将这些重复的部分一起计算，令$Q[i][j]$表示左端点在$i$，右端点在$j$的区间集合。 对于每个询问，我们可以用$k^2$的时间计算出每个区间在$s$中出现的次数，具体做法是建出$s$的后缀自动机，枚举左端点，右端点在自动机上跑，然后所在位置的$right$集合大小就是出现次数。 然后我们枚举这$k^2$个区间，看看有多少个是在$[a,b]$之间的。这个可以二分查找。也可以离线用莫队来处理，如果用莫队就只需要将计算出来的出现次数存在$cnt[i][j]$里面，答案就是$cnt[i][j]\times (i,j)在[a,b]中出现次数$。 如果用二分查找，复杂度是$O(qk^2\log m)$，如果用莫队，复杂度是$O(qk^2+m\sqrt{m})$ 对于$k$很大的情况，由于q比较小，我们可以直接$O(qm)$对每个询问暴力查找每个区间的出现次数，如果能在较低复杂度内查找$w[l,r]$在$s$中出现次数，那么可以解决这个问题。然后这个可以考虑在$SAM$上倍增，考虑到子串就是前缀的后缀，那么我们先将$w$在自动机上匹配一次，记录下每个前缀在自动机上的匹配位置，然后就可以在$parent$树上倍增查找到子串位置了。 时间复杂度$O(qm\log n+qk)$ 既然这样，我们可以设置一个阈值$S=\sqrt{10^5}$，然后当$k&lt;S$时用算法一，否则用算法二。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 400005#define ll long longusing namespace std;const int K=400;ll Ans;int n,m,q,k,L[N],R[N];char s[N],w[N];namespace SAM&#123; int tot,rt,las,par[N][20],Max[N],son[N][26],si[N]; bool vis[N]; vector&lt;int&gt;G[N]; int NP(int v)&#123;return Max[++tot]=v,tot;&#125; void Init()&#123;tot=0;las=rt=++tot;&#125; void Ins(int t) &#123; int p=las,q,np,nq; np=NP(Max[p]+1);si[np]=1; while(p&amp;&amp;!son[p][t])son[p][t]=np,p=par[p][0]; if(!p)par[np][0]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)par[np][0]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); par[nq][0]=par[q][0]; par[q][0]=par[np][0]=nq; while(p&amp;&amp;son[p][t]==q)son[p][t]=nq,p=par[p][0]; &#125; &#125; las=np; &#125; void Build()&#123;for(int i=2;i&lt;=tot;i++)G[par[i][0]].push_back(i);&#125; void DFS(int x) &#123; int i,y; for(i=1;i&lt;=18;i++)par[x][i]=par[par[x][i-1]][i-1]; for(i=0;i&lt;G[x].size();i++) &#123; y=G[x][i];DFS(y); si[x]+=si[y]; &#125; &#125; void Match(int &amp;p,int t,int &amp;len) &#123; while(p&amp;&amp;!son[p][t])p=par[p][0],len=Max[p]; if(p)p=son[p][t],len++; else p=rt,len=0; &#125; int Jump(int p,int l) &#123; for(int i=18;i&gt;=0;i--)if(Max[par[p][i]]&gt;=l)p=par[p][i]; return p; &#125;&#125;void Solve1()&#123; vector&lt;int&gt;Q[K][K]; int i,j,a,b,p,l,r,cnt=0; for(i=0;i&lt;m;i++)Q[L[i]][R[i]].push_back(i); while(q--) &#123; scanf("%s%d%d",w,&amp;a,&amp;b);Ans=0; for(i=0;i&lt;k;i++) &#123; p=SAM::rt; for(j=i;j&lt;k;j++) &#123; p=SAM::son[p][w[j]-'a']; if(p==0)break; cnt=SAM::si[p]; l=lower_bound(Q[i][j].begin(),Q[i][j].end(),a)-Q[i][j].begin(); r=upper_bound(Q[i][j].begin(),Q[i][j].end(),b)-Q[i][j].begin(); Ans+=1ll*cnt*(r-l); &#125; &#125; printf("%lld\n",Ans); &#125;&#125;void Solve2()&#123; int i,l,r,a,b,p,len[N]=&#123;0&#125;,pos[N]=&#123;0&#125;,tmp; while(q--) &#123; scanf("%s%d%d",w,&amp;a,&amp;b);Ans=0; p=SAM::rt;tmp=0; for(i=0;i&lt;k;i++) &#123; SAM::Match(p,w[i]-'a',tmp); pos[i]=p;len[i]=tmp; &#125; for(i=a;i&lt;=b;i++) &#123; if(R[i]-L[i]+1&gt;len[R[i]])continue; p=SAM::Jump(pos[R[i]],R[i]-L[i]+1); Ans+=SAM::si[p]; &#125; printf("%lld\n",Ans); &#125;&#125;int main_main()&#123; int i; scanf("%d%d%d%d%s",&amp;n,&amp;m,&amp;q,&amp;k,s); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;L[i],&amp;R[i]); SAM::Init(); for(i=0;i&lt;n;i++)SAM::Ins(s[i]-'a'); SAM::Build(); SAM::DFS(SAM::rt); if(k&lt;K)Solve1(); else Solve2();&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>分治法</category>
        <category>后缀自动机</category>
        <category>莫队</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>后缀自动机</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 6030（雅礼集训2017 Day1）矩阵（乱搞）]]></title>
    <url>%2F2018%2F03%2F27%2FLOJ-6030%EF%BC%88%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2017-Day1%EF%BC%89%E7%9F%A9%E9%98%B5%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「雅礼集训 2017 Day1」矩阵问题描述 有一个 $ n \times n $ 的矩阵，每个位置 $ (i, j) $ 如果是 . 表示为白色，如果是 # 表示为黑色。 初始时，每个位置可以是黑色或白色的，$ (i, j) $ 位置的值会作为 $ a_{i, j} $ 给你。 现在有一种操作，选择两个整数 $ i, j \in [1, n] $，记 $ (i, 1), (i, 2), \ldots, (i, n) $ 的颜色为 $ C_1, C_2, \ldots C_n $，将 $ (1, j), (2, j), \ldots, (n, j) $ 的颜色赋为 $ C_1, C_2, \ldots, C_n $。 你的任务是将整个矩阵变成全黑，如果能够办到，输出最少步数，否则输出 $ -1 $。 输入格式 第一行一个整数 $ n $。 接下来 $ n $ 行，每行 $ n $ 个字符表示整个矩阵。 输出格式 输出只有一行，一个整数表示答案。 样例输入 2#..# 样例输出 3 提示 对于 $ 30\% $ 的数据，$ n \leq 4 $； 对于另外 $ 20\% $ 的数据，满足每一列都至少有一个黑色的格子； 对于 $ 100\% $ 的数据，$ 1 \leq n \leq 1000 $。 容易发现题目无解当且仅当该矩阵全白。 容易发现最优解一定是先得到全黑的一行。 因此我们考虑直接枚举将哪一行变成全黑，容易发现要将第$i$行变成全黑，需要第$i$列有一个黑色格子，并且每次只能使一个位置变黑。 因此我们只需要算算初始有多少行，多少列是全黑，然后枚举将哪一行变成全黑，然后取最小值就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;char map[N][N];int n,cntx,cnty;bool No=1;int Calx()&#123; for(int i=1;i&lt;=n;i++) &#123; int k=1; for(int j=1;j&lt;=n;j++)if(map[i][j]=='.')k=0; cntx+=k; &#125;&#125;int Caly()&#123; for(int i=1;i&lt;=n;i++) &#123; int k=1; for(int j=1;j&lt;=n;j++)if(map[j][i]=='.')k=0; cnty+=k; &#125;&#125;int Cal(int x)&#123; int i,j,k=1,cnt=0; for(i=1;i&lt;=n;i++)if(map[i][x]=='#')k=0; for(i=1;i&lt;=n;i++)cnt+=map[x][i]=='.'; return cnt+k;&#125;int main()&#123; int i,j,k,Min=1e9; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%s",&amp;map[i][1]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)if(map[i][j]=='#')No=0; if(No)return puts("-1"),0; Calx();Caly(); if(cntx==n)return puts("0"),0; if(cntx!=0)return printf("%d",n-cnty),0; for(i=1;i&lt;=n;i++)Min=min(Min,Cal(i)+n-cnty); printf("%d",Min);&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 6029（雅礼集训2017 Day1）市场（线段树）]]></title>
    <url>%2F2018%2F03%2F27%2FLOJ-6029%EF%BC%88%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2017-Day1%EF%BC%89%E5%B8%82%E5%9C%BA%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[「雅礼集训 2017 Day1」市场问题描述 从前有一个贸易市场，在一位执政官到来之前都是非常繁荣的，自从他来了之后，发布了一系列奇怪的政令，导致贸易市场的衰落。 有 $ n $ 个商贩，从 $ 0 \sim n - 1 $ 编号，每个商贩的商品有一个价格 $ a_i $，有两种政令： $ l, r, c $，对于 $ i \in [l, r], a_i \leftarrow a_i + c $ $l, r, d $，对于 $ i \in [l, r], a_i \leftarrow \lfloor {a_i}/{d} \rfloor $ 现在有一个外乡的旅客想要了解贸易市场的信息，有两种询问方式： 给定 $ l, r $，求 $ \min_{i \in [l, r]} a_i $ 给定 $ l, r $，求 $ \sum_{i\in [l, r]} a_i $ 输入格式 第一行为两个空格隔开的整数 $ n, q $ 分别表示商贩个数和政令 + 询问个数。 第二行包含 $ n $ 个由空格隔开的整数 $ a_0 \sim a_{n - 1} $ 接下来 $ q $ 行，每行表示一个操作，第一个数表示操作编号 $ 1 \sim 4 $，接下来的输入和问题描述一致。 输出格式 对于每个 3、4 操作，输出询问答案。 样例输入 10 10 -5 -4 -3 -2 -1 0 1 2 3 4 1 0 4 1 1 5 9 1 2 0 9 3 3 0 9 4 0 9 3 0 1 4 2 3 3 4 5 4 6 7 3 8 9 样例输出 -2 -2 -2 -2 0 1 1 提示 对于 $ 30\% $ 的数据，$ n, q \leq 10 ^ 3 $； 对于 $ 60\% $ 的数据，保证数据随机； 对于 $ 100\% $ 的数据，$ 1 \leq n, q \leq 10 ^ 5, 0 \leq l \leq r \leq n - 1, c \in [-10 ^ {4}, 10 ^ 4], d \in [2, 10 ^ 9] $ 对于操作1，打个lazy就行了，对于操作二，直接在线段树上暴力下放，然后需要加一个优化。 令$Max,Min$分别为当前区间中最大值和最小值，如果$Max-\lfloor\frac{Max}{d}\rfloor=Min-\lfloor\frac{Min}{d}\rfloor$，此时相当于区间整体减一个数，打个lazy返回就行了。 这个复杂度我算不来，但根据一些理论，他是不会$TLE$的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005#define ll long longusing namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x;bool f=0; while(t!='-'&amp;&amp;(t&lt;48||t&gt;57))t=GC; if(t=='-')t=GC,f=1; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return f?-x:x;&#125;int n,m,tot;ll A[N];struct node&#123;node *ls,*rs;ll Max,Min,Sum,lazy;&#125;Seg[N&lt;&lt;2],*rt;void Div(ll &amp;x,ll y)&#123; if(x&gt;=0)x=x/y; else x=(x-y+1)/y;&#125;void MT(node *p)&#123; p-&gt;Max=max(p-&gt;ls-&gt;Max,p-&gt;rs-&gt;Max); p-&gt;Min=min(p-&gt;ls-&gt;Min,p-&gt;rs-&gt;Min); p-&gt;Sum=p-&gt;ls-&gt;Sum+p-&gt;rs-&gt;Sum;&#125;void PD(node *p,int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1;ll d=p-&gt;lazy; node *ls=p-&gt;ls,*rs=p-&gt;rs; ls-&gt;Max+=d;rs-&gt;Max+=d; ls-&gt;Min+=d;rs-&gt;Min+=d; ls-&gt;Sum+=d*(mid-l+1);rs-&gt;Sum+=d*(r-mid); ls-&gt;lazy+=d;rs-&gt;lazy+=d; p-&gt;lazy=0;&#125;void BT(node *p,int x,int y)&#123; if(x==y)&#123;p-&gt;Max=p-&gt;Min=p-&gt;Sum=A[x];return;&#125; int mid=x+y&gt;&gt;1; p-&gt;ls=&amp;Seg[++tot]; p-&gt;rs=&amp;Seg[++tot]; BT(p-&gt;ls,x,mid); BT(p-&gt;rs,mid+1,y); MT(p);&#125;void ADD(node *p,int l,int r,int x,int y,ll d)&#123; if(p-&gt;lazy)PD(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r) &#123; p-&gt;Max+=d;p-&gt;Min+=d;p-&gt;Sum+=(r-l+1)*d;p-&gt;lazy+=d; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)ADD(p-&gt;ls,l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)ADD(p-&gt;rs,mid+1,r,x,y,d); MT(p);&#125;void Div(node *p,int l,int r,int x,int y,ll d)&#123; if(p-&gt;lazy)PD(p,l,r); if(l==r)&#123;Div(p-&gt;Max,d);Div(p-&gt;Min,d);Div(p-&gt;Sum,d);return;&#125; if(x&lt;=l&amp;&amp;y&gt;=r) &#123; ll a=p-&gt;Max,b=p-&gt;Min;Div(a,d);Div(b,d); if(p-&gt;Max-a==p-&gt;Min-b) &#123; int k=a-p-&gt;Max; p-&gt;Max+=k;p-&gt;Min+=k;p-&gt;Sum+=(r-l+1)*k; p-&gt;lazy+=k;return; &#125; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)Div(p-&gt;ls,l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)Div(p-&gt;rs,mid+1,r,x,y,d); MT(p);&#125;ll Gmin(node *p,int l,int r,int x,int y)&#123; if(p-&gt;lazy)PD(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r)return p-&gt;Min; int mid=l+r&gt;&gt;1;ll lmin=1e18,rmin=1e18; if(x&lt;=mid&amp;&amp;y&gt;=l)lmin=Gmin(p-&gt;ls,l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)rmin=Gmin(p-&gt;rs,mid+1,r,x,y); return min(lmin,rmin);&#125;ll Gsum(node *p,int l,int r,int x,int y)&#123; if(p-&gt;lazy)PD(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r)return p-&gt;Sum; int mid=l+r&gt;&gt;1;ll sum=0; if(x&lt;=mid&amp;&amp;y&gt;=l)sum+=Gsum(p-&gt;ls,l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)sum+=Gsum(p-&gt;rs,mid+1,r,x,y); return sum;&#125;int main()&#123; int i,j,k,x,y;ll z; n=_R();m=_R(); for(i=1;i&lt;=n;i++)A[i]=_R(); rt=&amp;Seg[++tot];BT(rt,1,n); for(i=1;i&lt;=m;i++) &#123; k=_R(); if(k==1) &#123; x=_R();y=_R();z=_R(); ADD(rt,1,n,x+1,y+1,z); &#125; if(k==2) &#123; x=_R();y=_R();z=_R(); Div(rt,1,n,x+1,y+1,z); &#125; if(k==3) &#123; x=_R();y=_R(); printf("%lld\n",Gmin(rt,1,n,x+1,y+1)); &#125; if(k==4) &#123; x=_R();y=_R(); printf("%lld\n",Gsum(rt,1,n,x+1,y+1)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4422（CERC 2015）Cow Confinement（扫描线+线段树+差分）]]></title>
    <url>%2F2018%2F03%2F27%2FBZOJ-4422%EF%BC%88CERC-2015%EF%BC%89Cow-Confinement%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF-%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E5%B7%AE%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[CERC2015]奶牛围栏问题描述 一个10^6行10^6列的网格图，上面有一些牛、花和一些矩形围栏，围栏在格子的边界上，牛和花在格子里，牛只能向下或向右走，牛也不能穿过围栏和地图边界，求每头牛它能到达的花的数量。注意栅栏不会相交 .png) 输入格式 第一行一个数f表示矩形围栏的数量。 接下来f行，每行四个数x1,y1,x2,y2，表示(x1,y1)在围栏内部矩形的左上角，(x2,y2)在右下角。 接下来一行一个数m表示花的数量。 接下来m行每行两个数x,y，表示在(x,y)处有一朵花。 接下来一行一个数n表示牛的数量。 接下来n行每行两个数x,y，表示在(x,y)处有一头牛。 输出格式 总共n行，每行一个数ans，第i个数表示第i头牛能到ans个花。 样例输入 4 2 2 8 4 1 9 4 10 6 7 9 9 3 3 7 3 9 3 4 8 4 11 5 10 7 10 8 9 8 2 8 4 11 9 11 8 1 1 5 10 6 9 3 7 7 1 4 2 7 5 3 3 样例输出 5 1 0 1 3 1 3 0 由于每头牛只能往右或往下走，我们考虑从右往左扫描，令$f[i]$表示扫描到当前$x$坐标时，纵坐标为$i$的位置能到的花的数目，那么考虑维护$f[i]$，发现不是很好维护，令$g[i]=f[i]-f[i+1]$，考虑来维护$g[i]$ 如果遇到一朵花，就是单点修改，如果遇到右栅栏$[l,r]$，那么就是将$[l,p]$（p为$l$下方第一个栅栏的位置）区间的和加到$g[l-1]$上，然后记录一下当前$[r+1,p]$的和$res[i]$，再清空$[l,r]$ 如果遇到左栅栏$[l,r]$，就清空$[l,r]$区间，然后在$l-1$位置减去先前记录的$res[i]$，这个画个图就能看出来此时$res[i]$被重复计算了一次，因此要减掉。 如果遇到牛$x$，就是查询$[x,p]$的和，因此只需要扫描线时用线段树来维护$g[i]$即可。 这题疑似数据和描述不清，特别注意排序顺序。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#define N 200005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;int x; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48; return x;&#125;const int T=1e6+1;set&lt;int&gt;Q;struct node&#123;int x1,x2,y1,y2;&#125;fence[N];struct thh&#123;int pos,l,r,id,ty;&#125;op[N&lt;&lt;3];struct nodd&#123;int x,y,id;&#125;flower[N],cow[N];bool cmp1(thh a,thh b)&#123; if(a.pos!=b.pos)return a.pos&gt;b.pos; if(a.ty!=b.ty&amp;&amp;(a.ty&gt;2||b.ty&gt;2))return a.ty&lt;b.ty; if(a.l!=b.l)return a.l&lt;b.l; return a.r&lt;b.r;&#125;int f,n,m,res[N],Ans[N];namespace Seg&#123; int tot,ls[T&lt;&lt;2],rs[T&lt;&lt;2],v[T&lt;&lt;2],lazy[T&lt;&lt;2]; int BT(int x,int y) &#123; int p=++tot; if(x==y)return p; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); return p; &#125; void PD(int p) &#123; v[ls[p]]=v[rs[p]]=0; lazy[ls[p]]=lazy[rs[p]]=1; lazy[p]=0; &#125; void Clear(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;v[p]=0;lazy[p]=-1;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)Clear(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)Clear(rs[p],mid+1,r,x,y); v[p]=v[ls[p]]+v[rs[p]]; &#125; void ADD(int p,int l,int r,int k,int d) &#123; if(lazy[p])PD(p);v[p]+=d; if(l==r)return; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ADD(ls[p],l,mid,k,d); else ADD(rs[p],mid+1,r,k,d); v[p]=v[ls[p]]+v[rs[p]]; &#125; int GS(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)return v[p]; int mid=l+r&gt;&gt;1,sum=0; if(x&lt;=mid&amp;&amp;y&gt;=l)sum+=GS(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)sum+=GS(rs[p],mid+1,r,x,y); return sum; &#125;&#125;int Get(int x)&#123; set&lt;int&gt;::iterator it=Q.lower_bound(x); return *it;&#125;int main()&#123; int i,j,k,x,y,x1,x2,y1,y2,tot; f=_R(); for(i=1;i&lt;=f;i++) &#123; x1=_R();y1=_R();x2=_R();y2=_R(); fence[i]=(node)&#123;x1,x2,y1,y2&#125;; &#125; m=_R();for(i=1;i&lt;=m;i++)flower[i]=(nodd)&#123;_R(),_R(),i&#125;; n=_R();for(i=1;i&lt;=n;i++)cow[i]=(nodd)&#123;_R(),_R(),i&#125;; for(i=1;i&lt;=f;i++) &#123; op[i]=(thh)&#123;fence[i].y1-1,fence[i].x1,fence[i].x2,i,2&#125;; op[i+f]=(thh)&#123;fence[i].y2,fence[i].x1,fence[i].x2,i,1&#125;; &#125; Seg::BT(0,T);tot=f+f;Q.insert(T); for(i=1;i&lt;=m;i++)op[++tot]=(thh)&#123;flower[i].y,flower[i].x,0,i,3&#125;; for(i=1;i&lt;=n;i++)op[++tot]=(thh)&#123;cow[i].y,cow[i].x,0,i,4&#125;; sort(op+1,op+tot+1,cmp1); for(i=1;i&lt;=tot;i++) &#123; if(op[i].ty==1) &#123; res[op[i].id]=Seg::GS(1,0,T,op[i].r+1,Get(op[i].r+1)); int tmp=Seg::GS(1,0,T,op[i].l,Get(op[i].l)); Seg::Clear(1,0,T,op[i].l,op[i].r); Seg::ADD(1,0,T,op[i].l-1,tmp); Q.insert(op[i].l-1);Q.insert(op[i].r); &#125; else if(op[i].ty==3)Seg::ADD(1,0,T,op[i].l,1); else if(op[i].ty==4)Ans[op[i].id]=Seg::GS(1,0,T,op[i].l,Get(op[i].l)); else if(op[i].ty==2) &#123; Seg::Clear(1,0,T,op[i].l,op[i].r); Seg::ADD(1,0,T,op[i].l-1,-res[op[i].id]); Q.erase(op[i].l-1);Q.erase(op[i].r); &#125; &#125; for(i=1;i&lt;=n;i++)printf("%d\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>杂学</category>
        <category>扫描线</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>差分</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 5197（CERC 2017）Gambling Guide（数学期望+动态规划+最短路）]]></title>
    <url>%2F2018%2F03%2F26%2FBZOJ-5197%EF%BC%88CERC-2017%EF%BC%89Gambling-Guide%EF%BC%88%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【CERC2017】旅游指南问题描述 给定一张n个点，m条双向边的无向图。 你要从1号点走到n号点。当你位于x点时，你需要花1元钱，等概率随机地买到与x相邻的一个点的票，只有通过票才能走到其它点。 每当完成一次交易时，你可以选择直接使用那张票，也可以选择扔掉那张票然后再花1元钱随机买另一张票。注意你可以无限次扔票。 请使用最佳的策略，使得期望花的钱数最少。 输入格式 第一行包含两个正整数n,m(1&lt;=n,m&lt;=300000)，表示点数和边数。 接下来m行，每行两个正整数u,v(1&lt;=u,v&lt;=n)，表示一条双向边。 输入数据保证无重边、无自环，且1号点一定可以走到n号点。 输出格式 输出一行一个实数，即最少的期望花费，当绝对或者相对误差不超过10^{-6}时视为正确。 样例输入 5 8 1 2 1 3 1 4 2 3 2 4 3 5 5 4 2 5 样例输出 4.1111111111 如果不用最优策略，那么可以得到dp方程$dp[x]=\frac{\sum dp[y]}{d[x]}+1$，然后可以用高斯消元处理。 再考虑最优策略，只需要修改一下dp方程，$dp[x]=\frac{\sum min(dp[x],dp[y])}{d[x]}+1$，这里的$min$表示如果$y$不优，那么可以停在原地。因此我们可以假设有$c$个$dp[y]&lt;dp[x]$，那么解方程可以得到$dp[x]=\frac{\sum dp[y]+d[x]}{c}$ 然后可以用Dijkstra来进行转移，初始时$dp[n]=0$，然后每次取$dp$值最小的且没用过的$dp[x]$出来，转移到$dp[y]$，具体实现可以看代码。 因为Dijkstra每次选的都是最优的点，那么就可以保证当$x$出堆时，所有$dp[y]&lt;dp[x]$的y都已经讨论过，即当前的$dp[x]$取得最优值。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 600005using namespace std;struct node&#123;double x;int p;&#125;;bool operator&lt;(node a,node b)&#123;return a.x&gt;b.x;&#125;int n,m,c[N],d[N];int TOT,LA[N],NE[N],EN[N];double dp[N],sum[N];bool mark[N];priority_queue&lt;node&gt;Q;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x);d[x]++;d[y]++; &#125; Q.push((node)&#123;0,n&#125;); while(Q.size()) &#123; node tmp=Q.top(); Q.pop();x=tmp.p; if(mark[x])continue; mark[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y])continue; sum[y]+=dp[x];c[y]++; dp[y]=(sum[y]+d[y])/(1.0*c[y]); Q.push((node)&#123;dp[y],y&#125;); &#125; &#125; printf("%.7lf",dp[1]);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>图论</category>
        <category>概率与期望</category>
        <category>一般dp</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>最短路</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4144（AMPPZ 2014）Petrol（最短路+最小生成树）]]></title>
    <url>%2F2018%2F03%2F26%2FBZOJ-4144%EF%BC%88AMPPZ-2014%EF%BC%89Petrol%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【AMPPZ2014】加油问题描述 给定一个n个点、m条边的带权无向图，其中有s个点是加油站。 每辆车都有一个油量上限b，即每次行走距离不能超过b，但在加油站可以补满。 q次询问，每次给出x,y,b，表示出发点是x，终点是y，油量上限为b，且保证x点和y点都是加油站，请回答能否从x走到y。 输入格式 第一行包含三个正整数n,s,m(2&lt;=s&lt;=n&lt;=200000,1&lt;=m&lt;=200000)，表示点数、加油站数和边数。 第二行包含s个互不相同的正整数c[1],c[2],…c[s] (1&lt;=c[i]&lt;=n)，表示每个加油站。 接下来m行，每行三个正整数u[i],v[i],di，表示u[i]和v[i]之间有一条长度为d[i]的双向边。 接下来一行包含一个正整数q(1&lt;=q&lt;=200000)，表示询问数。 接下来q行，每行包含三个正整数x[i],y[i],b[i] (1&lt;=x[i],y[i]&lt;=n,x[i]!=y[i],1&lt;=b[i]&lt;=2*10^9)，表示一个询问。 输出格式 输出q行。第i行输出第i个询问的答案，如果可行，则输出TAK，否则输出NIE。 样例输入 6 4 5 1 5 2 6 1 3 1 2 3 2 3 4 3 4 5 5 6 4 5 4 1 2 4 2 6 9 1 5 9 6 5 8 样例输出 TAK TAK TAK NIE 先跑一个多源最短路，求出到每个点最近的加油站是哪里，然后枚举每条边，如果边的两端最近的加油站不同，那么连接这两个加油站，边权为$dis[x]+dis[y]+len$，这样建好图之后离线处理询问，排序之后跑生成树就行了。 正确性的话我们考虑任意两个加油站的连接的路径，路径上一定存在一个分界点，也就是我们枚举的边。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define ll long long#define N 400005using namespace std;struct node&#123;ll x,y,d,id;&#125;E[N],K[N];bool operator&lt;(node a,node b)&#123;return a.d&lt;b.d;&#125;ll n,s,m,q,fa[N],c[N],dis[N],pre[N],cnt,F[N],Ans[N];ll TOT,LA[N],NE[N],ST[N],EN[N],LE[N];bool mark[N];queue&lt;ll&gt;Q;ll GF(ll x)&#123;return x==F[x]?x:F[x]=GF(F[x]);&#125;void Merge(ll x,ll y)&#123; ll fx=GF(x),fy=GF(y); if(fx==fy)return; F[fx]=fy;&#125;void ADD(ll x,ll y,ll z)&#123; TOT++; ST[TOT]=x; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void SPFA()&#123; while(Q.size()) &#123; ll x=Q.front(); Q.pop(); mark[x]=0; for(ll i=LA[x];i;i=NE[i]) &#123; ll y=EN[i]; if(dis[y]&gt;dis[x]+LE[i]) &#123; dis[y]=dis[x]+LE[i]; pre[y]=pre[x]; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125;&#125;int main()&#123; ll i,j,k,x,y,z; scanf("%lld%lld%lld",&amp;n,&amp;s,&amp;m); fill(dis,dis+n+1,1e18); for(i=1;i&lt;=n;i++)F[i]=i; for(i=1;i&lt;=s;i++) &#123; scanf("%lld",&amp;c[i]);pre[c[i]]=c[i]; dis[c[i]]=0;mark[c[i]]=1;Q.push(c[i]); &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; SPFA();scanf("%lld",&amp;q); for(i=1;i&lt;=q;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); K[i]=(node)&#123;x,y,z,i&#125;; &#125; for(i=1;i&lt;=TOT;i+=2) &#123; x=ST[i];y=EN[i]; if(pre[x]!=pre[y])E[++cnt]=(node)&#123;pre[x],pre[y],dis[x]+dis[y]+LE[i],0&#125;; &#125; sort(K+1,K+q+1); sort(E+1,E+cnt+1); for(i=j=1;i&lt;=q;i++) &#123; while(j&lt;=cnt&amp;&amp;E[j].d&lt;=K[i].d)Merge(E[j].x,E[j].y),j++; if(GF(K[i].x)==GF(K[i].y))Ans[K[i].id]=1; &#125; for(i=1;i&lt;=q;i++)Ans[i]==1?puts("TAK"):puts("NIE");&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4842（NEERC 2016）Delight for a Cat（线性规划+差分+网络流）]]></title>
    <url>%2F2018%2F03%2F25%2FBZOJ-4842%EF%BC%88NEERC-2016%EF%BC%89Delight-for-a-Cat%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%B7%AE%E5%88%86-%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【Neerc2016】养猫问题描述 ls是一个特别堕落的小朋友，对于n个连续的小时，他将要么睡觉要么打隔膜，一个小时内他不能既睡觉也打隔膜，因此一个小时内他只能选择睡觉或者打隔膜，当然他也必须选择睡觉或打隔膜，对于每一个小时，他选择睡觉或打隔膜的愉悦值是不同的，对于第i个小时，睡觉的愉悦值为$s_i$，打隔膜的愉悦值为$e_i$，同时又有一个奥妙重重的规定：对于任意一段连续的k小时，ls必须至少有$t_1$时间在睡觉，$t_2$时间在打隔膜。那么ls想让他获得的愉悦值尽量大，他该如何选择呢？ 输入格式 第一行四个整数,$n,k(1&lt;=k&lt;=n&lt;=1000),t_1,t_2(0&lt;=t_1,t_2&lt;=k;t_1+t_2&lt;=k$),含义如上所述。 接下来一行n个整数，第i个整数$s_i(0&lt;=s_i&lt;=10^9)$表示睡觉的愉悦值。 接下来一行n个整数，第i个整数$e_i(0&lt;=e_i&lt;=10^9)$表示打隔膜的愉悦值。 输出格式 一行输出最大的愉悦值。 样例输入 10 4 1 2 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 样例输出 69 这题比较劲，首先我们假设每天都打隔膜，然后令$x_i$表示第$i$天是否睡觉，如果睡觉就会产生$s_i-e_i$的愉悦值 然后对于$k$的限制，我们可以列出方程。$$\begin{cases}t_1\leq x_1+x_2+\cdots+x_k\leq k-t_2\\t_1\leq x_2+x_3+\cdots+x_{k+1}\leq k-t_2\\\quad\quad\quad\quad\quad\quad\quad\quad\vdots\\t_1\leq x_{n-k+1}+x_{n-k+2}+\cdots+x_n\leq k-t_2\end{cases}$$然后我们要求的是$\sum_{i=1}^{n}(s_i-e_i)x_i$，这里$0\leq x_i\leq 1$，那么这就是一个线性规划问题。 这里可以用费用流来解决非负整数上的线性规划问题，现将不等式转化成等式，设一些辅助元。$$\begin{cases}\x_1+x_2+\cdots+x_k&amp;=t_1+y_1\\x_1+x_2+\cdots+x_k&amp;=k-t_2-z_1\\x_2+x_3+\cdots+x_{k+1}&amp;=t_1+y_2\\&amp;\vdots\end{cases}$$然后在末尾添加一个方程$0=0$，然后对这个方程组差分，得到$$\begin{cases}\x_1+x_2+\cdots+x_k&amp;=t_1+y_1\\y_1+z_1&amp;=k-t_1-t_2\\x_{k+1}+k-t_1-t_2&amp;=x_1+y_2+z_1\\&amp;\vdots\\k-t_2-z_{n-k+1}&amp;=x_{n-k+1}+x_{n-k+2}+\cdots+x_n\end{cases}$$然后观察这个方程组，我们可以发现，每一个变量恰好在等号左边和右边各出现了一次，又因为每个变量都是非负的，因此我们可以将每个变量看成边，变量的取值看成流量，每个等式看成一个点，然后这个方程就描述了每个点的出入流量守恒，因此我们可以假设左边为流出，右边为流入。 那么对于每个$x_i$，从他在左边的方程连到他在右边的方程，容量为$1$，费用为$s_i-e_i$ 对于每个$y_i,z_i$，同样连接他所在的两个方程，容量为$inf$，费用为$0$ 最后对于常数项，如果在左边，就从方程连到汇点，反之从源点连到方程，容量为它的值，费用为$0$ 这样建好图之后，跑一遍最大费用最大流，再加上$\sum_{i=1}^{n}e_i$就是答案，正确性自己画个图感受一下就能明白。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define ll long long#define N 10005using namespace std;ll n,k,t1,t2,A[N],B[N],S,T,tot;ll TOT=1,LA[N],NE[N],EN[N],G[N],LE[N];ll dis[N],use[N],pre[N],maxflow,maxcost;queue&lt;ll&gt;Q;bool mark[N];void ADD(ll x,ll y,ll z,ll c)&#123; TOT++; G[TOT]=c; LE[TOT]=z; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Link(ll x,ll y,ll z,ll c)&#123; ADD(x,y,z,c); ADD(y,x,-z,0);&#125;bool FP()&#123; fill(dis,dis+T+1,-1e18); dis[S]=0;Q.push(S);mark[S]=1; while(Q.size()) &#123; ll x=Q.front(); Q.pop();mark[x]=0; for(ll i=LA[x];i;i=NE[i]) &#123; ll y=EN[i];if(!G[i])continue; if(dis[y]&lt;dis[x]+LE[i]) &#123; dis[y]=dis[x]+LE[i]; pre[y]=x;use[y]=i; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125; return dis[T]!=-1e18;&#125;void AF()&#123; ll f=1e18; for(ll i=T;i!=S;i=pre[i])f=min(f,G[use[i]]); maxflow+=f;maxcost+=f*dis[T]; for(ll i=T;i!=S;i=pre[i])G[use[i]]-=f,G[use[i]^1]+=f;&#125;int main()&#123; ll i,j,t,ans=0; scanf("%lld%lld%lld%lld",&amp;n,&amp;k,&amp;t1,&amp;t2); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;B[i]),ans+=B[i]; tot=2*n-2*k+3;S=tot+1;T=S+1; Link(S,1,0,t1);Link(tot,T,0,k-t2); for(i=2;i&lt;=tot;i+=2) &#123; Link(S,i,0,k-t1-t2); Link(i,i-1,0,1e9); Link(i,i+1,0,1e9); &#125; for(i=3;i&lt;tot;i+=2)Link(i,T,0,k-t1-t2); for(i=1,j=3;i&lt;=k;i++,j+=2) &#123; if(j&gt;tot)j=tot; Link(1,j,A[i]-B[i],1); &#125; for(i=k+1,t=3;i&lt;=n;i++,j+=2,t+=2) &#123; if(j&gt;tot)j=tot; Link(t,j,A[i]-B[i],1); &#125; while(FP())AF(); printf("%lld",ans+maxcost);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>图论</category>
        <category>杂学</category>
        <category>线性规划</category>
        <category>网络流</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>网络流</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4152（AMPPZ 2014）The Captain（最短路）]]></title>
    <url>%2F2018%2F03%2F25%2FBZOJ-4152%EF%BC%88AMPPZ-2014%EF%BC%89The-Captain%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【AMPPZ2014】船长问题描述 给定平面上的n个点，定义(x1,y1)到(x2,y2)的费用为min(|x1-x2|,|y1-y2|)，求从1号点走到n号点的最小费用。 输入格式 第一行包含一个正整数n(2&lt;=n&lt;=200000)，表示点数。 接下来n行，每行包含两个整数x[i],yi，依次表示每个点的坐标。 输出格式 一个整数，即最小费用。 样例输入 5 2 2 1 1 4 5 7 1 6 7 样例输出 2 注意到这个距离的定义，直接先按x排序，相邻点连边，然后按y排序，相邻点连边，然后跑Dijkstra就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 200005#define M 2000005#define ll long longusing namespace std;typedef pair&lt;ll,ll&gt; par; struct node&#123;ll x,y,id;&#125;P[N];ll n,TOT,LA[N],NE[M],EN[M],LE[M],dis[N];priority_queue&lt;par&gt;Q;bool cmp1(node a,node b)&#123;return a.x&lt;b.x;&#125;bool cmp2(node a,node b)&#123;return a.y&lt;b.y;&#125;void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Link(ll x,ll y,ll z)&#123;ADD(x,y,z);ADD(y,x,z);&#125;void Dijkstra()&#123; fill(dis,dis+n+1,1e18); dis[1]=0;Q.push(par(0,1)); while(Q.size()) &#123; par tmp=Q.top(); Q.pop(); if(dis[tmp.second]!=-tmp.first)continue; for(int i=LA[tmp.second];i;i=NE[i]) &#123; int y=EN[i]; if(dis[y]&gt;LE[i]-tmp.first) &#123; dis[y]=LE[i]-tmp.first; Q.push(par(-dis[y],y)); &#125; &#125; &#125;&#125;int main()&#123; ll i; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld%lld",&amp;P[i].x,&amp;P[i].y),P[i].id=i; sort(P+1,P+n+1,cmp1); for(i=2;i&lt;=n;i++)Link(P[i].id,P[i-1].id,P[i].x-P[i-1].x); sort(P+1,P+n+1,cmp2); for(i=2;i&lt;=n;i++)Link(P[i].id,P[i-1].id,P[i].y-P[i-1].y); Dijkstra();printf("%lld",dis[n]);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2017 影魔（扫描线+线段树+树状数组）]]></title>
    <url>%2F2018%2F03%2F24%2FHNOI-2017-%E5%BD%B1%E9%AD%94%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Description 影魔，奈文摩尔，据说有着一个诗人的灵魂。事实上，他吞噬的诗人灵魂早已成千上万。千百年来，他收集了各式各样的灵魂，包括诗人、牧师、帝王、乞丐、奴隶、罪人，当然，还有英雄。 每一个灵魂，都有着自己的战斗力，而影魔，靠这些战斗力提升自己的攻击。 奈文摩尔有n个灵魂，他们在影魔宽广的体内可以排成一排，从左至右标号1到n。第i个灵魂的战斗力为k[i]，灵魂们以点对的形式为影魔提供攻击力，对于灵魂对i，j (i &lt; j) 来说，若不存在k[s] (i &lt; s &lt; j) 大于k[i]或者k[j]，则会为影魔提供p1的攻击力（可理解为：当j=i+1时，因为不存在满足i &lt; s &lt; j的s，从而k[s]不存在，这时提供p1的攻击力；当j&gt;i+1时，若max{k[s]|i&lt;s&lt;j}&lt;=min(k[i],k[j])，则提供p1的攻击力）；另一种情况，令c为k[i+1],k[i+2],k[i+3]……k[j-1]的最大值，若c满足：k[i] &lt; c &lt; k[j],或者k[j] &lt; c &lt; k[i]，则会为影魔提供p2的攻击力，当这样的c不存在时，自然不会提供这p2的攻击力；其他情况的点对，均不会为影魔提供攻击力。 影魔的挚友噬魂鬼在一天造访影魔体内时被这些灵魂吸引住了，他想知道，对于任意一段区间[a,b]，1&lt;=a &lt; b&lt;=n，位于这些区间中的灵魂对会为影魔提供多少攻击力，即考虑所有满足a&lt;=i &lt; j&lt;=b的灵魂对i,j提供的攻击力之和。 顺带一提，灵魂的战斗力组成一个1到n的排列：k[1],k[2],…,k[n]。 Input 第一行n,m,p1,p2 第二行n个数：k[1],k[2],…,k[n] 接下来m行，每行两个数a,b，表示询问区间[a,b]中的灵魂对会为影魔提供多少攻击力。 Output 共输出m行，每行一个答案，依次对应m个询问。 Sample Input 10 5 2 3 7 9 5 1 3 10 6 8 2 4 1 7 1 9 1 3 5 9 1 5 Sample Output 30 39 4 13 16 Data Constraint 30%：1&lt;= n,m &lt;= 500。 另30%: p1=2*p2。 100%:1 &lt;= n,m &lt;= 200000；1 &lt;= p1,p2 &lt;= 1000。 首先考虑$p_1$的贡献，那么需要计算有多少对$(i,j)$满足$k[i],k[j]$分别是$[i,j]$的最大值和次大值。 我们讨论每个点对中的次大值，那么当$k[i]$为区间次大值时，找到$k[i]$左边第一个比它大的数$k[l]$，右边第一个比他大的数$k[r]$，那么以$k[i]$为次大值的点对就是$(l,i)$和$(i,r)$ 那么询问$p_1$的贡献就等价于问以$(a,a)$为左下角$(b,b)$为右上角的矩形中有多少个点。 将每个询问拆成两个询问，即以$(1,a)$为左下角，$(a-1,b)$为右上角的矩形和以$(1,a)$为左下角$(b,b)$为右上角的两个矩形相减即可，然后用扫描线从左往右扫一遍，用树状数组维护纵坐标的区间和即可。 然后考虑$p_2$的贡献，需要计算有多少对$(i,j)$满足一个端点是最大值，另一个不是次大值。这个不好计算，但我们可以发现$p_1$与$p_2$的贡献和很好算，即计算有多少对$(i,j)$满足其中一个是区间最大值。 那么考虑每个点$k[i]$，那么同样找出每个点左边第一个比他大的数$k[l]$，右边$k[r]$，则满足条件的点对是$([l+1,i-1],i)$与$(i,[i+1,r-1])$，这些点对，容易发现我们可以将这些点对抽象成线段，即横坐标为$i$，纵坐标在$[l+1,i-1]$与$[i+1,r-1]$之间的线段，这样的话同样可以扫描线，只不过单点修改变成了区间修改。 那么$p_2$的点对数就是上述算出来的点对数减去$p_1$的点对数即可。 总时间复杂度$O(n\log n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define N 400005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,m,v1,v2,A[N],L[N],R[N],cnt1[N],cnt2[N];stack&lt;int&gt;S;struct nodd&#123;int pos,x1,x2,ty,id;&#125;T[N],Q[N];struct node&#123;int l,r,id;&#125;K[N];bool operator&lt;(nodd a,nodd b)&#123;return a.pos&lt;b.pos;&#125;namespace BIT&#123; int C[N]; void MD(int x,int d) &#123;for(int i=x;i&amp;&amp;i&lt;=n;i+=(i&amp;-i))C[i]+=d;&#125; int GS(int x) &#123; int i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=C[i]; return sum; &#125;&#125;namespace Seg&#123; int tot,ls[N],rs[N],v[N],lazy[N]; int BT(int x,int y) &#123; int p=++tot; if(x==y)return p; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); return p; &#125; void PD(int p,int l,int r) &#123; int mid=l+r&gt;&gt;1; if(ls[p])v[ls[p]]+=lazy[p]*(mid-l+1),lazy[ls[p]]+=lazy[p]; if(rs[p])v[rs[p]]+=lazy[p]*(r-mid),lazy[rs[p]]+=lazy[p]; lazy[p]=0; &#125; void ADD(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;lazy[p]++;v[p]+=r-l+1;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)ADD(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)ADD(rs[p],mid+1,r,x,y); v[p]=v[ls[p]]+v[rs[p]]; &#125; int GS(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r)return v[p]; int mid=l+r&gt;&gt;1,sum=0; if(x&lt;=mid&amp;&amp;y&gt;=l)sum+=GS(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)sum+=GS(rs[p],mid+1,r,x,y); return sum; &#125;&#125;int main()&#123; int i,j,k,x,y,pt=0; _R(n);_R(m);_R(v1);_R(v2); for(i=1;i&lt;=n;i++)_R(A[i]); A[0]=A[n+1]=1e9;S.push(0); for(i=1;i&lt;=n;i++) &#123; while(A[S.top()]&lt;A[i])S.pop(); L[i]=S.top();S.push(i); &#125; while(S.size())S.pop(); S.push(n+1); for(i=n;i&gt;=1;i--) &#123; while(A[S.top()]&lt;A[i])S.pop(); R[i]=S.top();S.push(i); &#125; for(i=1;i&lt;=m;i++) &#123; _R(x);_R(y); K[i]=(node)&#123;x,y,i&#125;; &#125; for(i=1;i&lt;=n;i++) &#123; T[i]=(nodd)&#123;i,L[i],0,0,0&#125;; T[n+i]=(nodd)&#123;i,R[i],0,0,0&#125;; &#125; for(i=1;i&lt;=m;i++) &#123; Q[i]=(nodd)&#123;K[i].l-1,K[i].l,K[i].r,-1,i&#125;; Q[i+m]=(nodd)&#123;K[i].r,K[i].l,K[i].r,1,i&#125;; &#125; sort(T+1,T+n+n+1);sort(Q+1,Q+m+m+1); for(i=j=1;i&lt;=m+m;i++) &#123; while(j&lt;=n+n&amp;&amp;T[j].pos&lt;=Q[i].pos) BIT::MD(T[j].x1,1),j++; cnt1[Q[i].id]+=Q[i].ty*(BIT::GS(Q[i].x2)-BIT::GS(Q[i].x1-1)); &#125; for(i=1;i&lt;=n;i++) &#123; if(L[i]+1&lt;i)T[++pt]=(nodd)&#123;i,L[i]+1,i-1,0,0&#125;; if(R[i]-1&gt;i)T[++pt]=(nodd)&#123;i,i+1,R[i]-1,0,0&#125;; &#125; sort(T+1,T+pt+1);Seg::BT(1,n); for(i=j=1;i&lt;=m+m;i++) &#123; while(j&lt;=pt&amp;&amp;T[j].pos&lt;=Q[i].pos)Seg::ADD(1,1,n,T[j].x1,T[j].x2),j++; cnt2[Q[i].id]+=Q[i].ty*Seg::GS(1,1,n,Q[i].x1,Q[i].x2); &#125; for(i=1;i&lt;=m;i++)printf("%lld\n",1ll*v1*cnt1[i]+1ll*v2*(cnt2[i]-cnt1[i]));&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>杂学</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI 2015 小凸解密码（stl）]]></title>
    <url>%2F2018%2F03%2F24%2FSCOI-2015-%E5%B0%8F%E5%87%B8%E8%A7%A3%E5%AF%86%E7%A0%81%EF%BC%88stl%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Scoi2015]小凸解密码Description 小凸得到了一个密码盘，密码盘被等分成N个扇形，每个扇形上有一个数字(0～9)，和一个符号（“+”或”*”) 密码盘解密的方法如下： 首先，选择一个位置开始，顺时针地将数字和符号分别记在数组A和数组C巾 B0=A0 当x&gt;0时： 若Cx为“+”，Bx=(Ax+Ax-1)%10，注意：x-1是下标 若Cx为“*”，Bx= (Ax×Ax-1)%10,注意：x-1是下标值 操作完成后，可以得到一个长度为n的数组B，然后以B0为起点将B数组顺时针写成一个环，解密就完成了，称得到的环为答案环。 现在小凸得到了一份指令表，指令表上有2种操作。 一种指令是修改操作，即改变原来密码盘上一个位置的数字和符号。 另一种指令是询问操作，具体如下： 首先从指令给出的位置开始完成解密，得到答案环。 答案环上会有一些0连在一起，将这些连在一起的0称为零区间，找出其中距离B0最远的那个零区间，输出这个距离。 零区问和B0的距离定义为：零区问内所有0到B0距离中的最小值。 Input 第1行包含2个整数n,m，代表密码盘大小和指令个数 接下来n行，每行包含1个整数和1个字符，按顺时针顺序给出了密码盘上的数组和符号 接下来m行，依次给出指令 每行第1个整数代表指令类型 若第1个墼数为1，代表本行对应指令为修改操作，之后依次有2个整数pos，num和1个字符opt，分别代表修改的位置，以及修改后该位置的数字和字符 若第1个整数为2，代表本行对应指令位询问操作，之后有1个整数pos，代表本次操作中解密的开始位置 密码盘上的位置标号为0到n-1 数据保证合法，即数据中0≤pos&lt;N，0≤num≤9，opt为“+”或“*” Output 对于每个询问操作1行，输出答案，若答案环上没有0，输出-1 Sample Input 5 8 0 * 0 * 0 * 0 * 0 * 2 0 1 0 1 + 1 2 1 + 2 3 1 1 1 + 1 3 1 + 1 4 1 + 2 4 Sample Output 0 2 -1 HINT 对于100%数据，$5 &lt;=n，m≤10^5$ 这题容易想到直接维护$0$区间，这里可以使用线段树，也可以直接用set。 每次修改的时候在set里面合并或拆分区间，每次查询的时候直接找距离$x+\frac{n}{2}$最近的区间，然后为了减少特判直接查查左右相邻的几个区间取最大值就行了。 口头ac很简单，但由于要处理环，写起来细节很多，比较麻烦。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#define N 200005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;inline void _S(char &amp;c)&#123; c=GC; while(c!='+'&amp;&amp;c!='*')c=GC;&#125;struct node&#123;int l,r;&#125;;bool operator&lt;(node a,node b)&#123; if(a.l==b.l)return a.r&lt;b.r; return a.l&lt;b.l;&#125;bool Cross(node a,node b)&#123; if(a.r&gt;=b.l-1)return 1; return 0;&#125;bool In(int x,node a)&#123;return a.l&lt;=a.r?(x&gt;=a.l&amp;&amp;x&lt;=a.r):(x&lt;=a.r||x&gt;=a.l);&#125;node Merge(node a,node b)&#123; return (node)&#123;a.l,b.r&#125;;&#125;set&lt;node&gt;Q;int n,m,A[N],B[N];char C[N];int dis(int x,node a)&#123; if(In(x,a))return 0; int p=abs(x-a.l),q=abs(x-a.r); p=min(p,n-p);q=min(q,n-q); return min(p,q);&#125;int f(int a,int b,char c)&#123; if(c=='+')return (a+b)%10; return (a*b)%10;&#125;void Ins(node t)&#123; Q.insert(t); set&lt;node&gt;::iterator it=Q.lower_bound(t),pt; pt=it;pt++; if(pt!=Q.end()&amp;&amp;Cross(*it,*pt))Q.insert(Merge(*it,*pt)),Q.erase(*pt),Q.erase(*it); it=Q.lower_bound(t); if(it==Q.end()||!In(t.l,*it))it--; if(it!=Q.begin()) &#123; pt=it;pt--; if(Cross(*pt,*it))Q.insert(Merge(*pt,*it)),Q.erase(*pt),Q.erase(*it); &#125; it=Q.begin();pt=Q.end();pt--; if(it==pt)return; if(it-&gt;l==0&amp;&amp;pt-&gt;r==n-1)Q.insert(Merge(*pt,*it)),Q.erase(*it),Q.erase(*pt);&#125;void Del(int x)&#123; set&lt;node&gt;::iterator it=Q.lower_bound((node)&#123;x,x&#125;); if(it==Q.end())it--; if(!In(x,*it))it==Q.begin()?it=--Q.end():it=--it; node p=*it;Q.erase(*it); if(p.l&lt;=p.r) &#123; if(x!=p.l)Ins((node)&#123;p.l,x-1&#125;); if(x!=p.r)Ins((node)&#123;x+1,p.r&#125;); &#125; else &#123; if(x!=p.l)Ins((node)&#123;p.l,(x-1+n)%n&#125;); if(x!=p.r)Ins((node)&#123;(x+1)%n,p.r&#125;); &#125;&#125;set&lt;node&gt;::iterator Nex(set&lt;node&gt;::iterator a)&#123; a++;if(a!=Q.end())return a; else return Q.begin();&#125;set&lt;node&gt;::iterator Pre(set&lt;node&gt;::iterator a)&#123; if(a!=Q.begin())return --a; return --Q.end();&#125;int Gans(int x)&#123; if(!Q.size())return -1; int op=x+(n&gt;&gt;1),ans=0;op%=n; set&lt;node&gt;::iterator it=Q.lower_bound((node)&#123;op,op&#125;),pt; ans=max(ans,dis(x,*it)); pt=Nex(it);ans=max(ans,dis(x,*pt)); pt=Nex(pt);ans=max(ans,dis(x,*pt)); pt=Nex(pt);ans=max(ans,dis(x,*pt)); pt=Nex(pt);ans=max(ans,dis(x,*pt)); pt=Pre(it);ans=max(ans,dis(x,*pt)); pt=Pre(pt);ans=max(ans,dis(x,*pt)); pt=Pre(pt);ans=max(ans,dis(x,*pt)); pt=Pre(pt);ans=max(ans,dis(x,*pt)); return ans;&#125;int main()&#123; int i,j,k,x,y,New,ans; _R(n);_R(m); for(i=0;i&lt;n;i++)_R(A[i]),_S(C[i]); for(i=0;i&lt;n;i++)B[i]=f(A[i],A[(i-1+n)%n],C[i]); for(i=0;i&lt;n;i=j+1) &#123; j=i; if(B[i]!=0)continue; while(j+1&lt;n&amp;&amp;B[j+1]==0)j++; Ins((node)&#123;i,j&#125;); &#125; for(i=1;i&lt;=m;i++) &#123; _R(k); if(k==1) &#123; _R(x);_R(A[x]);_S(C[x]); New=f(A[x],A[(x-1+n)%n],C[x]); if(New&amp;&amp;!B[x])Del(x); else if(!New&amp;&amp;B[x])Ins((node)&#123;x,x&#125;); B[x]=New; New=f(A[x],A[(x+1)%n],C[(x+1)%n]); if(New&amp;&amp;!B[(x+1)%n])Del((x+1)%n); else if(!New&amp;&amp;B[(x+1)%n])Ins((node)&#123;(x+1)%n,(x+1)%n&#125;); B[(x+1)%n]=New; &#125; else &#123; _R(x); if(B[x]&amp;&amp;!A[x]) &#123; Ins((node)&#123;x,x&#125;); ans=Gans(x); Del(x); &#125; else if(!B[x]&amp;&amp;A[x]) &#123; Del(x); ans=Gans(x); Ins((node)&#123;x,x&#125;); &#125; else ans=Gans(x); printf("%d\n",ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI 2016 地图（仙人掌+DFS序+莫队+分块）]]></title>
    <url>%2F2018%2F03%2F24%2FHAOI-2016-%E5%9C%B0%E5%9B%BE%EF%BC%88%E4%BB%99%E4%BA%BA%E6%8E%8C-DFS%E5%BA%8F-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[HAOI2016]地图问题描述 一天rin来到了一个遥远的都市。这个都市有n个建筑，编号从1到n，其中市中心编号为1，这个都市有m条双向通行的街道，每条街道连接着两个建筑，其中某些街道首尾相连连接成了一个环。rin通过长时间的走访，已经清楚了这个都市的两个特点： 1.从市中心出发可以到达所有的建筑物。 2.任意一条街道最多存在与一个简单环中。 令rin心花怒放的是，每个建筑物都会有拉面售卖。拉面有很多不同的种类，但对于rin而言只有油腻程度的不同，因此我们把油腻程度相同的拉面看做同一种拉面。由于不同建筑物的拉面的油腻程度可能不同，我们用一个正整数来表示拉面的油腻程度。要知道，拉面可是rin的最爱，但是现在到了下班高峰期，都市的交通变得非常的堵塞。 rin只能通过没有被堵死的街道通行，去品尝所在建筑物的拉面。 现在rin想知道，如果她正在编号为x的建筑物，那么在从市中心到x的所有简单路径经过的街道都被堵死的情况下，rin可以品尝到的拉面中（注意没有出现的拉面是不能算在里面的）： 1.油腻程度≤ y且品尝次数为奇数次的拉面有多少种？ 2.油腻程度≤ y且品尝次数为偶数次的拉面有多少种？ 输入格式 第一行两个正整数n,m，含义如题所示第二行一共N个正整数，第i个数Ai表示第i个建筑物出售的拉面的油腻程度。 接下来M行，每行两个正整数x,y，表示在建筑物x,y之间有一条双向通行的街道。数据保证1&lt;=x&lt;y&lt;=N 接下来一行一个正整数Q，表示询问个数。 接下来Q行每行三个非负整数ty,x,y,x表示询问的建筑物编号，y表示油腻程度的限制，ty=0时表示询问偶数，ty=1表示询问奇数。 N&lt;=100000,M&lt;=150000,Q&lt;=100000,Ai&lt;=10^6 输出格式 一共Q行，对于每个询问输出一个答案。 这题给了个仙人掌，但观察后发现，由于是有根的，因此可以直接利用圆方树的姿势处理，但不需要添加方点，直接跑Tarjan后转化成一个树上对子树的询问。 直接维护比较麻烦，我们考虑利用DFS序转化成序列上的问题，然后发现每次询问相当于问一个区间，因此考虑用莫队维护cnt值，同时用一个数据结构来维护每个权值出现了奇数次和偶数次的前缀和，由于莫队的原因，可以用修改$O(1)$，询问$O(\sqrt{n})$的分块前缀和来解决。 总时间复杂度仍然是$O(n\sqrt{n})$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 1000005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,m,q,A[N],MAX,Hash[N],Ans[N],H;int TOT,LA[N],NE[N],ST[N],EN[N];int tot,la[N],ne[N],en[N];int dfn[N],low[N],VT,fa[N],id[N];int In[N],Out[N],C[N],Cnt[N],VTT;struct node&#123;int ty,l,r,k,id;&#125;K[N];bool cmp(node a,node b)&#123; if(id[a.l]==id[b.l])return a.r&lt;b.r; return id[a.l]&lt;id[b.l];&#125;namespace BLK&#123; int lp[N],rp[N],id[N],sum[N][2],cnt[N][2],S; void Build() &#123; int i,j;S=sqrt(H); for(i=1;i&lt;=H;i++) &#123; id[i]=i/S+1; if(!lp[id[i]])lp[id[i]]=i; rp[id[i]]=i; &#125; &#125; void Ins(int x,int d,int ty) &#123; cnt[x][ty]+=d; sum[id[x]][ty]+=d; &#125; int GS(int x,int ty) &#123; int i,ans=0; for(i=1;i&lt;id[x];i++)ans+=sum[i][ty]; for(i=lp[id[x]];i&lt;=x;i++)ans+=cnt[i][ty]; return ans; &#125;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void add(int x,int y)&#123; tot++; en[tot]=y; ne[tot]=la[x]; la[x]=tot;&#125;void Getcir(int x,int y)&#123; do&#123; add(x,y); add(y,x); y=fa[y]; &#125;while(y!=x);&#125;void Tarjan(int x)&#123; int i,y; dfn[x]=low[x]=++VT; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==fa[x])continue; if(!dfn[y]) &#123; fa[y]=x;Tarjan(y); low[x]=min(low[x],low[y]); &#125; else low[x]=min(low[x],dfn[y]); if(low[y]&gt;dfn[x])add(x,y),add(y,x); &#125; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(dfn[y]&lt;dfn[x])continue; if(fa[y]!=x)Getcir(x,y); &#125;&#125;void DFS(int x,int f)&#123; int i,y; In[x]=++VTT; C[VTT]=A[x]; for(i=la[x];i;i=ne[i]) &#123; y=en[i];if(In[y])continue; DFS(y,x); &#125; Out[x]=VTT;&#125;void UD(int k,int ty)&#123; k=C[k]; if(Cnt[k])BLK::Ins(k,-1,Cnt[k]&amp;1); Cnt[k]+=ty; if(Cnt[k])BLK::Ins(k,1,Cnt[k]&amp;1);&#125;int main_main()&#123; int i,j,k,x,y,z,ty,S,L,R; _R(n);_R(m);S=sqrt(n); for(i=1;i&lt;=n;i++)_R(A[i]),id[i]=i/S; for(i=1;i&lt;=m;i++) &#123; _R(x);_R(y); ADD(x,y);ADD(y,x); &#125; Tarjan(1);DFS(1,0); for(i=1;i&lt;=n;i++)Hash[i]=C[i]; sort(Hash+1,Hash+n+1); H=unique(Hash+1,Hash+n+1)-Hash-1; for(i=1;i&lt;=n;i++)C[i]=lower_bound(Hash+1,Hash+H+1,C[i])-Hash; _R(q); for(i=1;i&lt;=q;i++) &#123; _R(ty);_R(x);_R(y); z=lower_bound(Hash+1,Hash+H+1,y)-Hash; if(Hash[z]!=y)z--; K[i]=(node)&#123;ty,In[x],Out[x],z,i&#125;; &#125; sort(K+1,K+q+1,cmp); L=1;R=0;BLK::Build(); for(i=1;i&lt;=q;i++) &#123; while(R&lt;K[i].r)UD(++R,1); while(R&gt;K[i].r)UD(R--,-1); while(L&lt;K[i].l)UD(L++,-1); while(L&gt;K[i].l)UD(--L,1); Ans[K[i].id]=BLK::GS(K[i].k,K[i].ty); &#125; for(i=1;i&lt;=q;i++)printf("%d\n",Ans[i]);&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>图论</category>
        <category>分治法</category>
        <category>杂学</category>
        <category>分块</category>
        <category>仙人掌</category>
        <category>莫队</category>
        <category>DFS序</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>分块</tag>
        <tag>莫队</tag>
        <tag>仙人掌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TJOI 2015 旅游（树链剖分+线段树）]]></title>
    <url>%2F2018%2F03%2F24%2FTJOI-2015-%E6%97%85%E6%B8%B8%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[TJOI2015]旅游问题描述 为了提高智商，ZJY准备去往一个新世界去旅游。这个世界的城市布局像一棵树。每两座城市之间只有一条路径可以互达。每座城市都有一种宝石，有一定的价格。ZJY为了赚取最高利益，她会选择从A城市买入再转手卖到B城市。由于ZJY买宝石时经常卖萌，因而凡是ZJY路过的城市，这座城市的宝石价格会上涨。让我们来算算ZJY旅游完之后能够赚取的最大利润。（如a城市宝石价格为v，则ZJY出售价格也为v） 输入格式 第一行输入一个正整数N，表示城市个数。 接下来一行输入N个正整数表示每座城市宝石的最初价格p，每个宝石的初始价格不超过100。 第三行开始连续输入N-1行，每行有两个数字x和y。表示x城市和y城市有一条路径。城市编号从1开始。 下一行输入一个整数Q，表示询问次数。 接下来Q行，每行输入三个正整数a,b,v，表示ZJY从a旅游到b，城市宝石上涨v。 即是询问a—&gt;b(有方向)间路径上的max(Price[j]−Price[i])) 且j到a的距离比i到a大 。然后把这条路径上所有点的点权+v。 1≤ N≤50000， 1≤Q ≤50000 输出格式 对于每次询问，输出ZJY可能获得的最大利润，如果亏本则输出0。 样例输入 3 1 2 3 1 2 2 3 2 1 2 100 1 3 100 样例输出 1 1 显然的树链剖分，主要处理询问。 考虑用线段树维护，线段树上记录$Max，Min，Lans，Rans$，其中$Lans=max(Max[ls]-Min[rs],Lans[ls],Lans[rs])$。 $Rans$同理，然后每次查询可以用一个结构体来保存结果，将询问拆到线段树整区间上再向上合并即可。 最后求结果的时候，先找出$a,b$的$lca$，然后答案就是$a\rightarrow lca$的$Lans$，$lca\rightarrow b$的$Rans$，$lca\rightarrow b$的$Max$减去$a\rightarrow lca$的$Min$三者的最大值。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 50005#define M 200005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,q,A[N],B[N];int TOT,LA[N],EN[N&lt;&lt;1],NE[N&lt;&lt;1];int fa[N],dep[N],top[N],id[N],son[N],si[N],VT;struct node&#123; int Max,Min,Ans; node(int a=0,int b=1e9,int c=0) &#123;Max=a;Min=b;Ans=c;&#125;&#125;;node Merge(node a,node b)&#123; node c; c.Max=max(a.Max,b.Max); c.Min=min(a.Min,b.Min); c.Ans=max(a.Max-b.Min,max(a.Ans,b.Ans)); return c;&#125;namespace Seg&#123; int tot,ls[M],rs[M],Max[M],Min[M],Lmax[M],Rmax[M],lazy[M]; void MT(int p) &#123; int l=ls[p],r=rs[p]; Max[p]=max(Max[l],Max[r]); Min[p]=min(Min[l],Min[r]); Lmax[p]=max(Max[l]-Min[r],max(Lmax[l],Lmax[r])); Rmax[p]=max(Max[r]-Min[l],max(Rmax[l],Rmax[r])); &#125; void PD(int p) &#123; Max[ls[p]]+=lazy[p]; Max[rs[p]]+=lazy[p]; Min[ls[p]]+=lazy[p]; Min[rs[p]]+=lazy[p]; lazy[ls[p]]+=lazy[p]; lazy[rs[p]]+=lazy[p]; lazy[p]=0; &#125; int BT(int x,int y) &#123; int p=++tot; if(x==y)return Max[p]=Min[p]=B[x],p; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); return MT(p),p; &#125; void ADD(int p,int l,int r,int x,int y,int d) &#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;Max[p]+=d;Min[p]+=d;lazy[p]+=d;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)ADD(ls[p],l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)ADD(rs[p],mid+1,r,x,y,d); MT(p); &#125; node Glmax(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)return node(Max[p],Min[p],Lmax[p]); int mid=l+r&gt;&gt;1;node Lp,Rp; if(x&lt;=mid&amp;&amp;y&gt;=l)Lp=Glmax(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)Rp=Glmax(rs[p],mid+1,r,x,y); return Merge(Lp,Rp); &#125; node Grmax(int p,int l,int r,int x,int y) &#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)return node(Max[p],Min[p],Rmax[p]); int mid=l+r&gt;&gt;1;node Lp,Rp; if(x&lt;=mid&amp;&amp;y&gt;=l)Lp=Grmax(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)Rp=Grmax(rs[p],mid+1,r,x,y); return Merge(Rp,Lp); &#125;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void FHE(int x,int f)&#123; int i,y; dep[x]=dep[f]+1; fa[x]=f; si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; FHE(y,x);si[x]+=si[y]; if(si[y]&gt;si[son[x]])son[x]=y; &#125;&#125;void CHE(int x,int f)&#123; int i,y; top[x]=f; id[x]=++VT; B[VT]=A[x]; if(son[x])CHE(son[x],f); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==fa[x])continue; if(y!=son[x])CHE(y,y); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])swap(x,y); return y;&#125;void MD(int x,int y,int d)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); Seg::ADD(1,1,n,id[top[x]],id[x],d); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])swap(x,y); Seg::ADD(1,1,n,id[y],id[x],d);&#125;int Gans(int x,int y)&#123; int lca=LCA(x,y);node L,R; while(top[x]!=top[lca]) &#123; L=Merge(Seg::Glmax(1,1,n,id[top[x]],id[x]),L); x=fa[top[x]]; &#125; L=Merge(Seg::Glmax(1,1,n,id[lca],id[x]),L); while(top[y]!=top[lca]) &#123; R=Merge(R,Seg::Grmax(1,1,n,id[top[y]],id[y])); y=fa[top[y]]; &#125; R=Merge(R,Seg::Grmax(1,1,n,id[lca],id[y])); return max(R.Max-L.Min,max(L.Ans,R.Ans));&#125;int main_main()&#123; int i,j,k,x,y,z; _R(n); for(i=1;i&lt;=n;i++)_R(A[i]); for(i=1;i&lt;n;i++) &#123; _R(x);_R(y); ADD(x,y);ADD(y,x); &#125; FHE(1,0);CHE(1,1);Seg::BT(1,n); _R(q); for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y);_R(z); printf("%d\n",Gans(x,y)); MD(x,y,z); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JLOI 2015 有意义的字符串（矩阵乘法）]]></title>
    <url>%2F2018%2F03%2F20%2FJLOI-2015-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[JLOI2015 DAY1]有意义的字符串问题描述 B 君有两个好朋友，他们叫宁宁和冉冉。有一天，冉冉遇到了一个有趣的题目：输入 $b, d, n$，求 $$\bigg [ \Big ( \frac{b+ \sqrt{d}}{2} \Big )^n \bigg ]\mod 7528443412579576937$$ 输入格式 一行三个整数b,d,n。 输出格式 一行一个数表示模7528443412579576937 之后的结果。 样例输入 1 1 5 9 样例输出 1 76 样例输入 2 11 125 6715504 样例输出 2 1499928102740042526 提示 其中 $0&lt;b^2 \leq d &lt;(b+1)^2 \leq 10^{18}, \ n \leq 10^{18}$，并且 $b \mod 2=1, \ d \mod 4=1$ 这个题直接上精度是吃不住的，需要观察出一个优美的式子，将原式写成$$\bigg[\bigg( \frac{b+\sqrt{d}}{2} \bigg)^n+\bigg(\frac{b-\sqrt{d}}{2}\bigg)^n\bigg]-\bigg(\frac{b-\sqrt{d}}{2}\bigg)^n$$这个式子我们发现最后一项由于题目所给的$b^2&lt;=d&lt;(b+1)^2$，那么只有当$b^2=d$时，它为0，其他情况下都是小数，只需要考虑$n$的奇偶就行了。因此我们主要看前面的部分。因此单独将他提出来$$\bigg(\frac{b+\sqrt{d}}{2}\bigg)^n+\bigg(\frac{b-\sqrt{d}}{2}\bigg)^n=\frac{1}{2^n}\bigg((b+\sqrt{d})^n+(b-\sqrt{d})^n\bigg)$$考虑括号内的二项式展开，当$\sqrt{d}$的次数为奇数时，这些项恰好两两抵消全部没了，因此剩下的项全都是$\sqrt{d}$的次数为偶数的项，我们猜测它一定是一个整数，考虑用数学归纳法证明，令$\alpha=\frac{b+\sqrt{d}}{2},\beta=\frac{b-\sqrt{d}}{2}$ 当$n=0,1,2$时显然成立。 假设$n=k$时$\alpha^k+\beta^k$是整数，考虑$$(\alpha^k+\beta^k)(\alpha+\beta)=\alpha^{k+1}+\beta^{k+1}+\alpha\beta^k+\alpha^k\beta=\alpha^{k+1}+\beta^{k+1}+\frac{b-d^2}{4}\bigg(\alpha^{k-1}+\beta^{k-1}\bigg)$$由于$\alpha^k+\beta^k$与$\alpha+\beta$，$\alpha^{k-1}+\beta^{k-1}$都是整数，因此要证明$\alpha^{k+1}+\beta^{k+1}$是整数，只需要$\frac{b-d^2}{4}$是整数。 而考虑到题给条件，$b\ mod\ 2=1,d\ mod\ 4=1$，容易得到$b^2\ mod\ 4=1$，因此$\frac{b-d^2}{4}$是整数，故命题得证。 那么我们就可以先算出$\alpha^n+\beta^n$，最后再乘上$\frac{1}{2^n}$即可。 考虑用递推计算，实际上我们只需要算出$(b+\sqrt{d})^n$的整数部分系数再乘2即可 这个矩阵比较好推，由$[b,1]$开始，假设当前系数是$[x,y\sqrt{d}]$，那么再乘上一个$b+\sqrt{d}$后的系数就是$[xb+yd,by\sqrt{d}+x\sqrt{d}]$，因此转移矩阵出来了。 最后在考虑一开始提到的后面的一部分小数造成的影响即可，注意特判$n=0$的情况。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define ull unsigned long longusing namespace std;const ull mod=7528443412579576937LL;ull b,d,n;ll ans;ull A[3][3],Ans[3][3];void add(ull &amp;a,ull b)&#123;a+=b;a-=a&gt;=mod?mod:0;&#125;ull QC(ull a,ull b)&#123; ull o=0; while(b) &#123; if(b&amp;1)add(o,a); b&gt;&gt;=1;add(a,a); &#125; return o;&#125;ull QM(ull a,ull b)&#123; ull o=1; while(b) &#123; if(b&amp;1)o=QC(o,a); b&gt;&gt;=1;a=QC(a,a); &#125; return o;&#125;void C(ull x[3][3],ull y[3][3])&#123; ull z[3][3],i,j,k; memset(z,0,sizeof(z)); for(i=1;i&lt;3;i++) for(j=1;j&lt;3;j++) for(k=1;k&lt;3;k++)add(z[i][j],QC(x[i][k],y[k][j])); memcpy(x,z,sizeof(z));&#125;ull MQM(ull t)&#123; while(t) &#123; if(t&amp;1)C(Ans,A); t&gt;&gt;=1;C(A,A); &#125; return Ans[1][1];&#125;int main()&#123; ull x,y; scanf("%lld%lld%lld",&amp;b,&amp;d,&amp;n); if(n==0)return puts("1"),0; A[1][1]=A[2][2]=b;A[1][2]=1;A[2][1]=d; Ans[1][1]=b;Ans[1][2]=1; x=MQM(n-1);x=QC(x,2);y=QM(mod+1&gt;&gt;1,n); ans=QC(x,y); if(b*b!=d)ans+=(n&amp;1)?0:-1; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI 2016 模式字符串（点分治+哈希）]]></title>
    <url>%2F2018%2F03%2F20%2FSDOI-2016-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB-%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[SDOI2016]模式字符串问题描述给出n个结点的树结构T，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母A到Z,再给出长度为m的模式串s，其中每一位仍然是A到z的大写字母。 Alice希望知道，有多少对结点&lt;u，v&gt;满足T上从u到V的最短路径形成的字符串可以由模式串S重复若干次得到？这里结点对&lt;u，v&gt;是有序的，也就是说&lt;u，v&gt;和&lt;v，u&gt;需要被区分. 所谓模式串的重复，是将若干个模式串S依次相接（不能重叠).例如当S=PLUS的时候，重复两次会得到PLUSPLUS，重复三次会得到PLUSPLUSPLUS,同时要注恿，重复必须是整数次的。例如当S=XYXY时，因为必须重复整数次，所以XYXYXY不能看作是S重复若干次得到的。 输入格式每一个数据有多组测试， 第一行输入一个整数C，表示总的测试个数。 对于每一组测试来说： 第一行输入两个整数，分别表示树T的结点个数n与模式长度m。结点被依次编号为1到n， 之后一行，依次给出了n个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第i个字符对应了第i个结点). 之后n-1行，每行有两个整数u和v表示树上的一条无向边，之后一行给定一个长度为m的由大写字母组成的字符串，为模式串S。 1&lt;=C&lt;=10,3&lt;=N&lt;=10000003&lt;=M&lt;=1000000 输出格式给出C行，对应C组测试。每一行输出一个整数，表示有多少对节点&lt;u,v&gt;满足从u到v的路径形成的字符串恰好是模式串的若干次重复. 样例输入111 4IODSSDSOIOI1 22 33 41 55 66 73 88 96 1010 11SDOI 样例输出5 此题是树上路径问题，显然考虑点分治，那么我们需要判断一条路径是否是给定串的倍数。 考虑用哈希处理，我们将若干个模式串拼起来，得到一个长度大于等于n的串，然后求出这个串的前缀和后缀哈希值，这样我们点分治的时候，只需要从根出发，算算哈希值，就知道长度为$k$的前缀和后缀分别有多少个了，然后算一算就知道有多少符合条件的路径了，注意到长度$k$超过$m$的前缀和后缀直接累加到$k\%m$上就行了。 复杂度$O(n\log n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define ll long long#define ull unsigned long longusing namespace std;char buf[1 &lt;&lt; 20], *p1, *p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R() &#123; int d; char t; while (t=GC,t&lt;'0'||t&gt;'9'); d=t-'0'; while(t=GC,t&gt;='0'&amp;&amp;t&lt;='9')d=(d&lt;&lt;3)+(d&lt;&lt;1)+t-'0'; return d;&#125;inline void _S(char *c) &#123; char *t=c,ch; while(ch=GC,ch==' '||ch=='\n'||ch=='\r'); *t++=ch; while (ch=GC,ch!=' '&amp;&amp;ch!='\n'&amp;&amp;ch!='\r')*t++=ch; *t=0;&#125;const ull p=131;ull Suf[N],Pre[N];ll ans,suf[N],pre[N];char C[N],s[N];int T,n,m,si[N],Min,rt,MX;bool mark[N];int TOT,LA[N],NE[N&lt;&lt;1],EN[N&lt;&lt;1];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Gsi(int x,int f)&#123; int i,y;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y]||y==f)continue; Gsi(y,x);si[x]+=si[y]; &#125;&#125;void Grt(int x,int s,int f)&#123; int i,y,Max=s-si[x]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y]||y==f)continue; Grt(y,s,x);Max=max(Max,si[y]); &#125; if(Max&lt;Min)Min=Max,rt=x;&#125;void Gans(int x,int f,int d,ull Hash)&#123; int i,y;Hash=Hash*p+C[x]; y=m-d%m;y-=y&gt;=m?m:0; if(Hash==Suf[d])ans+=pre[y]; if(Hash==Pre[d])ans+=suf[y]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y]||y==f)continue; Gans(y,x,d+1,Hash); &#125;&#125;void Updata(int x,int f,int d,ull Hash)&#123; int i,y;Hash=Hash*p+C[x]; if(Hash==Suf[d])suf[d%m]++,MX=max(MX,d%m); if(Hash==Pre[d])pre[d%m]++,MX=max(MX,d%m); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y]||y==f)continue; Updata(y,x,d+1,Hash); &#125;&#125;void Cal(int x)&#123; int i,y;ull Hash=C[x];MX=1; if(Hash==Suf[1])suf[1]++; if(Hash==Pre[1])pre[1]++; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y])continue; Gans(y,x,1,0); Updata(y,x,2,Hash); &#125; fill(suf,suf+MX+1,0); fill(pre,pre+MX+1,0);&#125;void DC(int x)&#123; int i,y;mark[x]=1;Cal(x); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y])continue; Min=1e9;Gsi(y,x);Grt(y,si[y],x); if(si[y]&gt;=m)DC(rt); &#125;&#125;int main_main()&#123; int i,j,k,x,y;ull z; T=_R(); while(T--) &#123; n=_R();m=_R(); TOT=0;ans=0; fill(LA,LA+n+1,0); fill(mark,mark+n+1,0); _S(C+1); for(i=1;i&lt;n;i++) &#123; x=_R();y=_R(); ADD(x,y);ADD(y,x); &#125; _S(s+1); for(i=1,j=1,z=1;i&lt;=n;i++,z*=p,j++,j-=j&gt;m?m:0)Pre[i]=Pre[i-1]+z*s[j]; for(i=1,j=m,z=1;i&lt;=n;i++,z*=p,j--,j+=j&lt;1?m:0)Suf[i]=Suf[i-1]+z*s[j]; Min=1e9;Gsi(1,0);Grt(1,si[1],0);DC(rt); printf("%lld\n",ans); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>分治法</category>
        <category>点分治</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2015 接水果（整体二分+DFS序+树状数组）]]></title>
    <url>%2F2018%2F03%2F20%2FHNOI-2015-%E6%8E%A5%E6%B0%B4%E6%9E%9C%EF%BC%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86-DFS%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[HNOI2015]接水果问题描述 风见幽香非常喜欢玩一个叫做 osu!的游戏，其中她最喜欢玩的模式就是接水果。由于她已经DT FC 了The big black, 她觉得这个游戏太简单了，于是发明了一个更加难的版本。首先有一个地图，是一棵由 n 个顶点、n-1 条边组成的树（例如图 1给出的树包含 8 个顶点、7 条边）。这颗树上有 P 个盘子，每个盘子实际上是一条路径（例如图 1 中顶点 6 到顶点 8 的路径），并且每个盘子还有一个权值。第 i 个盘子就是顶点$a_i$到顶点$b_i$的路径(由于是树，所以从$a_i$到$b_i$的路径是唯一的)，权值为$c_i$。接下来依次会有Q个水果掉下来，每个水果本质上也是一条路径，第i 个水果是从顶点 $u_i$ 到顶点$v_i $的路径。幽香每次需要选择一个盘子去接当前的水果：一个盘子能接住一个水果，当且仅当盘子的路径是水果的路径的子路径（例如图1中从 3到7 的路径是从1到8的路径的子路径）。这里规定:从a 到b的路径与从b到 a的路径是同一条路径。当然为了提高难度，对于第 i 个水果，你需要选择能接住它的所有盘子中，权值第 $k_i$ 小的那个盘子，每个盘子可重复使用（没有使用次数的上限：一个盘子接完一个水果后，后面还可继续接其他水果，只要它是水果路径的子路径）。幽香认为这个游戏很难，你能轻松解决给她看吗？ 输入格式 第一行三个数 n和P 和Q，表示树的大小和盘子的个数和水果的个数。 接下来n-1 行，每行两个数 a、b，表示树上的a和b 之间有一条边。树中顶点按1到 n标号。 接下来 P 行，每行三个数 a、b、c，表示路径为 a 到 b、权值为 c 的盘子，其中$0≤c≤10^9$，a不等于b。 接下来Q行，每行三个数 u、v、k，表示路径为 u到 v的水果，其中 u不等于v，你需要选择第 k小的盘子，第k 小一定存在。 输出格式 对于每个果子，输出一行表示选择的盘子的权值。 样例输入 10 10 10 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 3 2 217394434 10 7 13022269 6 7 283254485 6 8 333042360 4 6 442139372 8 3 225045590 10 4 922205209 10 8 808296330 9 2 486331361 4 9 551176338 1 8 5 3 8 3 3 8 4 1 8 3 4 8 1 2 3 1 2 3 1 2 3 1 2 4 1 1 4 1 样例输出 442139372 333042360 442139372 283254485 283254485 217394434 217394434 217394434 217394434 217394434 提示 对于所有数据，N,P,Q≤40000 本题要求一条路径的子路径中权值第K小的路径，首先考虑如何判定子路径，容易看出如果一条路径的点集是${p_1,p_2…p_n}$那么，他的一条子路径的两端点都在这个集合中，那么可以将一条子路径$x\rightarrow y$，抽象成一个点$(x,y)$，但是这些点是离散的，因此不好处理，可以利用轻重链剖分，这样的话$DFS$序最多有$\log n$个连续区间，就可以将一条路径的子路径范围抽象成$\log^2$个矩形，这样就只需要求若干矩形中权值第$k$小的点了。 但这样显然不优秀，我们考虑换一个方向，考虑一条路径的父路径，沿用刚才的思路，我们发现问题变得异常简单，因为我们考虑一条路径$x\rightarrow y$，如果$LCA(x,y)\neq x\&amp;\&amp; LCA(x,y)\neq y$，那么它的一条父路径的两个端点必然是$x$和$y$的子树中的两个点，而且由于子树的DFS序是连续的，因此我们就可以将这样的路径抽象成一个矩形，而对于另一种情况，显然一条父路径必然是一个点在子树中，另一个点不在子树中，这就可以抽象成两个矩形。 因此我们可以将盘子看成矩形，将水果看成点，那么问题变成了求二维平面中覆盖一个点的所有矩形中，权值第K小的矩形。这个问题可以用扫描线+线段树套主席树来解决，但他非常的麻烦。 但是求区间第K小问题也是整体二分的经典模型，因此我们考虑扫描线+整体二分+树状数组，二分一个权值，然后将所有权值小于等于$mid$的矩形取出来做扫描线，求一下每个点被覆盖的次数，次数小于$k$的甩到$[mid+1,r]$中去，大于等于$k$的甩到$[l,mid]$中去，这个只需要一个树状差分数组来处理就行了。 复杂度$O(n\log^2 n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 40005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;struct nodd&#123;int x[2],y[2],v;&#125;;struct node&#123;int x,y,k,id;&#125;;struct thh&#123;int pos,l,r,v;&#125;;bool operator&lt;(thh a,thh b)&#123;return a.pos&lt;b.pos;&#125;int n,p,q,In[N],Out[N],VT,dep[N],Ans[N],S=17;int fa[N][20],cnt[N],C[N];int TOT,LA[N],NE[N&lt;&lt;1],EN[N&lt;&lt;1];void MD(int x,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))C[i]+=d;&#125;int GS(int x)&#123; int i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=C[i]; return sum;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int f)&#123; int i,y; dep[x]=dep[f]+1; In[x]=++VT; fa[x][0]=f; for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; DFS(y,x); &#125; Out[x]=VT;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=fa[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int Find(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]-1; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=fa[x][i]; return x;&#125;void DC(int l,int r,vector&lt;nodd&gt;P,vector&lt;node&gt;Q)&#123; if(!Q.size())return; int i,j,k,x,y,mid=l+r&gt;&gt;1; if(l==r) &#123; for(i=0;i&lt;Q.size();i++)Ans[Q[i].id]=l; return; &#125; vector&lt;nodd&gt;P1,P2; vector&lt;node&gt;Q1,Q2; vector&lt;thh&gt;T1,T2; for(i=0;i&lt;P.size();i++) &#123; if(P[i].v&lt;=mid) &#123; T1.push_back((thh)&#123;P[i].x[0],P[i].y[0],P[i].y[1],1&#125;); T1.push_back((thh)&#123;P[i].x[1]+1,P[i].y[0],P[i].y[1],-1&#125;); P1.push_back(P[i]); &#125; else P2.push_back(P[i]); &#125; for(i=0;i&lt;Q.size();i++) &#123; cnt[Q[i].id]=0; T2.push_back((thh)&#123;Q[i].x,Q[i].y,0,Q[i].id&#125;); T2.push_back((thh)&#123;Q[i].y,Q[i].x,0,Q[i].id&#125;); &#125; sort(T1.begin(),T1.end()); sort(T2.begin(),T2.end()); for(i=j=0;i&lt;T2.size();i++) &#123; while(j&lt;T1.size()&amp;&amp;T1[j].pos&lt;=T2[i].pos) &#123; MD(T1[j].l,T1[j].v); MD(T1[j].r+1,-T1[j].v); j++; &#125; cnt[T2[i].v]+=GS(T2[i].l); &#125; while(j&lt;T1.size()) &#123; MD(T1[j].l,T1[j].v); MD(T1[j].r+1,-T1[j].v); j++; &#125; for(i=0;i&lt;Q.size();i++) &#123; if(cnt[Q[i].id]&gt;=Q[i].k)Q1.push_back(Q[i]); else Q[i].k-=cnt[Q[i].id],Q2.push_back(Q[i]); &#125; DC(l,mid,P1,Q1);DC(mid+1,r,P2,Q2);&#125;int main_main()&#123; vector&lt;nodd&gt;P; vector&lt;node&gt;Q; int i,j,k,x,y,z; _R(n);_R(p);_R(q); for(i=1;i&lt;n;i++) &#123; _R(x);_R(y); ADD(x,y);ADD(y,x); &#125; DFS(1,0); for(i=1;i&lt;=p;i++) &#123; _R(x);_R(y);_R(z); if(dep[x]&lt;dep[y])swap(x,y); int lca=LCA(x,y); if(lca!=y)P.push_back((nodd)&#123;&#123;In[x],Out[x]&#125;,&#123;In[y],Out[y]&#125;,z&#125;); else &#123; k=Find(x,y); P.push_back((nodd)&#123;&#123;In[x],Out[x]&#125;,&#123;1,In[k]-1&#125;,z&#125;); if(Out[k]&lt;n)P.push_back((nodd)&#123;&#123;In[x],Out[x]&#125;,&#123;Out[k]+1,n&#125;,z&#125;); &#125; &#125; for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y);_R(z); Q.push_back((node)&#123;In[x],In[y],z,i&#125;); &#125; DC(0,1e9,P,Q); for(i=1;i&lt;=q;i++)printf("%d\n",Ans[i]);&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>分治法</category>
        <category>杂学</category>
        <category>整体二分</category>
        <category>DFS序</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>主席树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI 2016 美味（主席树+贪心）]]></title>
    <url>%2F2018%2F03%2F20%2FSCOI-2016-%E7%BE%8E%E5%91%B3%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%2B%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[SCOI2016]美味问题描述 一家餐厅有 n 道菜，编号 1…n ，大家对第 i 道菜的评价值为$ a_i(1≤i≤n)$。有 m 位顾客，第 i 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$ 。因此，第 i 位顾客认为第 j 道菜的美味度为 $b_i\ XOR\ (a_j+x_i)$，XOR 表示异或运算。第 i 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。 输入格式 第1行，两个整数，n，m，表示菜品数和顾客数。 第2行，n个整数，$a_1，a_2，…，a_n，$表示每道菜的评价值。 第3至m+2行，每行4个整数，b，x，l，r，表示该位顾客的期望值，偏好值，和可以选择菜品区间。 输出格式 输出m 行，每行一个整数表示该位顾客选择的最美味的菜的美味值。 样例输入 4 4 1 2 3 4 1 4 1 4 2 3 2 3 3 2 3 3 4 1 2 4 样例输出 9 7 6 7 提示 $1≤n≤2×10^5,$ $0≤a_i,b_i,x_i&lt;10^5,$ $1≤l_i≤r_i≤n(1≤i≤m),$ $1≤m≤10^5$ 令$Ans=b_i\ XOR\ (a_j+x_i)$，那么$Ans\ XOR\ b_i=a_j+x_i$，我们考虑按照二进制位贪心，那么如果当前讨论到从高到低的第$k$位，考虑$Ans$这一位能否取1，那么由于第$k$位以前的二进制位已经确定，我们令$Ans$的前$k$位和$b$的前$k$位异或的结果为$tmp$，其余未确定的位都取0，如果$b$的二进制第$k$位为$1$，那么$Ans$的第$k$位要为1，就有$Ans\ XOR\ b$的第$k$位要为0，只需要存在一个$a_j+x_i$在$[tmp,tmp|((1&lt;&lt;(Max-k))-1)]$之间就行了，$tmp|((1&lt;&lt;(Max-k))-1)$表示未确定的位（除第$k$位）均取1,这个查询可以用主席树来搞。 如果$b$的二进制第$k$位为0，那么$Ans\ XOR\ b$的第$k$位为1，同样只需要用主席树查找一下就行了。具体可以看代码。核心就是按位贪心看能否取到。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005#define M 10000005using namespace std;int n,m,A[N],T;int tot,ls[M],rs[M],v[M],rt[N];int CP(int p)&#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; v[o]=v[p]; return o;&#125;int ADD(int p,int l,int r,int k)&#123; int o=CP(p);v[o]++; if(l==r)return o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k); else rs[o]=ADD(rs[o],mid+1,r,k); return o;&#125;int GS(int lp,int rp,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)return v[lp]-v[rp]; int mid=l+r&gt;&gt;1,sum=0; if(x&lt;=mid&amp;&amp;y&gt;=l)sum+=GS(ls[lp],ls[rp],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)sum+=GS(rs[lp],rs[rp],mid+1,r,x,y); return sum;&#125;int main()&#123; int i,j,k,x,y,a,b,l,r,Ans,tmp,L,R; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),T=max(T,A[i]); for(i=1;i&lt;=n;i++)rt[i]=ADD(rt[i-1],0,T,A[i]); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;b,&amp;x,&amp;l,&amp;r); for(j=20,Ans=0;j&gt;=0;j--) &#123; if(b&gt;&gt;j&amp;1) &#123; if(!GS(rt[r],rt[l-1],0,T,Ans-x,Ans+(1&lt;&lt;j)-1-x))Ans|=1&lt;&lt;j; &#125; else &#123; Ans|=(1&lt;&lt;j); if(!GS(rt[r],rt[l-1],0,T,Ans-x,Ans+(1&lt;&lt;j)-1-x))Ans^=1&lt;&lt;j; &#125; &#125; printf("%d\n",Ans^b); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>贪心</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 树（LCA+DFS序+主席树）]]></title>
    <url>%2F2018%2F03%2F20%2FHNOI-2016-%E6%A0%91%EF%BC%88LCA%2BDFS%E5%BA%8F%2B%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day1]树问题描述 小A想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小A只有一棵结点数为N的树，结点的编号为1,2,…,N，其中结点1为根；我们称这颗树为模板树。小A决定通过这棵模板树来构建一颗大树。构建过程如下：（1）将模板树复制为初始的大树。（2）以下(2.1)(2.2)(2.3)步循环执行M次（2.1）选择两个数字a,b，其中1&lt;=a&lt;=N，1&lt;=b&lt;=当前大树的结点数。（2.2）将模板树中以结点a为根的子树复制一遍，挂到大树中结点b的下方(也就是说，模板树中的结点a为根的子树复制到大树中后，将成为大树中结点b的子树)。（2.3）将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行2.2步之前大树有L个结点，模板树中以a为根的子树共有C个结点，那么新加入模板树的C个结点在大树中的编号将是L+1,L+2,…,L+C；大树中这C个结点编号的大小顺序和模板树中对应的C个结点的大小顺序是一致的。下面给出一个实例。假设模板树如下图： 根据第(1)步，初始的大树与模板树是相同的。在(2.1)步，假设选择了a=4，b=3。运行(2.2)和(2.3)后，得到新的大树如下图所示 现在他想问你，树中一些结点对的距离是多少。 输入格式 第一行三个整数：N,M,Q，以空格隔开，N表示模板树结点数，M表示第(2)中的循环操作的次数，Q 表示询问数量。接下来N-1行，每行两个整数 fr,to，表示模板树中的一条树边。再接下来M行，每行两个整数x,to，表示将模板树中 x 为根的子树复制到大树中成为结点to的子树的一次操作。再接下来Q行，每行两个整数fr,to，表示询问大树中结点 fr和 to之间的距离是多少。N,M,Q&lt;=100000 输出格式 输出Q行，每行一个整数，第 i行是第 i个询问的答案。 样例输入 5 2 3 1 4 1 3 4 2 4 5 4 3 3 2 6 9 1 8 5 3 样例输出 6 3 3 本题容易想到将每次选的树根连接成一颗树，每个点代表一块，然后先在这个树上倍增，走到同一块内后再到原树上倍增，想起来比较简单，但实现比较麻烦。 注意到需要通过新树中的编号查找在原树中的位置，由于知道当前块中树根的编号，等价于查询原树的一颗子树中的权值第$k$小，这个可以用DFS序转化成求序列上区间第$k$小，用主席树处理即可。 然后就是一堆细节，分块树上边的权值设成两个根之间的距离，倍增的时候要记下跳到了这一块中哪个节点上。 写起来非常的恶心! 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005#define int long longusing namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;3)+(x&lt;&lt;1)+t-48;&#125;int n,m,q;namespace Seg&#123; int tot,ls[N&lt;&lt;7],rs[N&lt;&lt;7],v[N&lt;&lt;7]; int CP(int p) &#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; v[o]=v[p]; return o; &#125; int ADD(int p,int l,int r,int k) &#123; int o=CP(p);v[o]++; if(l==r)return o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k); else rs[o]=ADD(rs[o],mid+1,r,k); return o; &#125; int GA(int lp,int rp,int l,int r,int k) &#123; if(l==r)return l; int mid=l+r&gt;&gt;1,tmp; tmp=v[ls[rp]]-v[ls[lp]]; if(tmp&gt;=k)return GA(ls[lp],ls[rp],l,mid,k); return GA(rs[lp],rs[rp],mid+1,r,k-tmp); &#125;&#125;namespace Ori&#123; int TOT,LA[N],NE[N&lt;&lt;1],EN[N&lt;&lt;1]; int rt[N],fa[N][20],S=18,dep[N],In[N],Out[N],si[N],VT; void ADD(int x,int y) &#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT; &#125; void DFS(int x,int f) &#123; int i,y; if(f)dep[x]=dep[f]+1; In[x]=++VT; si[x]=1; fa[x][0]=f; rt[VT]=Seg::ADD(rt[VT-1],1,n,x); for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; DFS(y,x);si[x]+=si[y]; &#125; Out[x]=VT; &#125; int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=fa[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125; int DIS(int x,int y) &#123; int lca=LCA(x,y); return dep[x]+dep[y]-(dep[lca]&lt;&lt;1); &#125; int Getid(int x,int k) &#123;return Seg::GA(rt[In[x]-1],rt[Out[x]],1,n,k);&#125; int Getdep(int x,int k) &#123; int p=Getid(x,k); return dep[p]; &#125;&#125;namespace New&#123; int TOT,LA[N],NE[N],EN[N],LE[N]; int rt[N],id[N],tot,All,fa[N]; int dep[N],dis[N],F[N][20],S=18; void ADD(int x,int y,int z) &#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT; &#125; void DFS(int x,int f) &#123; int i,y; F[x][0]=f; dep[x]=dep[f]+1; for(i=1;i&lt;=S;i++)F[x][i]=F[F[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; dis[y]=dis[x]+LE[i];DFS(y,x); &#125; &#125; int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=F[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(F[x][i]!=F[y][i])x=F[x][i],y=F[y][i]; return F[x][0]; &#125; int DIS(int x,int y) &#123; int lca=LCA(x,y); return dis[x]+dis[y]-(dis[lca]&lt;&lt;1); &#125; int Frt(int x) &#123; int f=lower_bound(id+1,id+tot+1,x)-id; return id[f]==x?f:f-1; &#125; void add(int x,int y) &#123; id[++tot]=All+1; fa[tot]=y; rt[tot]=x; All+=Ori::si[x]; int f=Frt(y); int k=Ori::Getdep(rt[f],y-id[f]+1)-Ori::dep[rt[f]]; ADD(f,tot,k+1); &#125; int GA1(int x,int y,int fx,int fy) &#123; int i,j,k,sum=0,t=fx; int px=Ori::Getid(rt[fx],x-id[fx]+1); int py=Ori::Getid(rt[fy],y-id[fy]+1); sum+=Ori::dep[px]-Ori::dep[rt[fx]]; k=dep[fx]-dep[fy]-1; for(i=0;i&lt;=S;i++) if(k&gt;&gt;i&amp;1)fx=F[fx][i]; sum+=DIS(fx,t)+1; x=fa[fx]; px=Ori::Getid(rt[fy],x-id[fy]+1); return sum+Ori::DIS(px,py);; &#125; int GA2(int x,int y,int fx,int fy) &#123; int lca=LCA(fx,fy),sum=0; sum+=Ori::Getdep(rt[fx],x-id[fx]+1)-Ori::dep[rt[fx]]; sum+=Ori::Getdep(rt[fy],y-id[fy]+1)-Ori::dep[rt[fy]]; int i,t=dep[fx]-dep[lca]-1; x=fx;y=fy; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)fx=F[fx][i]; sum+=DIS(x,fx); t=dep[fy]-dep[lca]-1; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)fy=F[fy][i]; sum+=DIS(y,fy); sum+=2;x=fa[fx];y=fa[fy]; int px=Ori::Getid(rt[lca],x-id[lca]+1); int py=Ori::Getid(rt[lca],y-id[lca]+1); return sum+Ori::DIS(px,py); &#125;&#125;int main_main()&#123; int i,j,k,x,y,z,ans; _R(n);_R(m);_R(q); for(i=1;i&lt;n;i++) &#123; _R(x);_R(y); Ori::ADD(x,y);Ori::ADD(y,x); &#125; Ori::DFS(1,0); New::id[New::tot=1]=1; New::All=n;New::rt[1]=1; for(i=1;i&lt;=m;i++) &#123; _R(x);_R(y); New::add(x,y); &#125; New::DFS(1,0); for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y);ans=0; int fx=New::Frt(x); int fy=New::Frt(y); if(fx==fy) &#123; int px=Ori::Getid(New::rt[fx],x-New::id[fx]+1); int py=Ori::Getid(New::rt[fy],y-New::id[fy]+1); ans=Ori::DIS(px,py); &#125; else &#123; int lca=New::LCA(fx,fy); if(lca==fx||lca==fy) &#123; if(New::dep[fx]&lt;New::dep[fy])swap(fx,fy),swap(x,y); ans=New::GA1(x,y,fx,fy); &#125; else ans=New::GA2(x,y,fx,fy); &#125; printf("%lld\n",ans); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>主席树</category>
        <category>杂学</category>
        <category>LCA</category>
        <category>DFS序</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 网络（树链剖分+线段树+堆）]]></title>
    <url>%2F2018%2F03%2F19%2FHNOI-2016-%E7%BD%91%E7%BB%9C%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day1]网络问题描述 一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：1. 在某两个服务器之间出现一条新的数据交互请求；2. 某个数据交互结束请求；3. 某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。 输入格式 第一行两个正整数n,m，分别描述服务器和事件个数。服务器编号是从1开始的，因此n个服务器的编号依次是1,2,3,…,n。接下来n-1行，每行两个正整数u,v，描述一条树边。u和v是服务器的编号。接下来m行，按发生时刻依次描述每一个事件；即第i行（i=1,2,3,…,m）描述时刻i发生的事件。每行的第一个数type描述事件类型，共3种类型：（1）若type=0，之后有三个正整数a,b,v，表示服务器a,b之间出现一条重要度为v的数据交互请求；（2）若type=1，之后有一个正整数t，表示时刻t（也就是第t个发生的事件）出现的数据交互请求结束；（3）若type=2，之后有一个正整数x，表示服务器x在这一时刻出现了故障。对于每个type为2的事件，就是一次询问，即询问“当服务器x发生故障时，未被影响的请求中重要度的最大值是多少？”注意可能有某个服务器自身与自身进行数据交互的情况。$2 ≤ n ≤ 10^5, 1 ≤ m ≤ 2×10^5$，其他的所有输入值不超过$ 10^9$ 输出格式 对于每个type=2的事件，即服务器出现故障的事件，输出一行一个整数，描述未被影响的请求中重要度的最大值。如果此时没有任何请求，或者所有请求均被影响，则输出-1。 样例输入 13 23 1 2 1 3 2 4 2 5 3 6 3 7 4 8 4 9 6 10 6 11 7 12 7 13 2 1 0 8 13 3 0 9 12 5 2 9 2 8 2 2 0 10 12 1 2 2 1 3 2 7 2 1 0 9 5 6 2 4 2 5 1 7 0 9 12 4 0 10 5 7 2 1 2 4 2 12 1 2 2 5 2 3 样例输出 -1 3 5 -1 1 -1 1 1 3 6 7 7 4 6 本题需要维护的是不经过某个点的路径最大值，这是可以维护的，考虑树链剖分，然后每次修改是一条链，那么就只需要更新这条链以外的点就行了。 具体实现时，将这条链上的区间取出来，排序之后在线段树上修改两两区间之间的位置就好了。由于一条路径最多被拆成$\log n$条重链，因此最多只有$\log n$个区间需要修改，复杂度并没有上升。 然后线段树上需要维护每个位置的最大值，并且要支持插入删除操作，因此每个位置上开两个堆，一个记录插入，一个记录删除即可。区间修改的时候$lazy$不需要下放，只用在查询的时候自底向下取每一层$lazy$的最大值就行了。 注意到添加和删除一个数操作的区间一定是相同的，因此不会出现删除到不存在的数的情况。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;#define N 800005using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)int G() &#123; int o=0;char t=GC; while(!isdigit(t)) t=GC; while(isdigit(t)) o=o*10+t-48,t=GC; return o;&#125;struct nodd&#123;int x,y;&#125;;bool operator&lt;(nodd a,nodd b)&#123;return a.y&lt;b.y;&#125;struct node&#123; priority_queue&lt;int&gt;Q[2]; void Ins(int x,int ty)&#123;Q[ty].push(x);&#125; int top() &#123; while(Q[0].size()&amp;&amp;Q[1].size()&amp;&amp;Q[0].top()==Q[1].top())Q[0].pop(),Q[1].pop(); if(Q[0].size())return Q[0].top(); return -1; &#125;&#125;v[N];int n,m,X[N],Y[N],Z[N];int son[N],fa[N],top[N],dep[N],si[N],id[N],VT;int TOT,LA[N],NE[N],EN[N];int tot,ls[N],rs[N];void add(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void FHE(int x,int f)&#123; int i,y; fa[x]=f;dep[x]=dep[f]+1;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; FHE(y,x);si[x]+=si[y]; if(si[y]&gt;=si[son[x]])son[x]=y; &#125;&#125;void CHE(int x,int f)&#123; int i,y; top[x]=f;id[x]=++VT; if(son[x])CHE(son[x],f); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==fa[x])continue; if(y!=son[x])CHE(y,y); &#125;&#125;int BT(int x,int y)&#123; int p=++tot; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; return p;&#125;void ADD(int p,int l,int r,int x,int y,int d,int ty)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)&#123;v[p].Ins(d,ty);return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)ADD(ls[p],l,mid,x,y,d,ty); if(x&lt;=r&amp;&amp;y&gt;mid)ADD(rs[p],mid+1,r,x,y,d,ty);&#125;int GA(int p,int l,int r,int x)&#123; if(l==r)return v[p].top(); int mid=l+r&gt;&gt;1,tmp; tmp=x&lt;=mid?GA(ls[p],l,mid,x):GA(rs[p],mid+1,r,x); return max(tmp,v[p].top());&#125;void MD(int x,int y,int d,int ty)&#123; vector&lt;nodd&gt;S; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); S.push_back((nodd)&#123;id[top[x]],id[x]&#125;);x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])swap(x,y); S.push_back((nodd)&#123;id[y],id[x]&#125;); sort(S.begin(),S.end()); int l=0,r=S.size()-1; if(S[l].x!=1)ADD(1,1,n,1,S[l].x-1,d,ty); if(S[r].x!=n)ADD(1,1,n,S[r].y+1,n,d,ty); for(int i=l;i&lt;r;i++)if(S[i].y&lt;S[i+1].x-1)ADD(1,1,n,S[i].y+1,S[i+1].x-1,d,ty);&#125;int main_main()&#123; int i,j,k,x,y,z; n=G();m=G(); for(i=1;i&lt;n;i++) &#123; x=G();y=G(); add(x,y);add(y,x); &#125; FHE(1,0);CHE(1,1);BT(1,n); for(i=1;i&lt;=m;i++) &#123; k=G(); if(k==0) &#123; x=G();y=G();z=G(); X[i]=x;Y[i]=y;Z[i]=z; MD(x,y,z,0); &#125; else if(k==1) &#123; x=G(); MD(X[x],Y[x],Z[x],1); &#125; else &#123; x=G(); printf("%d\n",GA(1,1,n,id[x])); &#125; &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>堆</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>堆</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 最小公倍数（分块+并查集）]]></title>
    <url>%2F2018%2F03%2F19%2FHNOI-2016-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%88%E5%88%86%E5%9D%97-%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day1]最小公倍数问题描述 给定一张N个顶点M条边的无向图(顶点编号为1,2,…,n)，每条边上带有权值。所有权值都可以分解成$2^a3^b$的形式。现在有q个询问，每次询问给定四个参数u、v、a和b，请你求出是否存在一条顶点u到v之间的路径，使得路径依次经过的边上的权值的最小公倍数为$2^a3^b$。注意：路径可以不是简单路径。下面是一些可能有用的定义：最小公倍数：K个数$a_1,a_2,…,a_k$的最小公倍数是能被每个$a_i$整除的最小正整数。路径：路径$P:P_1,P_2,…,P_k$是顶点序列，满足对于任意$1&lt;=i&lt;k$，节点$P_i$和$P_{i+1}$之间都有边相连。简单路径：如果路径$P:P_1,P_2,…,P_k$中，对于任意$1&lt;=s≠t&lt;=k$都有$P_s≠P_t$，那么称路径为简单路径。 输入格式 第一行包含两个整数N和M，分别代表图的顶点数和边数。接下来M行，每行包含四个整数u、v、a、b代表一条顶点u和v之间、权值为2^a*3^b的边。接下来一行包含一个整数q，代表询问数。接下来q行，每行包含四个整数u、v、a和b，代表一次询问。询问内容请参见问题描述。$1&lt;=n,q&lt;=50000,1&lt;=m&lt;=100000,0&lt;=a,b&lt;=10^9$ 输出格式 对于每次询问，如果存在满足条件的路径，则输出一行Yes，否则输出一行 No（注意：第一个字母大写，其余字母小写） 。 样例输入 4 5 1 2 1 3 1 3 1 2 1 4 2 1 2 4 3 2 3 4 2 2 5 1 4 3 3 4 2 2 3 1 3 2 2 2 3 2 2 1 3 4 4 样例输出 Yes Yes Yes No No 首先容易想到一个朴素的暴力，即对每个询问，将满足$a_i&lt;=a\&amp;\&amp;b_i&lt;=b$的所有边拿来做一次并查集，然后如果$u,v$在同一个集合中，且这个集合中$Maxa==a\&amp;\&amp;Maxb==b$，那么就存在可行路径。这样做是$O(qm)$的，可以用分块优化。 考虑将边按照$a_i$排序后分组，分成$\sqrt{m}$组，将每个询问插入到对应的组中，对应的组的意思是对于组$i$中第一个元素$a_{询问}&gt;=a_i$,且对于组$i+1$的第一个元素，$a_{询问}&lt;a_{i+1}$ 这样分组后，依次处理每一组的询问，注意到对于组$i$中的询问，前$i-1$组的$a_i$值一定是满足要求的，因此只需要将前$i-1$组中$b_i$也满足要求的插入并查集，因此可以将询问和前$i-1$组的边按照$b_i$排序，这样就可以每组询问$O(m)$处理了，然后对于同组中的边，直接暴力判断是否加入并查集中，然后处理下一个询问时还原并查集，这样的话每个询问的复杂度是$O(\sqrt{m})$的 然后这里的排序可以利用归并排序优化，总复杂度$O(m\sqrt{m}+m\log m)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#define N 100005using namespace std;char *p1,*p2,buf[1&lt;&lt;20];#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC;bool f=0; while(t!='-'&amp;&amp;(t&lt;48||t&gt;57))t=GC; if(t=='-')f=1,t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;1)+(x&lt;&lt;3)+t-48; if(f)x=-x;&#125;struct nodd&#123;int x,f,a,b,d;&#125;S[N&lt;&lt;3];struct node&#123;int x,y,a,b,id;&#125;E[N],K[N],T[N],C[N];int n,m,q,Ans[N],lp[N],rp[N],Si,id[N],F[N],si[N],top,tot,Maxa[N],Maxb[N];vector&lt;node&gt;Q[N];bool cmp1(node a,node b)&#123; if(a.a==b.a)return a.b&lt;b.b; return a.a&lt;b.a;&#125;bool cmp2(node a,node b)&#123; if(a.b==b.b)return a.a&lt;b.a; return a.b&lt;b.b;&#125;int GF(int x)&#123;return F[x]!=x?GF(F[x]):x;&#125;int GM(int x,int y,int z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;void Merge(int x,int y,int a,int b)&#123; int fx=GF(x),fy=GF(y); S[++top]=(nodd)&#123;fx,F[fx],Maxa[fx],Maxb[fx],si[x]&#125;; S[++top]=(nodd)&#123;fy,F[fy],Maxa[fy],Maxb[fy],si[y]&#125;; if(fx==fy) &#123; Maxa[fx]=max(Maxa[fx],a); Maxb[fx]=max(Maxb[fx],b); return; &#125; if(si[fx]&gt;si[fy])swap(fx,fy); F[fx]=fy; Maxa[fy]=GM(Maxa[fx],Maxa[fy],a); Maxb[fy]=GM(Maxb[fy],Maxb[fx],b); si[fy]+=si[fx];&#125;void Mergesort(int l,int r)&#123; int i=1,j=l,k=0; while(i&lt;=tot&amp;&amp;j&lt;=r) &#123; if(T[i].b&lt;=E[j].b)C[++k]=T[i++]; else C[++k]=E[j++]; &#125; while(i&lt;=tot)C[++k]=T[i++]; while(j&lt;=r)C[++k]=E[j++]; for(i=1,tot=k;i&lt;=k;i++)T[i]=C[i];&#125;void Recover(int x)&#123; F[S[x].x]=S[x].f; Maxa[S[x].x]=S[x].a; Maxb[S[x].x]=S[x].b; si[S[x].x]=S[x].d;&#125;int main()&#123; int i,j,k,x,y,a,b,las,p; _R(n);_R(m); Si=sqrt(m); for(i=1;i&lt;=m;i++) &#123; _R(x);_R(y);_R(a);_R(b); E[i]=(node)&#123;x,y,a,b,0&#125;; &#125; _R(q); for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y);_R(a);_R(b); K[i]=(node)&#123;x,y,a,b,i&#125;; &#125; sort(E+1,E+m+1,cmp1); for(i=1;i&lt;=m;i++) &#123; id[i]=i/Si+1; if(!lp[id[i]])lp[id[i]]=i; rp[id[i]]=max(rp[id[i]],i); &#125; E[m+1].a=1e9+7;lp[id[m]+1]=m+1; for(i=1;i&lt;=q;i++) for(j=1;j&lt;=id[m];j++)if(K[i].a&lt;E[lp[j+1]].a)&#123;Q[j].push_back(K[i]);break;&#125; for(i=1;i&lt;=id[m];i++) &#123; sort(E+lp[i],E+rp[i]+1,cmp2); sort(Q[i].begin(),Q[i].end(),cmp2); &#125; for(i=1;i&lt;=id[m];i++) &#123; for(j=1;j&lt;=n;j++)F[j]=j,si[j]=1,Maxa[j]=Maxb[j]=-1; for(j=0,p=1,top=0;j&lt;Q[i].size();j++) &#123; while(p&lt;=tot&amp;&amp;T[p].b&lt;=Q[i][j].b)Merge(T[p].x,T[p].y,T[p].a,T[p].b),p++; for(las=top,k=lp[i];k&lt;=rp[i]&amp;&amp;E[k].b&lt;=Q[i][j].b;k++)if(E[k].a&lt;=Q[i][j].a)Merge(E[k].x,E[k].y,E[k].a,E[k].b); x=GF(Q[i][j].x);y=GF(Q[i][j].y); if(x==y&amp;&amp;Maxa[x]==Q[i][j].a&amp;&amp;Maxb[x]==Q[i][j].b)Ans[Q[i][j].id]=1; while(top!=las)Recover(top--); &#125; Mergesort(lp[i],rp[i]); &#125; for(i=1;i&lt;=q;i++)Ans[i]?puts("Yes"):puts("No");&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>分治法</category>
        <category>分块</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 大数（莫队）]]></title>
    <url>%2F2018%2F03%2F18%2FHNOI-2016-%E5%A4%A7%E6%95%B0%EF%BC%88%E8%8E%AB%E9%98%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day2]大数问题描述 小 B 有一个很大的数 S，长度达到了 N 位；这个数可以看成是一个串，它可能有前导 0，例如00009312345。小B还有一个素数P。现在，小 B 提出了 M 个询问，每个询问求 S 的一个子串中有多少子串是 P 的倍数（0 也是P 的倍数）。 例如 S为0077时，其子串 007有6个子串：0,0,7,00,07,007；显然0077的子串007有6个子串都是素 数7的倍数。 输入格式 第一行一个整数：P。 第二行一个串：S。 第三行一个整数：M。 接下来M行，每行两个整数 fr,to，表示对S 的子串S[fr…to]的一次询问。 注意：S的最左端的数字的位置序号为 1；例如S为213567，则S[1]为 2，S[1…3]为 213。N,M&lt;=100000，P为素数 输出格式 输出M行，每行一个整数，第 i行是第 i个询问的答案。 样例输入 11 121121 3 1 6 1 5 1 4 样例输出 5 3 2 提示 对于30%的数据: n,m&lt;=1000 对于60%的数据: n&lt;=10000,m&lt;=1000 对于100%的数据：n,m&lt;=100000,p是素数 判断一个字串是否能被P整除，容易想到求出该串的后缀模P的值，然后当$P\neq2\&amp;\&amp;P\neq5$时，子串$[L,R]$能被P整除当且仅当后缀$L$和$R+1$模P的值相等。因此可以离散化后用莫队维护模P的cnt值。然后组合数求方案即可。 当P等于2或5时需要特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 100005#define ll long longusing namespace std;struct node&#123;int l,r,id;&#125;K[N];ll P,n,m,D[N],A[N],B[N],cnt[N],S,id[N],Ans[N],ans,L,R;char s[N];bool cmp(node a,node b)&#123; if(id[a.l]==id[b.l])return a.r&lt;b.r; return id[a.l]&lt;id[b.l];&#125;void UD1(ll k,int d)&#123; if(d==1) &#123; if(k&lt;L) &#123; if(D[k]%2)ans+=cnt[0],cnt[1]++; else ans+=++cnt[0]; &#125; else &#123; if(D[k]%2)cnt[1]++; else cnt[0]++,ans+=(R-L+2); &#125; &#125; else &#123; if(k==L) &#123; if(D[k]%2)ans-=cnt[0],cnt[1]--; else ans-=cnt[0],cnt[0]--; &#125; else &#123; if(D[k]%2)cnt[1]--; else ans-=(R-L+1),cnt[0]--; &#125; &#125;&#125;void UD2(ll k,int d)&#123; if(d==1) &#123; if(k&lt;L) &#123; if(D[k]%5)ans+=cnt[0],cnt[1]++; else ans+=++cnt[0]; &#125; else &#123; if(D[k]%5)cnt[1]++; else cnt[0]++,ans+=(R-L+2); &#125; &#125; else &#123; if(k==L) &#123; if(D[k]%5)ans-=cnt[0],cnt[1]--; else ans-=cnt[0],cnt[0]--; &#125; else &#123; if(D[k]%5)cnt[1]--; else ans-=(R-L+1),cnt[0]--; &#125; &#125;&#125;void UD(ll k,int d)&#123; if(P==2)&#123;UD1(k,d);return;&#125; if(P==5)&#123;UD2(k,d);return;&#125; k=A[k]; ans-=cnt[k]*(cnt[k]-1)&gt;&gt;1; cnt[k]+=d; ans+=cnt[k]*(cnt[k]-1)&gt;&gt;1;&#125;int main()&#123; //freopen("data.in","r",stdin); //freopen("zj.out","w",stdout); ll i,j,k,tmp; scanf("%lld",&amp;P); scanf("\n%s",&amp;s[1]); n=strlen(s+1); S=sqrt(n); for(i=n,tmp=1;i&gt;=1;i--,tmp=tmp*10%P) &#123; D[i]=s[i]-48; A[i]=(A[i+1]+D[i]*tmp%P)%P; B[i]=A[i]; &#125; B[n+1]=0; sort(B+1,B+n+2); for(i=1;i&lt;=n+1;i++)A[i]=lower_bound(B+1,B+n+2,A[i])-B; for(i=1;i&lt;=n+1;i++)id[i]=i/S; scanf("%lld",&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;K[i].l,&amp;K[i].r); K[i].id=i; if(P!=2&amp;&amp;P!=5)K[i].r++; &#125; sort(K+1,K+m+1,cmp); L=1;R=0; for(i=1;i&lt;=m;i++) &#123; while(R&lt;K[i].r)UD(R+1,1),R++; while(R&gt;K[i].r)UD(R,-1),R--; while(L&lt;K[i].l)UD(L,-1),L++; while(L&gt;K[i].l)UD(L-1,1),L--; Ans[K[i].id]=ans; &#125; for(i=1;i&lt;=m;i++)printf("%lld\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 矿区（对偶图）]]></title>
    <url>%2F2018%2F03%2F18%2FHNOI-2016-%E7%9F%BF%E5%8C%BA%EF%BC%88%E5%AF%B9%E5%81%B6%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day2]矿区问题描述 平面上的矿区划分成了若干个开发区域。简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为s的开发区域的矿量为 s^2。 现在有 m 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 a和b，则优先度为$\frac{a^2+b^2}{a+b}$。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域） 你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 1.5，面积和是2，那么分子应为3，分母应为4；又如，若矿量和是 2，面积和是 4，那么分子应为 1，分母应为 2）。由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。 输入格式 第一行三个正整数 n,m,k，分别描述平面图中的点和边，以及开采计划的个数。 接下来n行，第 i行(i=1,2,…,n)有两个整数$x_i, y_i$, 表示点i的坐标为$(x_i, y_i)$。 接下来m行，第 i行有两个正整数a,b，表示点a和b 之间有一条边。 接下来一行若干个整数，依次描述每个开采计划。每个开采计划的第一个数c指出该开采计划由开发区域组成的多边形边界上的点的个数为d=(c+P) mod n + 1； 接下来d个整数，按逆时针方向描述边界上的每一个点：设其中第i个数为z_i，则第i个点的编号为$(z_i+P) mod n + 1$。其中P 是上一个开采计划的答案中分子的值；对于第 1 个开采计划，P=0。 输出格式 对于每个开采计划，输出一行两个正整数，分别描述分子和分母。 样例输入 9 14 5 0 0 1 0 2 0 0 1 1 1 2 1 0 2 1 2 2 2 1 2 2 3 5 6 7 8 8 9 1 4 4 7 5 8 3 6 6 9 4 8 1 5 2 6 6 8 3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3 样例输出 1 1 1 2 1 1 9 10 3 4 提示 对于100%的数据，$n, k ≤ 2×10^5, m ≤ 3n-6, |x_i|, |y_i| ≤ 3×10^4$。所有开采计划的d之和不超过$2×10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。保证所有开发区域的矿量和不超过 $2^{63}-1$。保证平面图中没有多余的点和边。保证数据合法。 本题显然考虑对偶图，然后就是平面图求对偶图的问题了。 求出对偶图后，在对偶图上以无穷域为根求一个DFS树，并统计每个点的子树矿量和与面积和，那么给每条边规定方向，令原图中的边对应上逆时针旋转$90$度后对偶图中的边，然后在原图中跑每一条边，如果该边的对应边是从DFS树上儿子走向父亲的，那么答案减去该儿子所在子树权值，否则就加上。 画个图就能发现，这是正确的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;#define ll long long#define N 200005using namespace std;char *p1,*p2,buf[1&lt;&lt;20];#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline int _R()&#123; char t=GC;bool f=0;int x=0; while(t!='-'&amp;&amp;(t&lt;48||t&gt;57))t=GC; if(t=='-')f=1,t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;1)+(x&lt;&lt;3)+t-48; return f?-x:x;&#125;int n,m,k,cnt=1,tot,rt;int NE[N&lt;&lt;3],num[N&lt;&lt;3],q[N],fa[N&lt;&lt;1];ll ans1,ans2,s[N&lt;&lt;1],s2[N&lt;&lt;1];bool vis[N&lt;&lt;1],mark[N&lt;&lt;3];struct node&#123;ll x,y;&#125;p[N];node operator+(node a,node b)&#123;return (node)&#123;a.x+b.x,a.y+b.y&#125;;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;ll operator*(node a,node b)&#123;return a.x*b.y-a.y*b.x;&#125;struct nodd&#123; int x,y,id;double alp; nodd(int tx=0,int ty=0,int tid=0) &#123; x=tx;y=ty;id=tid; alp=atan2((double)(p[y].y-p[x].y),(double)(p[y].x-p[x].x)); &#125;&#125;e[N&lt;&lt;3];bool operator&lt;(nodd a,nodd b)&#123;return a.alp&lt;b.alp;&#125;vector&lt;nodd&gt;E[N],G[N&lt;&lt;1];int Find(int x,nodd tmp)&#123;return lower_bound(E[x].begin(),E[x].end(),tmp)-E[x].begin();&#125;ll gcd(ll x,ll y)&#123;return y?gcd(y,x%y):x;&#125;void Build()&#123; int i,j,tmp,st;ll area; for(i=2;i&lt;=cnt;i++) if(!num[i]) &#123; area=0;tot++; j=i;st=e[i].x; do&#123; num[j]=tot; area+=p[e[j].x]*p[e[j].y]; j=NE[j]; &#125;while(j!=i); s[tot]=area;s2[tot]=area*area; if(area&lt;=0)rt=tot; &#125; for(i=2;i&lt;=cnt;i++)G[num[i]].push_back(nodd(num[i],num[i^1],i));&#125;void DFS(int x)&#123; int i,y;vis[x]=1; for(i=0;i&lt;G[x].size();i++) &#123; y=G[x][i].y; if(vis[y])continue; mark[G[x][i].id]=mark[G[x][i].id^1]=1; fa[y]=x;DFS(y); s[x]+=s[y];s2[x]+=s2[y]; &#125;&#125;int main_main()&#123; int i,j,x,y,z; n=_R();m=_R();k=_R(); for(i=1;i&lt;=n;i++)p[i].x=_R(),p[i].y=_R(); for(i=1;i&lt;=m;i++) &#123; x=_R();y=_R(); cnt++;e[cnt]=nodd(x,y,cnt);E[x].push_back(e[cnt]); cnt++;e[cnt]=nodd(y,x,cnt);E[y].push_back(e[cnt]); &#125; for(i=1;i&lt;=n;i++)sort(E[i].begin(),E[i].end()); for(i=2;i&lt;=cnt;i++) &#123; int tmp=Find(e[i].y,e[i^1])-1; if(tmp&lt;0)tmp+=E[e[i].y].size(); NE[i]=E[e[i].y][tmp].id; &#125; Build();DFS(rt); for(i=1;i&lt;=k;i++) &#123; z=_R();z=(z+ans2)%n+1; for(j=1;j&lt;=z;j++) &#123; x=_R(); q[j]=(x+ans2)%n+1; &#125; ans1=ans2=0;q[z+1]=q[1]; for(j=1;j&lt;=z;j++) &#123; x=q[j];y=q[j+1];int tmp=E[x][Find(x,nodd(x,y,0))].id; if(!mark[tmp])continue; if(num[tmp]==fa[num[tmp^1]])ans1-=s[num[tmp^1]],ans2-=s2[num[tmp^1]]; else ans1+=s[num[tmp]],ans2+=s2[num[tmp]]; &#125; ll d=gcd(ans1,ans2); ans1/=d;ans2/=d; if(ans2&amp;1)ans1&lt;&lt;=1;else ans2&gt;&gt;=1; printf("%lld %lld\n",ans2,ans1); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>图论</category>
        <category>对偶图</category>
      </categories>
      <tags>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2016 序列（RMQ+单调栈）]]></title>
    <url>%2F2018%2F03%2F18%2FHNOI-2016-%E5%BA%8F%E5%88%97%EF%BC%88RMQ-%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[Hnoi2016 day2]序列问题描述 给定长度为n的序列：$a_1,a_2,…,a_n$记为a[1:n]。 类似地，a[l:r]（$1≤l≤r≤N$）是指序列：$a_l,a_{l+1},…,a_{r-1},a_r$。 若$1≤l≤s≤t≤r≤n$，则称a[s:t]是a[l:r]的子序列。 现在有q个询问，每个询问给定两个数l和r，$1≤l≤r≤n$，求a[l:r]的不同子序列的最小值之和。 例如，给定序列5,2,4,1,3，询问给定的两个数为1和3，那么a[1:3]有 6个子序列a[1:1],a[2:2],a[3:3],a[1:2],a[2:3],a[1:3]，这6个子序列的最小值之和为5+2+4+2+2+2=17。 输入格式 第一行包含两个整数n和q，分别代表序列长度和询问数。 接下来一行，包含n个整数，以空格隔开,第i个整数为$a_i$，即序列第i个元素的值。 接下来q行，每行包含两个整数l和r，代表一次询问。 输出格式 对于每次询问，输出一行，代表询问的答案。 样例输入 5 5 5 2 4 1 3 1 5 1 3 2 4 3 5 2 5 样例输出 28 17 11 11 17 提示 $1 ≤N,Q ≤ 100000,|A_i| ≤ 10^9$ 这个做法非常的妙啊。 令$pre[i]$表示以$i$为区间右端点的所有区间的最小值之和。 令$Pre[i]$表示$pre[i]$的前缀和，即$[1,i]$的所有子区间的最小值之和。 令$suf[i]$表示以$i$为区间左端点的所有区间的最小值之和。 令$Suf[i]$表示$suf[i]$的后缀和，即$[i,n]$的所有子区间的最小值之和。 上述四个数组可以通过维护单调栈来$O(n)$求出。例如求$pre[i]$，只需要找到$i$左边第一个比$i$小的位置$j$，求可以求出$pre[i]$ 考虑如何求解答案，对于一个询问$[L,R]$，那么先找到$[L,R]$的最小值$Min$和最小值的位置$pos$ 对于左端点在$[L,pos]$，右端点在$[pos,R]$的区间，那么它的最小值一定是$Min$，可以$O(1)$统计。 对于左端点在$[L,pos-1]$，右端点在$[L,pos-1]$的区间，我们考虑$Suf[L]-Suf[pos]$，其中不仅有我们想要的，还有一部分是左端点在$[L,pos-1]$，右端点在$[pos,n]$的区间，考虑把它减掉，由于这些区间跨过了$pos$位置，那么他们的答案等价于$suf[pos]\times (pos-L)$，另一部分可以同理处理。 因此本题就只需要$RMQ$解决了。复杂度$O(n\log n)$，而且常数非常小 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#define N 100005#define ll long longusing namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC;bool f=0; while((t&lt;48||t&gt;57)&amp;&amp;t!='-')t=GC; if(t=='-')f=1,t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;1)+(x&lt;&lt;3)+t-48; x=f?-x:x;&#125;int n,q,A[N],F[N][20],S[N],T=17;ll suf[N],Suf[N],pre[N],Pre[N],Log[N];int RMQ(int l,int r)&#123; int k=Log[r-l+1],t=r-(1&lt;&lt;k)+1; return A[F[l][k]]&lt;A[F[t][k]]?F[l][k]:F[t][k];&#125;int main()&#123; register int i,j,k,x,y,Min,top; _R(n);_R(q);Log[1]=0; for(i=2;i&lt;=n;i++)Log[i]=Log[i&gt;&gt;1]+1; for(i=1;i&lt;=n;i++)_R(A[i]); for(i=1;i&lt;=n;i++)F[i][0]=i; for(i=n;i&gt;=1;i--) for(j=1;j&lt;=Log[n-i+1];j++)F[i][j]=A[F[i][j-1]]&lt;A[F[i+(1&lt;&lt;j-1)][j-1]]?F[i][j-1]:F[i+(1&lt;&lt;j-1)][j-1]; for(i=n;i&gt;=1;i--) &#123; while(top&amp;&amp;A[i]&lt;A[S[top]])top--; suf[i]=top?suf[S[top]]+1ll*(S[top]-i)*A[i]:suf[i]=1ll*(n-i+1)*A[i]; Suf[i]=Suf[i+1]+suf[i]; S[++top]=i; &#125; for(i=1,top=0;i&lt;=n;i++) &#123; while(top&amp;&amp;A[i]&lt;A[S[top]])top--; pre[i]=top?pre[S[top]]+1ll*(i-S[top])*A[i]:pre[i]=1ll*i*A[i]; Pre[i]=Pre[i-1]+pre[i]; S[++top]=i; &#125; for(i=1;i&lt;=q;i++) &#123; _R(x);_R(y); Min=RMQ(x,y); printf("%lld\n",1ll*(Min-x+1)*(y-Min+1)*A[Min]+Suf[x]-Suf[Min]-1ll*(Min-x)*suf[Min]+Pre[y]-Pre[Min]-1ll*(y-Min)*pre[Min]); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>单调栈</category>
        <category>RMQ</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4946 Area of Mushroom （凸包）]]></title>
    <url>%2F2018%2F03%2F15%2FHDU-4946-Area-of-Mushroom-%EF%BC%88%E5%87%B8%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Area of Mushroom问题描述 **中学有一个很大的操场，上面有n名同学(编号1到n)。我们可以看做一个无限大的平面上有n个坐标点。同学们跑步速度有快有慢。对于操场上的任何一点，如果一个学生能比其他学生都先到达(跑直线，没有人比他先到或同时到)，那么这个点就被他占领。 请你计算，哪些同学能占领无穷多个点。 输入格式 输入含有多组数据(&lt;=8组)，对于每组数据： 第一行一个整数n。 接下来n行，每行三个整数x,y,v，按1到n的顺序依次描述一个同学的位置坐标(x,y)和他的跑步速度。 输入以单独一行，一个数字0作为结束。 输出格式 对于每组数据，输出一行，n个数字，对应1到n号学生的情况。如果该学生能占用无限多个点，输出1，否则输出0。 样例输入 1 30 0 31 1 22 2 10 样例输出 1 100 样例输入 2 30 0 21 1 12 0 241 1 31 1 22 2 23 3 10 样例输出 2 1011000 提示 对于20%的数据： 1&lt;=n&lt;=5对于100%的数据：1&lt;=n&lt;=500 0&lt;=|x|,|y|,v&lt;=10^4 首先注意到只有速度最大的人才有可能占有无限的面积，这个比较显然，推式子的话会发现如果速度不相等，那么最终速度小的占有的会是一个圆。 因此只考虑速度最大的人，那么只有凸包上的人才能占有无限的面积，这个也比较容易脑补。因此只需要求出所有速度最大的人的凸包。 但是注意到两种特殊情况。一是如果所有人速度都为0，那么答案显然都为0。二是可能存在两个人的坐标相同，速度也相同，此时根据题意，两个人占有的面积都是0，需要特判，但是注意求凸包的时候，所有坐标速度都相同的人只能加一个且必须加一个，加多了会导致求凸包算法出问题，因为本题中凸包上三点共线是要保留的，因此有重点就会使得该被弹掉的点弹不掉。 复杂度$O(n\log n)$，事实上是可以推导一番用半平面交的，但精度好像有点问题？ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;const double eps=1e-12;struct node&#123;double x,y;int id;&#125;P[N],T[N],S[N];bool operator&lt;(node a,node b)&#123; if(a.x==b.x)return a.y&gt;b.y; return a.x&lt;b.x;&#125;node operator-(node a,node b)&#123;return (node)&#123;a.x-b.x,a.y-b.y&#125;;&#125;double operator*(node a,node b)&#123;return a.x*b.y-a.y*b.x;&#125;int n,v[N],top,m,tot;bool mark[N],rem[N];bool find(int x)&#123; bool f=0; for(int i=1;i&lt;=n;i++) &#123; if(i==x)continue; if(P[i].x!=P[x].x)continue; if(P[i].y!=P[x].y)continue; if(v[i]!=v[x])continue; f=1;rem[i]=1; &#125; return f;&#125;bool judge(node a,node b,node c)&#123;return (b-a)*(c-a)&lt;0;&#125;void GetTB()&#123; int i,j,k;top=0; sort(T+1,T+tot+1); for(i=1;i&lt;=tot;i++) &#123; while(top&gt;1&amp;&amp;judge(S[top-1],S[top],T[i]))top--; S[++top]=T[i]; &#125; k=--top; for(i=tot;i&gt;=1;i--) &#123; while(top&gt;k+1&amp;&amp;judge(S[top-1],S[top],T[i]))top--; S[++top]=T[i]; &#125; for(i=1;i&lt;=top;i++)mark[S[i].id]=1;&#125;int main()&#123; int i,j,k,Max; while(scanf("%d",&amp;n)) &#123; if(n==0)break;Max=0;tot=0; memset(mark,0,sizeof(mark)); memset(rem,0,sizeof(rem)); for(i=1;i&lt;=n;i++)scanf("%lf%lf%d",&amp;P[i].x,&amp;P[i].y,&amp;v[i]); for(i=1;i&lt;=n;i++)Max=max(Max,v[i]),P[i].id=i; if(Max==0) &#123; for(i=1;i&lt;=n;i++)putchar('0'); puts("");continue; &#125; for(i=1;i&lt;=n;i++)if(v[i]==Max&amp;&amp;!rem[i])T[++tot]=P[i],find(i); GetTB(); for(i=1;i&lt;=n;i++)mark[i]&amp;&amp;!find(i)?putchar('1'):putchar('0'); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5794 A Simple Chess （容斥原理+Lucas定理+dp）]]></title>
    <url>%2F2018%2F03%2F15%2FHDU-5794-A-Simple-Chess-%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-Lucas%E5%AE%9A%E7%90%86-dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A Simple Chess问题描述 有一个n*m棋盘，一枚棋子要从(1,1)格子移动到(n,m)格子。 该棋子能从坐标为(x1,y1)的格子跳到格子(x2,y2),当且仅当: (x2-x1)^2+(y2-y1)^2=5 x2&gt;x1，y2&gt;y1 棋盘上有r个格子有障碍物，棋子不能落到有障碍物的格子上。 请你计算，该棋子从起点到达终点总共有多少种方案。 输入格式 有若干组数据(&lt;=25组)，对于每组数据，格式如下：一行，三个整数n，m，r接下来r行，每行两个整数，表示一个有障碍物的格子的坐标。 输出格式 对于每组数据，输出一行，一个整数，表示所求方案数。mod 110119 样例输入 1 1 1 03 3 04 4 12 14 4 13 27 10 21 27 1 样例输出 1 10215 样例输入 2 58939239 79926962 428255565 3653519451497377 6732226048931736 6229047623383627 30097072 样例输出 2 9061 提示 对于100%的数据：1≤n,m≤10^18 , 0≤r≤100 (1,1)格子不会有障碍。 为了方便，将题目中的$x,y$坐标都减一，变成从$(0,0)$到$(n-1,m-1)$ 如果不考虑障碍，那么从$(0,0)$到$(x,y)$的方案数是一个组合数，这个比较好推，就是$C_{\frac{x+y}{3}}^{\frac{2x-y}{3}}$，注意到$(x,y)$可以到达当且仅当$x+y\equiv0\ mod\ 3$ 障碍数比较小，考虑容斥，令$F[i]$表示从$(1,1)$出发，经过的第一个障碍是第$i$个障碍，那么对于每一个在$i$左下角的障碍$j$，$$F[i]=C_{\frac{x_i+y_i}{3}}^{\frac{2x_i-y_i}{3}}-\sum_{j}F[j]\times C_{\frac{tx+ty}{3}}^{\frac{2tx-ty}{3}},tx=x_i-x_j,ty=y_i-y_j$$直接写个记忆化搜索，暴力枚举那些点在左下方就行了。组合数用$Lucas$处理，预处理阶乘和逆元，注意到$2x-y$可能小于$0$，此时也意味着走不到，因此要返回$0$另外还需要注意如果终点是障碍，那么答案也是$0$ 总时间复杂度$O(n^2\times???)$，还是很快。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 105#define ll long longusing namespace std;const ll mod=110119;ll n,m,r,F[N],X[N],Y[N],fac[110220],inv[110220];bool mark[N];ll C(ll a,ll b)&#123; if(a&lt;b)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;ll Lucas(ll a,ll b)&#123; if(a&lt;b)return 0; if(a&lt;0||b&lt;0)return 0; if(b==0||a==0)return 1; return Lucas(a/mod,b/mod)*C(a%mod,b%mod)%mod;&#125;ll DP(ll p)&#123; ll i,j; if(F[p]!=-1)return F[p]; if(mark[p])return F[p]=0; F[p]=Lucas((X[p]+Y[p])/3,(2*Y[p]-X[p])/3); for(i=1;i&lt;=r;i++) if(X[i]&lt;X[p]&amp;&amp;Y[i]&lt;Y[p]) &#123; if(mark[i])continue; F[p]-=DP(i)*Lucas((X[p]+Y[p]-X[i]-Y[i])/3,(2*(Y[p]-Y[i])-X[p]+X[i])/3)%mod; F[p]%=mod; &#125; F[p]+=mod;F[p]%=mod; return F[p];&#125;int main()&#123; ll i,j,k,x,y;bool f; fac[0]=fac[1]=inv[0]=inv[1]=1; for(i=2;i&lt;=mod;i++) &#123; fac[i]=fac[i-1]*i%mod; inv[i]=(mod-mod/i)*inv[mod%i]%mod; &#125; for(i=2;i&lt;=mod;i++)inv[i]=inv[i]*inv[i-1]%mod; while(scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;r)!=EOF) &#123; f=0; for(i=1;i&lt;=r;i++) &#123; scanf("%lld%lld",&amp;X[i],&amp;Y[i]); if(X[i]==n&amp;&amp;Y[i]==m)f=1; &#125; if(f)&#123;puts("0");continue;&#125; for(i=1;i&lt;=r;i++)X[i]--,Y[i]--; X[++r]=n-1;Y[r]=m-1; for(i=1;i&lt;=r;i++)mark[i]=(X[i]+Y[i])%3!=0; memset(F,-1,sizeof(F)); printf("%lld\n",DP(r)); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>容斥原理</category>
        <category>Lucas</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5781 ATM Mechine（数学期望+dp）]]></title>
    <url>%2F2018%2F03%2F15%2FHDU-5781-ATM-Mechine%EF%BC%88%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B-dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自动取款机问题描述 Alice打算从自动取款机上取出她的所有存款。但是她忘了自己有多少存款了，她只知道存款不超过k块钱。 但是这台取款机很奇怪，它不支持余额查询功能，Alice只能通过多次尝试的方式取钱。每次尝试，Alice输入一个提取金额y，若账户余额&gt;=y,取款机会立即吐出y块钱。若余额 &lt; y，取款机会发出警告。如果取款机发出了w次警告，它会认为Alice在故意捣乱，就会立即把卡吞掉。 请你帮忙计算，在不被吞卡的情况下，期望多少次就能取出所有的钱？ 输入格式 有5组数据 对于每组数据，只有一行, 两个整数 k和w. 输出格式 五行，每行对应一组数据的结果，只有一个数字,表示问题的答案，保留6个小数位。 样例输入 1 1 14 220 310 6123 7 样例输出 1 1.0000002.4000004.5238103.5454556.967742 样例输入 2 322 61193 10926 7335 3253 2 样例输出 2 8.44582010.2847579.90722810.74702415.937008 提示 对于100%的数据, 1≤K,W≤2000 令$F[i][j]$表示钱数不超过$i$，再被$j$次警告就会GG，那么考虑这一次取多少钱，有$$F[i][j]=min(\frac{i+1-k}{i+1}F[i-k][j]+\frac{k}{i+1}F[k-1][j-1]+1)$$由于实际钱数是一个随机变量，那么有$\frac{i+1-k}{i+1}$的概率实际钱数大于等于$k$使得取钱成功，有$\frac{k}{i+1}$的概率被警告，无论如何钱数的上界都会缩小。 直接这样dp是$O(n^3)$的，但是注意到如果$w$足够大，那么是可以二分得到最优答案的。因此当$w&gt;\log_2k$之后，$F[i][w]$是不变的。因此第二维只需要算到$12$就差不多了。复杂度$O(n^2)$ 代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2005using namespace std;int k,w;double F[N][N];int main()&#123; int i,j,x; for(i=1;i&lt;N;i++)F[i][1]=1.0*F[i-1][1]*i/(i+1)+1.0; for(i=1;i&lt;N;i++)F[1][i]=1.0; for(i=2;i&lt;N;i++) for(j=2;j&lt;14;j++) &#123; F[i][j]=1e9; for(x=1;x&lt;=i;x++)F[i][j]=min(1.0*F[i-x][j]*(i+1-x)/(i+1)+1.0*F[x-1][j-1]*x/(i+1)+1.0,F[i][j]); &#125; for(i=1;i&lt;=5;i++) &#123; scanf("%d%d",&amp;k,&amp;w);w=min(w,13); printf("%.6lf\n",F[k][w]); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>概率与期望</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4169 LＭC的游戏 （博弈+树dp）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-4169-LMC%E7%9A%84%E6%B8%B8%E6%88%8F-%EF%BC%88%E5%8D%9A%E5%BC%88-%E6%A0%91dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[4169 LMC的游戏【题目描述】 RHL 有一天看到 lmc 在玩一个游戏。“愚蠢的人类哟,what are you doing”,RHL 说。“我在玩一个游戏。现在这里有一个有 n 个结点的有根树,其中有 m 个叶子结点。这 m个叶子从 1 到 m 分别被给予了一个号码,每个叶子的号码都是独一无二的。一开始根节点有一个棋子,两个玩家每次行动将棋子移动到当前节点的一个儿子节点。当棋子被移动到某个叶节点的时候游戏结束,这个叶节点的号码即为该局游戏的 result。先手的玩家要最大化result,后手的玩家要最小化这个 result。”“你不先问一下我是谁吗 = =”“那么,who are you”“我是这个世界的创造者,维护者和毁灭者,整个宇宙的主宰,无所不知,无所不能的,三个字母都大写的 RHL。”“既然你这么厉害,那你一定知道,在两个玩家都无限聪明的情况下,在树的形态已知的情况下,在叶子的编号可以任意安排的情况下,游戏的 result 最大是多少咯。” 【输入格式】 输入数据第一行有一个正整数 n,表示结点的数量。接下来 n-1 行,每行有两个正整数 u 和 v,表示的父亲节点是 u。 【输出格式】 输出一行 2 个非负整数,分别表示 result 的最大值和最小值。 【样例输入】 51 21 32 42 5 【样例输出】 3 2 【样例解释】 有 3,4,5 三个叶子。若令 3 号叶子的编号是 3,则先手可以移到 3 号结点,故 result最大是 3。若 3 号叶子的编号是 2,则先手可以移到 3 号结点,故 result 最小是 2. 【数据范围】 30%,n&lt;=10100%,n&lt;=200000 有意思的博弈题。只考虑最大值的情况，最小值是类似的。令$F[i]$表示在$i$号点能取得子树中第$F[i]$大的叶子。如果$i$号点是先手移动，那么$F[i]=min(F[son_i])$，这个转移是显然的。如果$i$号点是后手移动，那么$F[i]=\sum F[son_i]$，这个转移是因为后手肯定会选择第$F[son_i]$大的值最小的子树移动，因此最后取得的一定是第$\sum F[son_i]$大的。 如果$i$号点是叶子，那么$F[i]=1$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005using namespace std;int n,m,dp[2][N],rt;int TOT,LA[N],NE[N],EN[N];bool mark[N],mmark[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int ty)&#123; if(!mmark[x])&#123;dp[0][x]=dp[1][x]=1;return;&#125; dp[ty][x]=1e9; for(int i=LA[x];i;i=NE[i]) &#123; int y=EN[i];DFS(y,ty^1); dp[ty][x]=min(dp[ty][x],dp[ty][y]); dp[ty^1][x]+=dp[ty^1][y]; &#125;&#125;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); mark[y]=1; mmark[x]=1; ADD(x,y); &#125; for(i=1;i&lt;=n;i++)if(!mark[i])rt=i; for(i=1;i&lt;=n;i++)if(!mmark[i])m++; DFS(rt,0); printf("%d %d",m-dp[0][rt]+1,dp[1][rt]);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>博弈</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ｎewnode‘s NOI 模拟赛 第二题 （单调dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNewnode%E2%80%98s-NOI-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E7%AC%AC%E4%BA%8C%E9%A2%98-%EF%BC%88%E5%8D%95%E8%B0%83dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二题问题描述 样例输入 1 3 2 *# #* ## 样例输出 1 2 样例输入 2 4 5*####*######## #\**# 样例输出 2 3 提示 对于20%的数据n,m&lt;=5；对于50%的数据满足n,m&lt;=500；对于100%的数据满足2&lt;=n,m&lt;=2000。 题意要求用每次消去正或反的Ｌ形的三个格子，消除所有的关键格子，需要的最小步数。显然每一列只需要关心最上面一个关键格子的位置就行了。因此令$A[i]$表示第$i$列最上面一个关键格子是从下往上数的第几个格子。 先考虑暴力的dp，令$F[i][j]$表示前$i$列，前$i-1$列已经消完，第$i$列还需要消$j$个格子的最优步数。那么转移的时候枚举第$i$列消去了$k$个反Ｌ形，有$$F[i][j]=min(F[i-1][k+2(A[i]-j-2k)]+k+A[i]-j-2k)$$$k+2(A[i]-j-2k)$表示消去第$i$行时，第$i-1$行会被消去的数量，也可以从$F[i-1]$第二维更小的位置转移过来，但显然不会更优。另外，$F[i][A[i]+1]-F[i][n]$都赋值为$F[i-1][0]$ 这个dp是$O(n^3)$的，需要优化。 考虑一下每次转移时$F[i][j]$和$F[i][j+1]$分别在$k$等于多少时取得最优值，一个结论是$F[i][j+1]$取得最优值的$k$一定小于等于$F[i][j]$取得最优值的k，这个结论脑补一下就能理解。因为需要消去的块变少了，那么相应的操作数一定是不增的。 容易得到$F[i]$是随着j变大而单调不增的。 再观察一下可以发现，在$j$确定的时候，$F[i-1][2A[i]-2j-3k]+A[i]-j-k$的取值是单峰的。因为$F[i-1][2A[i]-2j-3k]$随k的减小是不增的，$A[i]-j-k$是单增的，因此它是单峰的。 那么我们得到了一个很好的性质，即$F[i][j]$的转移是单峰的，并且峰的位置是单调的。因此我们就可以将枚举k的复杂度变成均摊$O(1)$的了。只需要每次记录一下最优的k取值，讨论$j+1$时直接从这个最优取值开始，如果$k-1$不能更优就$break$就行了。 总时间复杂度$O(n^2)$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2005using namespace std;int n,m,F[N][N],A[N];char map[N][N];int main()&#123; int i,j,k,x,id; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("\n%s",&amp;map[i][1]); for(i=1;i&lt;=m;i++) &#123; for(j=1;j&lt;=n;j++)if(map[j][i]=='*')break; A[i]=n+1-j; &#125; memset(F,60,sizeof(F)); for(i=0;i&lt;=n;i++)F[0][i]=0; for(i=1;i&lt;=m;i++) &#123; id=A[i]&gt;&gt;1; for(j=0;j&lt;=A[i];j++) &#123; id=min(id,A[i]-j&gt;&gt;1); for(k=id;k&gt;=0;k--) &#123; x=k+(A[i]-j-2*k&lt;&lt;1); if(x&gt;A[i-1])x=A[i-1]; if(F[i][j]&gt;=F[i-1][x]+A[i]-j-k)id=k,F[i][j]=F[i-1][x]+A[i]-j-k; else break; &#125; &#125; for(j=A[i]+1;j&lt;=n;j++)F[i][j]=F[i-1][0]; &#125; printf("%d",F[m][0]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4171 RHL的游戏（高斯消元+压位）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-4171-RHL%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83-%E5%8E%8B%E4%BD%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[4171: Rhl的游戏Description RHL最近迷上一个小游戏：Flip it。游戏的规则很简单，在一个N*M的格子上，有一些格子是黑色，有一些是白色每选择一个格子按一次，格子以及周围边相邻的格子都会翻转颜色（边相邻指至少与该格子有一条公共边的格子），黑变白，白变黑。RHL希望把所有格子都变成白色的。不幸的是，有一些格子坏掉了，无法被按下。这时，它可以完成游戏吗？ Input 第一行一个整数T，表示T组数据。每组数据开始于三个整数n,m,k，分别表示格子的高度和宽度、坏掉格子的个数。接下来的n行，每行一个长度m的字符串，表示格子状态为‘B‘或‘W‘。最后k行，每行两个整数Xi,Yi(1≤Xi≤n,1≤Yi≤m)，表示坏掉的格子。n,m,k&lt;=256,T&lt;=10 Output 对于每组数据，先输出一行Case #i: (1≤i≤T)如果可以成功，输出YES，否则输出NO。 Sample Input 23 3 0WBWBBBWBW3 3 2WBWBBBWBW2 23 2 Sample Output Case #1:YESCase #2:NO 如果n,m的范围比较小，那么直接令$X_{i,j}$表示$(i,j)$格子按不按，然后直接高斯消元，不能按的限制等价于一个方程$X_{i,j}=0$ 当n,m比较大的时候，直接高斯消元虽然可以利用他比较稀疏的特点优化时间，但空间还是比较卡。这时考虑缩小变量规模，可以利用$X_{1,i}$表示出$X_{2,i}$进而将$X_{n,i}$表示出来，这样变量规模就缩小到了n的规模。 这依赖于一个等式，对于点$(i,j)$，有$$X_{i-1,j}\oplus X_{i,j}\oplus X_{i,j-1}\oplus X_{i,j+1}\oplus X_{i+1,j}\oplus map[i][j]=0$$那么利用这个等式，就可以在已知第$i$行和$i-1$行的线性表示的情况下，表示出$i+1$行关于$X_{i,1…m}$的线性表示。举个例子就是$X_{2,3}=X_{1,3}\oplus X_{1,2}\oplus X_{1,4}\oplus map[1][3]$，这里的$map[1][3]$表示$(1,3)$这个格子是$0\ or\ 1$ 那么以此类推到最后一行后，就可以利用$(n,j)$点的等式来列出一个关于$X_{1,1…m}$的方程，总共有m个方程，m个未知数。 对于不能按的限制，由于已知了每个点的线性表示，那么也可以变成一个方程。最后高斯消元即可。 代码实现的时候只需要用一个$bitset$，$F[i][j]$表示$(i,j)$的线性表示中$X_{1,1…m}$的系数，另外用一个$int$数组记录一下$map[i][j]$的异或和即可。 总复杂度$O(Ｔ\frac{n^3}{32})$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#define N 260using namespace std;char s[N][N];bitset&lt;260&gt;map[N],F[N][N],G[N],A,B,C[N];int T,n,m,k;bool Gauss(int row,int col)&#123; int i,j,k,MR,x,y; for(x=1,y=1,MR=1;x&lt;=row&amp;&amp;y&lt;col;x++,y++,MR=x) &#123; for(i=x;i&lt;=row;i++)if(C[i][y]==1)MR=i; if(C[MR][y]==0)&#123;x--;continue;&#125; swap(C[x],C[MR]); for(i=x+1;i&lt;=row;i++)if(C[i][y])C[i]^=C[x]; &#125; for(i=x;i&lt;=row;i++)if(C[i][col]==1)return 0; return 1;&#125;int main()&#123; int i,j,tot,x,y,t; scanf("%d",&amp;T); for(t=1;t&lt;=T;t++) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(C,0,sizeof(C)); memset(map,0,sizeof(map)); memset(G,0,sizeof(G)); memset(F,0,sizeof(F)); for(i=1;i&lt;=n;i++)scanf("\n%s",&amp;s[i][1]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)if(s[i][j]=='B')map[i][j]=1; for(i=1;i&lt;=m;i++)F[1][i][i]=1; for(i=2;i&lt;=n;i++) for(j=1;j&lt;=m;j++) &#123; F[i][j]=F[i-1][j-1]^F[i-1][j]^F[i-1][j+1]^F[i-2][j]; G[i][j]=G[i-1][j-1]^G[i-1][j]^G[i-1][j+1]^G[i-2][j]^map[i-1][j]; &#125; for(i=1;i&lt;=m;i++) &#123; C[i]=F[n][i]^F[n][i-1]^F[n][i+1]^F[n-1][i]; C[i][m+1]=G[n][i]^G[n][i-1]^G[n][i+1]^G[n-1][i]^map[n][i]; &#125; tot=m; while(k--) &#123; scanf("%d%d",&amp;x,&amp;y); C[++tot]=F[x][y]; C[tot][m+1]=G[x][y]; &#125; if(Gauss(tot,m+1))printf("Case #%d:\nYES\n",t); else printf("Case #%d:\nNO\n",t); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
        <category>杂学</category>
        <category>压位</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>压位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ 5495 MiniumCut （最小割树）]]></title>
    <url>%2F2018%2F03%2F15%2FJZOJ-5495-MiniumCut-%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MiniumCutDescription 从前有张图。图里 n 个顶点两两之间有 $n^2$ 种最小割。告诉你这 $n^2$ 个最小割。还原出这张图。 Input 第一行一个正整数 n, 表示图的顶点数。接下来 n 行每行 n 个非负整数, 第 i 行第 j 列的数表示第 i 个点与第 j 个点的最小割。点的编号从 1 开始。$v_{ij}$ ≤ $10^5$ 。保证 $v_{ii}$ = 0。 Output 第一行一个整数 m, 表示图的边数。接下来每行三个整数 u,v,z。表示从 u 到 v 存在一条权值为 z 的边。$1 ≤ u, v ≤ n$$0 ≤ z ≤ 10^9 $$m ≤\frac{n(n-1)}{2}$请注意你给出的图要求联通。如果无解请输出 −1。若有多解则输出任意一组解。 Scoring 对于 10% 的数据, n = 2。对于 100% 的数据, n ≤ 100。 结论题，一张图最多有$n-1$个不同的最小割，并且可以构造成一颗最小割树，最小割树上两点间边的权值的最小值就是他们的最小割，因此本题只需要构造出最小割树就行了。 每次选取一个最小的最小割，然后这个最小割将树分成两部分，然后用并查集将最小割值大于选取值的点对划分到一个集合中，最后必然形成两个无交的集合，如果只有一个那么无解。然后对两个集合递归求解即可。每次选取出来的最小割和对应点对最终构成一颗最小割树。 如果不知道最小割树可以参考CQOI 2016 不同的最小割 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;vector&gt;#define N 205using namespace std;struct node&#123;int x,y,z;&#125;Edge[N];set&lt;int&gt;QQ;int n,G[N][N],tot,F[N];int GF(int x)&#123; if(F[x]!=x)F[x]=GF(F[x]); return F[x];&#125;void Merge(int x,int y)&#123; x=GF(x);y=GF(y); if(x!=y)F[x]=y;&#125;bool Solve(vector&lt;int&gt;Q)&#123; int i,j,k,x,y,Min=1e9,m=Q.size(); if(m==0||m==1)return 1; for(i=0;i&lt;m;i++) for(j=0;j&lt;m;j++)if(i!=j)Min=min(Min,G[Q[i]][Q[j]]); for(x=0;x&lt;m;x++) &#123; for(y=0;y&lt;m;y++)if(x!=y&amp;&amp;Min==G[Q[x]][Q[y]])break; if(y&lt;m&amp;&amp;x!=y&amp;&amp;Min==G[Q[x]][Q[y]])break; &#125; x=Q[x];y=Q[y]; Edge[++tot]=(node)&#123;x,y,Min&#125;; for(i=0;i&lt;m;i++)F[Q[i]]=Q[i]; for(i=0;i&lt;m;i++) for(j=0;j&lt;m;j++)if(G[Q[i]][Q[j]]&gt;Min)Merge(Q[i],Q[j]); if(GF(x)==GF(y))return 0; k=GF(x); vector&lt;int&gt;Q1,Q2; for(i=0;i&lt;m;i++) &#123; if(GF(Q[i])==k)Q1.push_back(Q[i]); else Q2.push_back(Q[i]); &#125; return Solve(Q1)&amp;Solve(Q2);&#125;int main()&#123; int i,j,k,x,y; vector&lt;int&gt;Q; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) &#123; scanf("%d",&amp;x); if(i!=j)QQ.insert(x); G[i][j]=x; &#125; if(QQ.size()&gt;n-1)return printf("-1"),0; for(i=1;i&lt;=n;i++)Q.push_back(i); if(Solve(Q)) &#123; printf("%d\n",n-1); for(i=1;i&lt;n;i++)printf("%d %d %d\n",Edge[i].x,Edge[i].y,Edge[i].z); &#125; else printf("-1");&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小割树</category>
      </categories>
      <tags>
        <tag>最小割树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ 5497 塔（哈希）]]></title>
    <url>%2F2018%2F03%2F15%2FJZOJ-5497-%E5%A1%94%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[塔- 问题描述 有一个塔,他的名字叫做粽粑,粽粑的每一层都有一个颜色 .粽粑非常厉害,它在吸收天地精华之后会长高.粽粑的长高方式有两种:1.在塔顶长出一层.2.在塔底长出一层,即原来的第一层变成第二层,第二层变成第三层,以此类推,新长出来的是第一层.粽粑有可能在某个时刻不是很开心,这个时候它会撤销它的前若干次长高.你现在想知道粽粑长高的奥秘,于是找到了粽粑,发现它的入口上写着这么一句话:要进入粽粑,请找出一段最长的塔的区间,满足翻转后颜色不变.粽粑会不断的长高（或撤销）,所以它每次长高（或撤销）后你都要回答.为了你的方便,粽粑一开始的高度为0。q&lt;=10^7 样例输入 7101102100299199198298 样例输出 25 题意让维护一个串的最长回文子串长度，并且要支持修改和撤销，并且强制在线。如果数据范围稍微小点，那么就是回文树裸题。但这题显然是故意要卡它。 注意到每次操作后，最长回文子串长度最多增加2，且一定包含操作的端点，那么可以用哈希来解决。 哈希的主要思想是记录从左到右的前缀哈希值，再记录从右到左的后缀哈希值，然后判断一个区间$[L,R]$是否回文的时候，只需要取出$[L,R]$的前缀哈希值和后缀哈希值比较一下即可。 至于撤销操作，只需要维护一个时间戳就行了，直接暴力撤销，复杂度是线性的。 代码实现的时候可以将在零点左边和右边的部分分开维护，分别记录一下$pow$递增和递减的哈希值，递减的用逆元处理。然后查询的时候再把左右两段拼接起来。具体可以参考代码。 复杂度$O(q)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 10000005#define ll long longusing namespace std;const int mod=998244353,p=131;int QM(int a,int b)&#123; int o=1; while(b) &#123; if(b&amp;1)o=1ll*o*a%mod; b&gt;&gt;=1;a=1ll*a*a%mod; &#125; return o;&#125;char s[3*N];ll Ans;int q,L,R,ans[N],T,ty[N];int La[N],Lb[N],Ra[N],Rb[N],Pow[N],Inv[N];bool JudgeL(int Le)&#123; if(L+R&lt;Le)return 0; if(Le&lt;=L) &#123; int a=1ll*(La[L]-La[L-Le]+mod)*Inv[L-Le+1]%mod; int b=1ll*(Lb[L]-Lb[L-Le]+mod)*Pow[L]%mod; return a==b; &#125; else &#123; int a=1ll*La[L]*Pow[Le-L-1]%mod+1ll*Rb[Le-L]*Pow[Le-L]%mod;a%=mod; int b=1ll*Lb[L]*Pow[L]%mod+1ll*Ra[Le-L]*Pow[L-1]%mod;b%=mod; return a==b; &#125;&#125;bool JudgeR(int Le)&#123; if(L+R&lt;Le)return 0; if(Le&lt;=R) &#123; int a=1ll*(Ra[R]-Ra[R-Le]+mod)*Inv[R-Le+1]%mod; int b=1ll*(Rb[R]-Rb[R-Le]+mod)*Pow[R]%mod; return a==b; &#125; else &#123; int a=1ll*Ra[R]*Pow[Le-R-1]%mod+1ll*Lb[Le-R]*Pow[Le-R]%mod;a%=mod; int b=1ll*Rb[R]*Pow[R]%mod+1ll*La[Le-R]*Pow[R-1]%mod;b%=mod; return a==b; &#125;&#125;void CalL()&#123; if(JudgeL(ans[T-1]+2))ans[T]=ans[T-1]+2; else if(JudgeL(ans[T-1]+1))ans[T]=ans[T-1]+1; else ans[T]=ans[T-1];&#125;void CalR()&#123; if(JudgeR(ans[T-1]+2))ans[T]=ans[T-1]+2; else if(JudgeR(ans[T-1]+1))ans[T]=ans[T-1]+1; else ans[T]=ans[T-1];&#125;int main()&#123; int i,j,k,num,Len;char a,b,c; scanf("%d\n",&amp;q); Pow[0]=Inv[0]=1;Inv[1]=QM(p,mod-2); for(i=1;i&lt;=q;i++)Pow[i]=1ll*Pow[i-1]*p%mod; for(i=2;i&lt;=q;i++)Inv[i]=1ll*Inv[i-1]*Inv[1]%mod; gets(s);Len=q*3; for(i=0;i&lt;Len;i+=3) &#123; a=s[i];b=s[i+1];c=s[i+2]; num=b-48;num=(num&lt;&lt;1)+(num&lt;&lt;3); num+=c-48; num+=ans[T];num%=100; if(a=='1') &#123; L++;ty[++T]=1; La[L]=(La[L-1]+1ll*num*Pow[L])%mod; Lb[L]=(Lb[L-1]+1ll*num*Inv[L])%mod; CalL(); &#125; else if(a=='2') &#123; R++;ty[++T]=2; Ra[R]=(Ra[R-1]+1ll*num*Pow[R])%mod; Rb[R]=(Rb[R-1]+1ll*num*Inv[R])%mod; CalR(); &#125; else while(num--)(ty[T--]==1)?(L--):(R--); Ans+=ans[T]; &#125; printf("%lld",Ans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code+三月月赛 Div1 D 白金元首与莫斯科（插头dp）]]></title>
    <url>%2F2018%2F03%2F15%2FCode-%E4%B8%89%E6%9C%88%E6%9C%88%E8%B5%9B-Div1-D-%E7%99%BD%E9%87%91%E5%85%83%E9%A6%96%E4%B8%8E%E8%8E%AB%E6%96%AF%E7%A7%91%EF%BC%88%E6%8F%92%E5%A4%B4dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[CODE+]白金元首与莫斯科题面 如果说障碍格子已经确定，那么可以用一个简单的插头dp算出方案数。那么可以暴力枚举障碍格子，但这样是$O(n^2m^22^m)$的。 注意到由于不确定的状态格子只有一个，因此可以从左上到右下dp一次，再从右下到左上dp一次，令两次的dp数组分别为$F1[i][j][S]$和$F2[i][j][S]$，那么当$(x,y)$为障碍时，答案就是$\sum F1[i][j-1][S1]\times F2[i][j+1][S2]$，$S1$和$S2$满足轮廓线上对应位置要么都有插头，要么都没有。如果在记录状态的时候都记录在当前坐标位置，那么就是$S1=S2$，注意到$(x,y)$这个点的上下左右四个方向都不能有插头。复杂度$O(nm2^m)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int mod=1e9+7;int n,m,map[20][20];int S,F1[20][20][1&lt;&lt;18],F2[20][20][1&lt;&lt;18],Ans[20][20];void add(int &amp;x,int y)&#123;x+=y;x-=x&gt;=mod?mod:0;&#125;int mul(int x,int y)&#123;return 1ll*x*y%mod;&#125;void PlugDP1()&#123; int l,u,*p,*q; F1[0][m][0]=1; for(register int i=1;i&lt;=n;i++) &#123; p=F1[i][0];q=F1[i-1][m]; for(register int j=0;j&lt;=(S&gt;&gt;1);j++)add(p[j&lt;&lt;1],q[j]); for(register int j=1;j&lt;=m;j++) &#123; p=F1[i][j];q=F1[i][j-1]; for(register int k=0;k&lt;=S;k++) if(q[k]) &#123; l=(k&gt;&gt;j-1)&amp;1;u=(k&gt;&gt;j)&amp;1; if(!map[i][j]) &#123; if(!l&amp;&amp;!u)add(p[k],q[k]); &#125; else &#123; if(!l&amp;&amp;!u) &#123; add(p[k],q[k]); if(map[i+1][j])add(p[k|(1&lt;&lt;j-1)],q[k]); if(map[i][j+1])add(p[k|(1&lt;&lt;j)],q[k]); &#125; else if(!l&amp;&amp;u)add(p[k^(1&lt;&lt;j)],q[k]); else if(l&amp;&amp;!u)add(p[k^(1&lt;&lt;j-1)],q[k]); &#125; &#125; &#125; &#125;&#125;void PlugDP2()&#123; int r,d,tmp,*p,*q; F2[n+1][1][0]=1; for(register int i=n;i&gt;=1;i--) &#123; p=F2[i][m+1];q=F2[i+1][1]; for(register int j=0;j&lt;=S;j++)add(p[j&gt;&gt;1],q[j]); for(register int j=m;j&gt;=1;j--) &#123; p=F2[i][j];q=F2[i][j+1]; for(register int k=0;k&lt;=S;k++) if(q[k]) &#123; r=(k&gt;&gt;j)&amp;1;d=(k&gt;&gt;j-1)&amp;1; if(!map[i][j]) &#123; if(!r&amp;&amp;!d)add(p[k],q[k]); &#125; else &#123; if(!r&amp;&amp;!d) &#123; add(p[k],q[k]); if(map[i-1][j])add(p[k|(1&lt;&lt;j)],q[k]); if(map[i][j-1])add(p[k|(1&lt;&lt;j-1)],q[k]); &#125; else if(r&amp;&amp;!d)add(p[k^(1&lt;&lt;j)],q[k]); else if(!r&amp;&amp;d)add(p[k^(1&lt;&lt;j-1)],q[k]); &#125; &#125; &#125; &#125;&#125;int main()&#123; int x,y,l,r,u,d,*p,*q; scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++)scanf("%d",&amp;map[i][j]),map[i][j]^=1; S=(1&lt;&lt;m+1)-1; PlugDP1();PlugDP2(); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++) &#123; if(!map[i][j])continue; p=F1[i][j-1];q=F2[i][j+1]; for(register int k=0;k&lt;=S;k++) if(p[k]&amp;&amp;q[k]) &#123; l=(k&gt;&gt;j-1)&amp;1;u=(k&gt;&gt;j)&amp;1; if(!l&amp;&amp;!u)add(Ans[i][j],mul(p[k],q[k])); &#125; &#125; for(register int i=1;i&lt;=n;i++,puts("")) for(register int j=1;j&lt;=m;j++)printf("%d ",Ans[i][j]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>插头dp</category>
      </categories>
      <tags>
        <tag>插头dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code+三月月赛 Div1 C 博弈论与与概率统计（莫队+组合数+数学期望）]]></title>
    <url>%2F2018%2F03%2F15%2FCode-%E4%B8%89%E6%9C%88%E6%9C%88%E8%B5%9B-Div1-C-%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E4%B8%8E%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%EF%BC%88%E8%8E%AB%E9%98%9F-%E7%BB%84%E5%90%88%E6%95%B0-%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[CODE+]博弈论与概率统计问题描述 样例输入 3 5001 12 34 4 样例输出 500000004200000002728571435 提示 首先，容易得到题目中的p是没有用的，因为Alice每一种输赢序列的出现概率是相等的，因此只需要算出每种排列的得分之和再除以$C_{n+m}^{n}$即可。 然后将赢记作1，输记作-1，那么得到一个序列$a_i$，对其求前缀和得到$b_i$观察可以发现，最终得分等于$\sum a_i-min(b_i)$，即$n-m-min(b_i)$那么最终答案等于$(n-m)C_{n+m}^{n}-\sum min(b_i)$ 考虑求后面的东西，令$F[k]$表示$b_i$的最小值恰为$k$的排列数，令$G[k]$表示$b_i$的最小值小于等于$k$的排列数考虑利用折线法来求得$G[k]$ 注意到最终的$b_{n+m}$一定是$n-m$，那么我们可以认为$a_i=1$表示从$(x,y)$走到$(x+1,y+1)$，而$a_i=-1$表示从$(x,y)$走到$(x+1,y-1)$，那么$a_i$序列就是从$(0,0)$走到$(n+m,n-m)$的一条折线。 考虑$b_i$的最小值小于等于$k$的意义，不妨令恰好取得最小值时，前面有$x$个$1$，$y$个$-1$，那么有$x-y&lt;=k$，反映到折线上就是这条折线至少有一个点的纵坐标小于等于$k$，也就是折线与$y=k$有交。 不妨将折线与$y=k$第一次相交后的部分沿$y=k$对称，对称前后的折线一一对应，那么对称后的折线终点是$(n+m,2k-n+m)$，那么此时对应的$a_i$中有$k+m$个1，$n-k$个-1，且这样的折线有$C_{n+m}^{m+k}$条，对应的$a_i$序列也就有这么多个。 因此我们得到$G[k]=C_{n+m}^{m+k}$，进一步的$F[k]=G[k]-G[k-1]=C_{n+m}^{m+k}-C_{n+m}^{m+k-1}$ 为了得到答案，我们考虑$min(b_i)$的取值范围容易得到$n&gt;=m时，min(b_i)\in[-m,0]$，当$n&lt;m时，min(b_i)\in[-m,n-m]$，因此需要分类讨论 先考虑$n&gt;=m$时，得到$Ans=(n-m)C_{n+m}^{n}-\sum_{k=-m}^{0}k(C_{n+m}^{m+k}-C_{n+m}^{m+k-1})$，推导一番$$Ans=(n-m)C_{n+m}^{n}+\sum_{k=0}^{m}k(C_{n+m}^{m-k}-C_{n+m}^{m-k-1})=(n-m)C_{n+m}^{n}+\sum_{k=0}^{m}kC_{n+m}^{m-k}-\sum_{k=0}^{m-1}kC_{n+m}^{m-1-k}$$ $$Ans=(n-m)C_{n+m}^{n}+\sum_{k=0}^{m-1}C_{n+m}^{m-1-k}=(n-m)C_{n+m}^{n}+\sum_{k=0}^{m-1}C_{n+m}^{k}$$ 我们发现是一个组合数前缀和的形式，不妨再看看$n&lt;m$时的情况。类似的处理$$Ans=(n-m)C_{n+m}^{n}-\sum_{k=-m}^{n-m}k(C_{n+m}^{m+k}-C_{n+m}^{m+k-1})=(n-m)C_{n+m}^{m}+\sum_{k=m-n}^{m}kC_{n+m}^{m-k}-\sum_{k=m-n}^{m-1}kC_{m+n}^{m-1-k}$$ $$Ans=(n-m)C_{n+m}^{n}+(m-n)C_{n+m}^{n}+\sum_{k=m-n}^{m-1}C_{n+m}^{m-1-k}=\sum_{k=0}^{n-1}C_{n+m}^{k}$$ 我们发现同样是一个组合数前缀和的形式，那么接下来考虑如何求组合数前缀和。注意到$$\sum_{k=0}^{m}C_{n+1}^{k}=\sum_{k=0}^{m}(C_{n}^{k}+C_{n}^{k-1})=2\sum_{k=0}^{m}C_{n}^{k}-C_{n}^{m}$$因此，如果我们已知$\sum_{k=0}^{m}C_{n}^{k}$，可以$O(1)$得到$\sum_{k=0}^{m}C_{n+1}^{k}$，反之亦然 因此我们可以用莫队算法来处理多次询问。总时间复杂度$O((N+M)\sqrt{N+M})$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 250005using namespace std;const int mod=1e9+7,inv2=1000000008&gt;&gt;1;int id[N],T,p,fac[N],inv[N],Ans;struct node&#123;int id,l,r;&#125;K[N],A[N];bool operator&lt;(node a,node b)&#123; if(id[a.l]==id[b.l])return a.r&lt;b.r; return id[a.l]&lt;id[b.l];&#125;void add(int &amp;x,int y)&#123;x+=y;x-=x&gt;=mod?mod:0;&#125;void sub(int &amp;x,int y)&#123;x-=y;x+=x&lt;0?mod:0;&#125;int mul(int x,int y)&#123;return 1ll*x*y%mod;&#125;int C(int n,int m)&#123; if(n&lt;m)return 0; return mul(fac[n],mul(inv[m],inv[n-m]));&#125;int inv_C(int n,int m)&#123; return mul(inv[n],mul(fac[m],fac[n-m]));&#125;void UD1(int n,int m)&#123; Ans=mul(Ans,2); sub(Ans,C(n,m));&#125;void UD2(int n,int m)&#123; add(Ans,C(n-1,m)); Ans=mul(Ans,inv2);&#125;void UD3(int n,int m)&#123; add(Ans,C(n,m+1));&#125;void UD4(int n,int m)&#123; sub(Ans,C(n,m));&#125;void Solve()&#123; int i,j,k,n,m,S=477; for(i=1;i&lt;N;i++)id[i]=i/S; sort(K+1,K+T+1); n=0;m=0;Ans=1; for(i=1;i&lt;=T;i++) &#123; while(n&lt;K[i].l)UD1(n++,m); while(n&gt;K[i].l)UD2(n--,m); while(m&lt;K[i].r)UD3(n,m++); while(m&gt;K[i].r)UD4(n,m--); add(A[K[i].id].id,Ans); &#125;&#125;int main()&#123; int i,j,k,n,m; fac[0]=fac[1]=inv[0]=inv[1]=1; for(i=2;i&lt;N;i++) &#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod%i],mod-mod/i); &#125; for(i=2;i&lt;N;i++)inv[i]=mul(inv[i],inv[i-1]); scanf("%d%d",&amp;T,&amp;p); for(i=1;i&lt;=T;i++) &#123; scanf("%d%d",&amp;n,&amp;m); A[i].l=n;A[i].r=m; if(n&gt;=m)A[i].id=mul(n-m,C(n+m,n)),K[i]=(node)&#123;i,n+m,m-1&#125;; else K[i]=(node)&#123;i,n+m,n-1&#125;; &#125; Solve(); for(i=1;i&lt;=T;i++) &#123; A[i].id=mul(A[i].id,inv_C(A[i].l+A[i].r,A[i].l)); printf("%d\n",A[i].id); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>分治法</category>
        <category>概率与期望</category>
        <category>莫队</category>
        <category>组合数</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>概率与期望</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4028（HZOI 2015）疯狂的机器人（NTT+卡特兰数）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4028%EF%BC%88HZOI-2015%EF%BC%89%E7%96%AF%E7%8B%82%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88NTT-%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4028[HZOI 2015]疯狂的机器人问题描述 现在在二维平面内原点上有一只机器人 他每次操作可以选择向右走，向左走，向下走，向上走和不走(每次如果走只能走一格） 但是由于本蒟蒻施展的大魔法，机器人不能走到横坐标是负数或者纵坐标是负数的点上 否则他就会big bang 给定操作次数n，求有多少种不同的操作序列使得机器人在操作后会回到原点 输出答案模998244353后的结果 注意如果两个操作序列存在某一时刻操作不同，则我们认为这两个操作序列不同 输入格式 输入n，表示操作次数 n&lt;=100000 输出格式 按要求输出答案 样例输入 3 样例输出 3 首先不考虑不走的情况，容易发现上下走和左右走是独立的，而只考虑上下走的话等价于一个进出栈序列，那么就是一个卡特兰数，因此我们令不考虑不走，走$2k$步的方案数为$G(2k)$，由于卡特兰数第k项为$\frac{C_{2k}^{k}}{k+1}$，容易得到$$G(2k)=\sum_{i=0}^{k}\frac{C_{2i}^{i}}{i+1}\times \frac{C_{2k-2i}^{k-i}}{k-i+1}\times C_{2k}^{2i}$$即枚举上下走的步数，然后排列一下。前两项分别表示上下走和左右走的方案数。然后打开组合数得到$$G(2k)=\sum_{i=0}^{k}\frac{(2i)!}{i!(i+1)!}\times \frac{(2k-2i)!}{(k-i)!(k-i+1)!}\times\frac{(2k)!}{(2i)!(2k-2i)!}$$化简一下得到$$G(2k)=(2k)!\sum_{i=0}^{k}\frac{1}{i!(i+1)!}\times\frac{1}{(k-i)!(k-i+1)!}$$容易发现这是个卷积，因此可以用NTT来加速。 然后考虑不走的情况，令最终方案数为$F(n)$，容易得到$$F(n)=\sum_{i=0}^{n}C_{n}^{i}\times G(n-i)$$这也是个卷积，但只需要算一项，那么直接暴力枚举就行了。也可以NTT。 总复杂度$O(n\log n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 400005using namespace std;const ll P=998244353LL,g=3;ll jc[N],inv[N],inv_jc[N],D[N];ll wi[N],A[N],B[N];ll QM(ll a,ll b)&#123; ll o=1;a%=P; while(b) &#123; if(b&amp;1)o=o*a%P; b&gt;&gt;=1;a=a*a%P; &#125; return o;&#125;void NTT(ll C[],ll n,ll ty)&#123; ll i,j,k,m,t0,t1; for(i=j=0;i&lt;n;i++) &#123; if(i&lt;j)swap(C[i],C[j]); for(k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1); &#125; wi[0]=1; for(m=1;m&lt;n;m&lt;&lt;=1) &#123; t0=QM(g,P-1+ty*(P-1)/(m&lt;&lt;1)); for(i=1;i&lt;m;i++)wi[i]=wi[i-1]*t0%P; for(k=0;k&lt;n;k+=m&lt;&lt;1) for(i=k;i&lt;k+m;i++) &#123; t0=C[i]; t1=C[i+m]*wi[i-k]%P; C[i]=t0+t1;C[i]-=C[i]&lt;P?0:P; C[i+m]=t0-t1;C[i+m]+=C[i+m]&lt;0?P:0; &#125; &#125; if(ty==1)return;t0=QM(n,P-2); for(i=0;i&lt;n;i++)C[i]=C[i]*t0%P;&#125;int main()&#123; ll n,i,j,k,L=1;inv[0]=jc[0]=inv[1]=jc[1]=inv_jc[0]=inv_jc[1]=A[0]=1; scanf("%lld",&amp;n);while(L&lt;=n+n)L&lt;&lt;=1; for(i=2;i&lt;=n+n;i++)inv[i]=(P-P/i)*inv[P%i]%P; for(i=2;i&lt;=n+n;i++)jc[i]=jc[i-1]*i%P; for(i=2;i&lt;=n+n;i++)inv_jc[i]=inv_jc[i-1]*inv[i]%P; for(i=0;i&lt;=n;i++)D[i]=inv_jc[i]*inv_jc[i]%P*inv[i+1]%P; NTT(D,L,1); for(i=0;i&lt;L;i++)D[i]=D[i]*D[i]%P; NTT(D,L,-1); for(i=0;i&lt;=n;i+=2)B[i]=jc[i]*D[i&gt;&gt;1]%P; for(i=1;i&lt;=n;i++)A[i]=A[i-1]*(n-i+1)%P*inv[i]%P; NTT(A,L,1);NTT(B,L,1); for(i=0;i&lt;L;i++)A[i]=B[i]*A[i]%P; NTT(A,L,-1); printf("%lld",(A[n]%P+P)%P);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>卡特兰数</category>
        <category>NTT</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ 5496 Tree（点分治+树形dp）]]></title>
    <url>%2F2018%2F03%2F15%2FJZOJ-5496-Tree%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB-%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Tree Description 从前有棵树。找出 k 个点 A 1 , A 2 , · · · , A k 。∑ k−1使得 i=1 dis(A i A i+1 ) 最小。 Input 第一行两个正整数 n, k, 表示数的顶点数和需要选出的点个数。接下来 n − 1 行每行 3 个非负整数 x, y, z, 表示从存在一条从 x 到 y 权值为 z 的边。1 ≤ k ≤ n。1 ≤ x, y ≤ n。1 ≤ z ≤ 10 5 。 Output 一行一个整数, 表示最小的距离和。 Scoring 对于 10% 的数据, n ≤ 10。对于另外 10% 的数据, k = n。对于另外 20% 的数据, n ≤ 50。对于另外 20% 的数据, n ≤ 200。对于 100% 的数据, n ≤ 3000。 标解是直接dp，但也可以点分治。首先注意到答案一定是一个树上联通块，那么点分治后只需要考虑包含根的联通块，那么转化成一个树形依赖dp。另外需要注意到最终的答案在点分治下，可以存在两条从根出发的链只走一次，其他的需要走两次。令$F[x][y][0/1]$表示以x为根，选y个点，是否存在从根出发只走一次的链，那么对于每个点$F[x][1][0]=2*d,F[x][1][1]=d$，d表示从他父亲到他的边长。有转移$$F[x][y+k][0]=min(F[son][k][0]+F[x][y][0])$$ $$F[x][y+k][1]=min(F[son][k][0]+F[x][y][1],F[son][k][1]+F[x][y][0]-d)$$ 最后在根节点做一次背包，$G[x][k]$表示选了$x$个点，其中有$k$条只走一次的链$k=0,1,2$，这个直接背包就行。最后答案取$min(G[m][0],G[m][1],G[m][2])$ 复杂度很玄学，不知道。但跑得飞快。 这道题最关键的地方是，dp跑for循环的时候,一定只枚举子树size的前缀和，并且不要写$F[x][y-k]$，$F[x][y+k]$要快的多。具体可以看代码的注释 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 3005using namespace std;int n,m,Min,rt,Ans,si[N],F[N][2][N],G[3][N];bool mark[N];int TOT,LA[N],NE[N&lt;&lt;1],EN[N&lt;&lt;1],LE[N&lt;&lt;1];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Gsi(int x,int f)&#123; int i,y;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Gsi(y,x);si[x]+=si[y]; &#125;&#125;void Grt(int x,int s,int f)&#123; int i,y,Max=s-si[x]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Grt(y,s,x);Max=max(Max,si[y]); &#125; if(Max&lt;Min)Min=Max,rt=x;&#125;void DP(int x,int d,int f)&#123; int i,j,k,y,sum=1; fill(F[x][0],F[x][0]+si[x]+1,1e9); fill(F[x][1],F[x][1]+si[x]+1,1e9); F[x][0][1]=2*d;F[x][1][1]=d; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y]||y==f)continue; DP(y,LE[i],x); if(sum&gt;m)sum=m; for(j=sum;j&gt;=1;j--)//跑得慢的写法是for(j=sum+si[y];j&gt;=2;j--)F[x][1][j-k]=min() for(k=1;k&lt;=si[y];k++) &#123; F[x][1][j+k]=min(F[x][1][j+k],F[x][0][j]+F[y][1][k]-d); F[x][1][j+k]=min(F[x][1][j+k],F[x][1][j]+F[y][0][k]); &#125; for(j=sum;j&gt;=1;j--)//同理 for(k=1;k&lt;=si[y];k++)F[x][0][j+k]=min(F[x][0][j+k],F[x][0][j]+F[y][0][k]); sum+=si[y]; &#125;&#125;void Gans(int x)&#123; int i,j,k,p,y,sum=1; memset(G,60,sizeof(G)); G[0][1]=G[1][1]=G[2][1]=0;Gsi(x,0); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y])continue; DP(y,LE[i],x); if(sum&gt;m)sum=m; for(k=sum;k&gt;=1;k--)//同理 for(p=1;p&lt;=si[y];p++) &#123; G[2][k+p]=min(G[2][k+p],G[1][k]+F[y][1][p]); G[2][k+p]=min(G[2][k+p],G[2][k]+F[y][0][p]); &#125; for(k=sum;k&gt;=1;k--)//同理 for(p=1;p&lt;=si[y];p++) &#123; G[1][k+p]=min(G[1][k+p],G[0][k]+F[y][1][p]); G[1][k+p]=min(G[1][k+p],G[1][k]+F[y][0][p]); &#125; for(k=sum;k&gt;=1;k--)//同理 for(p=1;p&lt;=si[y];p++)G[0][k+p]=min(G[0][k+p],G[0][k]+F[y][0][p]); sum+=si[y]; &#125; Ans=min(Ans,G[0][m]); Ans=min(Ans,G[1][m]); Ans=min(Ans,G[2][m]);&#125;void DC(int x)&#123; int i,y;mark[x]=1; Gans(x); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y])continue; Min=1e9;Gsi(y,x); Grt(y,si[y],x);DC(rt); &#125;&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; Ans=1e9; Min=1e9;Gsi(1,0);Grt(1,n,0);DC(rt); printf("%d",Ans);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>分治法</category>
        <category>树形dp</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4022（HEOI 2015）最短不公共子串（后缀自动机+序列自动机+dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4022%EF%BC%88HEOI-2015%EF%BC%89%E6%9C%80%E7%9F%AD%E4%B8%8D%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4022 [HEOI2015]最短不公共子串问题描述 在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。 一个串的“子串”指的是它的连续的一段，例如bcd是abcdef的子串，但bde不是。 一个串的“子序列”指的是它的可以不连续的一段，例如bde是abcdef的子串，但bdd不是。 下面，给两个小写字母串A，B，请你计算： (1) A的一个最短的子串，它不是B的子串 (2) A的一个最短的子串，它不是B的子序列 (3) A的一个最短的子序列，它不是B的子串 (4) A的一个最短的子序列，它不是B的子序列 输入格式 有两行，每行一个小写字母组成的字符串，分别代表A和B。 输出格式 输出4行，每行一个整数，表示以上4个问题的答案的长度。如果没有符合要求的答案，输出-1. 样例输入 aabbccabcabc 样例输出 2424 提示 对于100%的数据，A和B的长度都不超过2000 此题涉及到子串和子序列，考虑后缀自动机和序列自动机。那么此题就是在两个自动机上dp。对于第一问，令$F1[x][y]$表示从A的后缀自动机上x节点，B的后缀自动机上y节点出发的最短不公共子串长度，那么当$x\neq0,y=0$时$F1[x][y]=0$，然后直接在两个自动机上转移就行了，$F1[x][y]=min(F1[tx][ty]+1)$对于第二问，在A的后缀自动机和B的序列自动机上同样dp即可。对于第三问，在A的序列自动机和B的后缀自动机上同样dp即可。对于第四问，在A的序列自动机和B的序列自动机上同样dp即可。 复杂度$O(26n^2)?$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 4005using namespace std;struct PAM&#123; int tot,rt,las[26],pre[N],son[N][26]; PAM() &#123; tot=rt=1; for(int i=0;i&lt;26;i++)las[i]=1; &#125; void Ins(int c) &#123; tot++;pre[tot]=las[c]; for(int i=0;i&lt;26;i++) for(int j=las[i];j&amp;&amp;!son[j][c];j=pre[j])son[j][c]=tot; las[c]=tot; &#125;&#125;PA,PB;struct SAM&#123; int rt,tot,las,son[N][26],Max[N],pra[N]; SAM()&#123;tot=las=rt=1;&#125; int NP(int x) &#123; Max[++tot]=x; return tot; &#125; void Ins(int t) &#123; int p=las,q,np,nq; np=NP(Max[p]+1); while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p]; if(!p)pra[np]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); pra[nq]=pra[q]; pra[q]=pra[np]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p]; &#125; &#125; las=np; &#125;&#125;SA,SB;char s1[N],s2[N];int n,m,ans;int F1[N][N],F2[N][N&gt;&gt;1],F3[N&gt;&gt;1][N],F4[N&gt;&gt;1][N&gt;&gt;1];int DFS1(int x,int y)&#123; if(x&amp;&amp;y==0)return 0; if(!x||!y)return 1e9; if(F1[x][y]!=-1)return F1[x][y]; F1[x][y]=1e9; for(int i=0;i&lt;26;i++)F1[x][y]=min(F1[x][y],DFS1(SA.son[x][i],SB.son[y][i])+1); return F1[x][y];&#125;int DFS2(int x,int y)&#123; if(x&amp;&amp;y==0)return 0; if(!x||!y)return 1e9; if(F2[x][y]!=-1)return F2[x][y]; F2[x][y]=1e9; for(int i=0;i&lt;26;i++)F2[x][y]=min(F2[x][y],DFS2(SA.son[x][i],PB.son[y][i])+1); return F2[x][y];&#125;int DFS3(int x,int y)&#123; if(x&amp;&amp;y==0)return 0; if(!x||!y)return 1e9; if(F3[x][y]!=-1)return F3[x][y]; F3[x][y]=1e9; for(int i=0;i&lt;26;i++)F3[x][y]=min(F3[x][y],DFS3(PA.son[x][i],SB.son[y][i])+1); return F3[x][y];&#125;int DFS4(int x,int y)&#123; if(x&amp;&amp;y==0)return 0; if(!x||!y)return 1e9; if(F4[x][y]!=-1)return F4[x][y]; F4[x][y]=1e9; for(int i=0;i&lt;26;i++)F4[x][y]=min(F4[x][y],DFS4(PA.son[x][i],PB.son[y][i])+1); return F4[x][y];&#125;int main()&#123; scanf("%s%s",&amp;s1[1],&amp;s2[1]); s1[0]=s2[0]='%'; n=strlen(s1)-1; m=strlen(s2)-1; for(int i=1;i&lt;=n;i++)PA.Ins(s1[i]-'a'),SA.Ins(s1[i]-'a'); for(int i=1;i&lt;=m;i++)PB.Ins(s2[i]-'a'),SB.Ins(s2[i]-'a'); memset(F1,-1,sizeof(F1)); memset(F2,-1,sizeof(F2)); memset(F3,-1,sizeof(F3)); memset(F4,-1,sizeof(F4)); ans=DFS1(1,1);printf("%d\n",ans==1e9?-1:ans); ans=DFS2(1,1);printf("%d\n",ans==1e9?-1:ans); ans=DFS3(1,1);printf("%d\n",ans==1e9?-1:ans); ans=DFS4(1,1);printf("%d\n",ans==1e9?-1:ans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>后缀自动机</category>
        <category>序列自动机</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>后缀自动机</tag>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 HN Training 7.7 C （线段树）]]></title>
    <url>%2F2018%2F03%2F15%2F2015-HN-Training-7-7-C-%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C-问题描述 样例输入 40 0 R0 1 B1 1 R1 0 B 样例输出 2 提示 先考虑如果平行线恰好平行于y轴的情况，那么只需要按照x轴排序后求出最长连续R串即可。注意到如果有点在直线上，那么是可以通过微小扰动来解决的，因此一定合法。 然后考虑一般情况，我们考虑平行线来旋转，等价于坐标系旋转，那么两个点的位置位置关系发生改变当且仅当当前的平行线与两点确定的直线平行，因此只需要求出任意两点连线的斜率，然后排序后逐一改变位置关系同时维护最大连续R串即可，这个可以用线段树来维护，注意更新答案当且仅当同一斜率的直线全部更新完。 总时间复杂度$O(n^2\log n)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 1000005using namespace std;const double eps=1e-12;struct node&#123;double x,y;int ty,id;&#125;P[1005];struct nodd&#123;int x,y;double k;&#125;L[N];bool cmp1(node a,node b)&#123;return a.x&lt;b.x;&#125;bool cmp2(nodd a,nodd b)&#123;return a.k&lt;b.k;&#125;bool cmp3(node a,node b)&#123;return a.id&lt;b.id;&#125;int n,pos[1005],cnt;int ls[N],rs[N],Max[N],Lmax[N],Rmax[N],Sum[N],tot;double Get(int i,int j)&#123; if(P[i].x==P[j].x)return 1e12; else return (P[j].y-P[i].y)/(P[j].x-P[i].x);&#125;void MT(int p)&#123; int l=ls[p],r=rs[p]; if(Lmax[l]==Sum[l])Lmax[p]=Sum[l]+Lmax[r]; else Lmax[p]=Lmax[l]; if(Rmax[r]==Sum[r])Rmax[p]=Sum[r]+Rmax[l]; else Rmax[p]=Rmax[r]; Max[p]=max(Rmax[l]+Lmax[r],max(Max[l],Max[r]));&#125;int BT(int l,int r)&#123; int p=++tot;Sum[p]=r-l+1; if(l==r)return Max[p]=Lmax[p]=Rmax[p]=P[l].ty,p; int mid=l+r&gt;&gt;1; ls[p]=BT(l,mid); rs[p]=BT(mid+1,r); return MT(p),p;&#125;void MD(int p,int l,int r,int k)&#123; if(l==r) &#123; Max[p]^=1; Lmax[p]^=1; Rmax[p]^=1; return; &#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)MD(ls[p],l,mid,k); else MD(rs[p],mid+1,r,k); MT(p);&#125;int main()&#123; int i,j,k,x,y,Ans;char c; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%lf%lf %c",&amp;P[i].x,&amp;P[i].y,&amp;c); P[i].ty=(c=='R')?1:0;P[i].id=i; &#125; for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++)L[++cnt]=(nodd)&#123;i,j,Get(i,j)&#125;; sort(P+1,P+n+1,cmp1); sort(L+1,L+cnt+1,cmp2); for(i=1;i&lt;=n;i++)pos[P[i].id]=i; BT(1,n);Ans=Max[1]; sort(P+1,P+n+1,cmp3); for(i=1;i&lt;=cnt;i++) &#123; x=L[i].x;y=L[i].y; swap(pos[x],pos[y]); if(P[x].ty==P[y].ty)continue; MD(1,1,n,pos[x]); MD(1,1,n,pos[y]); if(L[i+1].k-L[i].k&gt;eps||i==cnt)Ans=max(Ans,Max[1]); &#125; printf("%d",Ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 HN Training 7.7 B（AC自动机）]]></title>
    <url>%2F2018%2F03%2F15%2F2015-HN-Training-7-7-B%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[B问题描述 样例输入3 10ATTTAAAAA3 10ATTTTAAAAA 样例输出 NoYes 提示 构造一个串不含某些给定串，考虑将给定串构造AC自动机，并将其改造成有限状态自动机（每个点不存在的转移改成fail树上第一个该转移），将串结尾的标记沿着fail树传上去，然后如果自动机的转移中存在环，那么一定有解，否则该图为DAG，求出从根节点出发的最长路（不能经过串结尾），最长路长度就是能构造出串的最大长度。复杂度$O(\sum |s|)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define ll long long#define N 1200005using namespace std;char s[N];ll m,Max,dep[N];int n,son[N][2],fail[N],exi[N],tot,rt;bool Instack[N],mark[N];void Ins()&#123; int i,p=rt,t,l=strlen(s); for(i=0;i&lt;l;i++) &#123; t=s[i]=='A'?0:1; if(!son[p][t])son[p][t]=++tot; p=son[p][t]; &#125; exi[p]=1;&#125;void Build()&#123; int i,p=rt;queue&lt;int&gt;Q; for(i=0;i&lt;2;i++) if(son[p][i])fail[son[p][i]]=p,Q.push(son[p][i]); else son[p][i]=p; while(Q.size()) &#123; p=Q.front();Q.pop(); for(i=0;i&lt;2;i++) if(son[p][i]) &#123; fail[son[p][i]]=son[fail[p]][i];Q.push(son[p][i]); exi[son[p][i]]|=exi[fail[son[p][i]]]; &#125; else son[p][i]=son[fail[p]][i]; &#125;&#125;bool DFS(int x)&#123; Instack[x]=1;mark[x]=1;dep[x]=0; for(int i=0;i&lt;2;i++) &#123; int p=son[x][i]; if(exi[p])continue; if(Instack[p])return 1; if(!mark[p]&amp;&amp;DFS(p))return 1; dep[x]=max(dep[x],dep[p]+1); &#125; Max=max(Max,dep[x]); Instack[x]=0;return 0;&#125;int main()&#123; int i,j,k,x,y; while(scanf("%d%lld",&amp;n,&amp;m)!=EOF) &#123; tot=rt=1;Max=0; memset(son,0,sizeof(son)); memset(fail,0,sizeof(fail)); memset(exi,0,sizeof(exi)); memset(mark,0,sizeof(mark)); memset(Instack,0,sizeof(Instack)); for(i=1;i&lt;=n;i++)scanf("\n%s",s),Ins(); Build();Max=0; if(DFS(rt))puts("Yes"); else if(Max&gt;=m)puts("Yes"); else puts("No"); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3984 （WC 2010）重建计划（二分答案+点分治+单调dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3984-%EF%BC%88WC-2010%EF%BC%89%E9%87%8D%E5%BB%BA%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E7%82%B9%E5%88%86%E6%B2%BB-%E5%8D%95%E8%B0%83dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3984[WC2010]重建计划问题描述 输入格式 第一行包含一个正整数N，表示X国的城市个数.第二行包含两个正整数L和U，表示政策要求的第一期重建方案中修建道路数的上下限接下来的N-1行描述重建小组的原有方案，每行三个正整数Ai,Bi,Vi分别表示道路(Ai,Bi),其价值为Vi 其中城市由1..N进行标号 输出格式 输出最大平均估值，保留三位小数 样例输入 1 42 31 2 11 3 21 4 3 样例输出 1 2.500 样例输入 2 123 51 2 8042241 3 6456172 4 7639312 6 7441332 8 5348244 5 1633186 7 4211586 10 7731676 11 3805988 9 6398369 12 261707 样例输出 2 773841.333 提示 20%的数据,N&lt;=500030%的数据,N&lt;=100000,原有方案恰好为一条路径100%的数据,N&lt;=100000,1&lt;=L&lt;=U&lt;=N-1,Vi&lt;=1000000 题目中要求的东西带了个平均值，不好处理，考虑二分答案，然后将每条边权减去mid，那么原题变成求是否存在一条长度在$[L,R]$之间，且权值和$&gt;=0$的路径。 树上路径问题，考虑点分治，考虑过分治中心的路径，按子树顺序讨论，记录$F[d]$表示当前子树之前的子树深度为$d$的最大路径的权，$G[d]$表示当前子树深度为$d$的路径的最大权，那么可以dp，从小到大枚举d，用$G[d]$与$F[L-d]-F[R-d]$来更新答案，显然可以用单调队列来优化。dp完了之后用$G$更新$F$，继续讨论下一棵子树。 这里理论上需要将子树按照最大深度排序来保证复杂度。具体不好说。 另外需要加上一些剪枝，即当前子树点数小于L就不用分治下去了。另外，最好每层点分治单独二分，这样会跑得比较快。但是我就是在外面二分，这样就需要加上一些其他优化才能卡过了，比如找到答案就不继续分治，预处理点分治树而不要每次都重新建立点分治树之类。 总时间复杂度$O(n\log^2n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;#include&lt;vector&gt;#define N 200005using namespace std;deque&lt;int&gt;Q;double Lim;int n,L,R;int TOT,LA[N],NE[N],EN[N];double LE[N],F[2][N];int Min,rt,Rt,si[N],Md;bool mark[N];vector&lt;int&gt;to[N],son[N];void ADD(int x,int y,double z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Gsi(int x,int f)&#123; int i,y;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y]||y==f)continue; Gsi(y,x);si[x]+=si[y]; &#125;&#125;void Grt(int x,int s,int f)&#123; int i,y,Max=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Grt(y,s,x); if(si[y]&gt;Max)Max=si[y]; &#125; if(s-si[x]&gt;Max)Max=s-si[x]; if(Max&lt;Min)Min=Max,rt=x;&#125;void Gdis(int x,double s,int d,int f,int ty)&#123; if(d&gt;R)return; F[ty][d]=max(F[ty][d],s);Md=max(Md,d); for(int i=LA[x];i;i=NE[i]) if(EN[i]!=f&amp;&amp;!mark[EN[i]])Gdis(EN[i],s+LE[i]-Lim,d+1,x,ty);&#125;bool MT(int a,int b)&#123; int i,j,l=a; Q.clear(); for(i=1;i&lt;=b;i++) &#123; while(l&gt;=0&amp;&amp;i+l&gt;=L) &#123; while(Q.size()&amp;&amp;F[0][Q.back()]&lt;=F[0][l])Q.pop_back(); Q.push_back(l);l--; &#125; while(Q.size()&amp;&amp;i+Q.front()&gt;R)Q.pop_front(); if(Q.size()&amp;&amp;F[1][i]+F[0][Q.front()]&gt;=0)return 1; &#125; return 0;&#125;void PreDC(int x)&#123; int i,y;mark[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y])continue; Min=1e9;Gsi(y,0);Grt(y,si[y],0); si[rt]=si[y]; to[x].push_back(rt); PreDC(rt); &#125;&#125;bool DC(int x)&#123; int i,j,y,las;las=Md=0;mark[x]=1; if(si[x]&lt;L)return 0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y])continue; las=max(las,Md);Md=0; Gdis(y,LE[i]-Lim,1,x,1); if(MT(las,Md))return Md=max(Md,las),1; Gdis(y,LE[i]-Lim,1,x,0); for(j=0;j&lt;=Md;j++)F[1][j]=-1e9; &#125; for(i=1;i&lt;=las||i&lt;=Md;i++)F[0][i]=-1e9; for(i=0;i&lt;to[x].size();i++) &#123; y=to[x][i]; if(DC(y))return 1; &#125; return 0;&#125;bool ok(double mid)&#123; Lim=mid; if(!Md)Md=1e5; memset(mark,0,sizeof(mark)); for(int i=1;i&lt;=Md;i++)F[0][i]=F[1][i]=-1e9; if(DC(Rt))return 1; return 0;&#125;void EF(double l,double r)&#123; double mid; while(r-l&gt;=0.0001) &#123; mid=(l+r)/2; if(ok(mid))l=mid; else r=mid; &#125; printf("%.3lf",(l+r)/2);&#125;int main_main()&#123; int i,j,k,x,y,z,Max=0; scanf("%d%d%d",&amp;n,&amp;L,&amp;R); for(i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,1.0*z);ADD(y,x,1.0*z);Max=max(Max,z); &#125; Min=1e9;Gsi(1,0);Grt(1,n,0); si[rt]=n;Rt=rt;PreDC(rt); EF(double(0),double(Max));&#125;const int main_stack=16;char my_stack[128&lt;&lt;20];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>分治法</category>
        <category>一般dp</category>
        <category>二分答案</category>
        <category>点分治</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
        <tag>单调性</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3967 （SCOI 2007）最大土地面积（旋转卡壳）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3967-%EF%BC%88SCOI-2007%EF%BC%89%E6%9C%80%E5%A4%A7%E5%9C%9F%E5%9C%B0%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3967【SCOI2007】最大土地面积问题描述 在某块平面土地上有N个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。 输入格式 在某块平面土地上有N个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。 输出格式 最大的多边形面积，答案精确到小数点后3位。 样例输入 50 01 01 10 10.5 0.5 样例输出 1.000 提示 n&lt;=2000, |x|,|y|&lt;=100000 首先，面积最大的点一定在凸包上，因此先求出凸包，然后在凸包上搞。求四边形面积不方便，容易想到拆成两个三角形，因此可以枚举对角线，然后分别求出对角线两侧的最大三角形面积。这里可以在凸包上二分。但是注意到当对角线一端固定，另一端向一个方向移动时，最大三角形面积的位置也是单调的。因为相当于是用平行于当前对角线的直线去与凸包求切点，所以可以旋转卡壳，跟着转就行了。最好直接用面积判断是否需要移动。总复杂度$O(n^2)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 3005using namespace std;double eps=1e-9;struct node&#123; double x,y; bool operator&lt;(const node &amp;b)const &#123; if(x==b.x)return y&gt;b.y; return x&lt;b.x; &#125; double operator*(const node &amp;b)const &#123;return x*b.y-y*b.x;&#125; node operator-(const node &amp;b)const &#123;return (node)&#123;x-b.x,y-b.y&#125;;&#125;&#125;P[N],S[N];int n,top;double Lmax[N],Rmax[N],ans;int main()&#123; int i,j,k; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;P[i].x,&amp;P[i].y); sort(P+1,P+n+1); for(i=1;i&lt;=n;i++) &#123; while(top&gt;1&amp;&amp;(S[top-1]-S[top])*(S[top-1]-P[i])&lt;eps)top--; S[++top]=P[i]; &#125; k=--top; for(i=n;i&gt;=1;i--) &#123; while(top&gt;k+1&amp;&amp;(S[top-1]-S[top])*(S[top-1]-P[i])&lt;eps)top--; S[++top]=P[i]; &#125; for(i=1;i&lt;top;i++) &#123; k=i+1; for(j=i+2;j&lt;top-1;j++) &#123; while(fabs((S[k]-S[j])*(S[k]-S[i]))&lt;fabs((S[k+1]-S[j])*(S[k+1]-S[i])))k++; Lmax[j]=fabs((S[k]-S[j])*(S[k]-S[i])); &#125; k=top-1; for(j=top-2;j&gt;i+1;j--) &#123; while(fabs((S[k]-S[i])*(S[k]-S[j]))&lt;fabs((S[k-1]-S[i])*(S[k-1]-S[j])))k--; Rmax[j]=fabs((S[k]-S[i])*(S[k]-S[j])); &#125; for(j=i+2;j&lt;top-1;j++)ans=max(ans,Lmax[j]+Rmax[j]); &#125; printf("%.3lf",0.5*ans);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>旋转卡壳</category>
      </categories>
      <tags>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3966 （ZJOI 2008）瞭望塔（半平面交/模拟退火）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3966-%EF%BC%88ZJOI-2008%EF%BC%89%E7%9E%AD%E6%9C%9B%E5%A1%94%EF%BC%88%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3966【ZJOI2008】瞭望塔问题描述 致力于建设全国示范和谐小村庄的H村村长dadzhi，决定在村中建立一个瞭望塔，以此加强村中的治安。 我们将H村抽象为一维的轮廓。如下图所示 我们可以用一条山的上方轮廓折线(x1, y1), (x2, y2), …. (xn, yn)来描述H村的形状，这里x1 &lt; x2 &lt; …&lt; xn。瞭望塔可以建造在[x1, xn]间的任意位置, 但必须满足从瞭望塔的顶端可以看到H村的任意位置。可见在不同的位置建造瞭望塔，所需要建造的高度是不同的。为了节省开支，dadzhi村长希望建造的塔高度尽可能小。 请你写一个程序，帮助dadzhi村长计算塔的最小高度。 输入格式 第一行包含一个整数n，表示轮廓折线的节点数目。接下来第一行n个整数, 为x1 ~ xn.第三行n个整数，为y1 ~ yn。 输出格式 仅包含一个实数，为塔的最小高度，精确到小数点后三位。 样例输入 1 61 2 4 5 6 71 2 2 4 2 1 样例输出 1 1.000 样例输入 2 410 20 49 590 10 10 0 样例输出 2 14.500 提示 对于60%的数据， N ≤ 60；对于100%的数据， N ≤ 300，输入坐标绝对值不超过106，注意考虑实数误差带来的问题。 此题显然是要把轮廓线上每一条直线拿出来做半平面交得到一个下凸壳，然后找两条轮廓上同一x坐标竖直距离最近的两个点，由于上下都是直线，那么显然只可能在端点取到，因此只需要枚举每一个端点即可。 另外，本题可以直接模拟退火+爬山，只需要调好参数即可，算上方凸壳的y坐标只需要取每条直线的y坐标最小值。需要注意的是，最好在退火结束的位置多爬几次山，减小精度误差。 代码（半平面交）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;struct node&#123;double x,y;&#125;Point[N],Line[N],S[N],T[N];int n,top;bool operator&lt;(node a,node b)&#123; if(a.x==b.x)return a.y&gt;b.y; return a.x&lt;b.x;&#125;node Cal(node a,node b)&#123; double k=(b.y-a.y)/(b.x-a.x); double t=b.y-k*b.x; return (node)&#123;k,t&#125;;&#125;node Intersection(node a,node b)&#123; double x=(b.y-a.y)/(a.x-b.x); return (node)&#123;x,b.x*x+b.y&#125;;&#125;bool judge(node p,node l)&#123; double y=l.x*p.x+l.y; return p.y&lt;y;&#125;void Halfplane()&#123; int i,j; for(i=1;i&lt;n;i++) &#123; if(Line[i].x==Line[i-1].x)continue; while(top&gt;1&amp;&amp;judge(Intersection(S[top],S[top-1]),Line[i]))top--; S[++top]=Line[i]; &#125;&#125;int main()&#123; int i,j;double ans=1e10; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lf",&amp;Point[i].x); for(i=1;i&lt;=n;i++)scanf("%lf",&amp;Point[i].y); for(i=1;i&lt;n;i++)Line[i]=Cal(Point[i],Point[i+1]); sort(Line+1,Line+n); Halfplane(); for(i=1;i&lt;top;i++)T[i]=Intersection(S[i],S[i+1]); for(i=1;i&lt;n;i++)Line[i]=Cal(Point[i],Point[i+1]); Point[n+1].x=1e10; for(i=1,j=1;i&lt;top;i++) &#123; while(T[i].x&gt;=Point[j].x)j++; ans=min(ans,T[i].y-(Line[j-1].x*T[i].x+Line[j-1].y)); &#125; T[top].x=1e10; for(i=1,j=1;i&lt;=n;i++) &#123; while(Point[i].x&gt;=T[j].x)j++; ans=min(ans,S[j].x*Point[i].x+S[j].y-Point[i].y); &#125; printf("%.3lf",ans);&#125; 代码（模拟退火）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#define N 505using namespace std;struct node&#123;double x1,x2,k,b;&#125;L[N];int n,X[N],Y[N];double ans=1e20,Now,New;double Rand()&#123;return rand()%10000/10000.0;&#125;node GetLine(int x1,int y1,int x2,int y2)&#123; double lx=1.0*x1,rx=1.0*x2; double ly=1.0*y1,ry=1.0*y2; double k=(ry-ly)/(rx-lx); double b=ry-k*rx; return (node)&#123;lx,rx,k,b&#125;;&#125;double f(int p,double x)&#123;return L[p].k*x+L[p].b;&#125;double F(double x)&#123; if(x&lt;X[1]||x&gt;X[n])return 1e20; double y,Max=-1e20; for(int i=1;i&lt;n;i++) &#123; y=f(i,x); Max=max(Max,y); &#125; for(int i=1;i&lt;n;i++) if(x&gt;=L[i].x1&amp;&amp;x&lt;=L[i].x2) &#123; Max=Max-f(i,x); break; &#125; if(ans&gt;Max)ans=Max; return Max;&#125;void SA(double T)&#123; Now=X[1]+rand()%(X[n]-X[1]); while(T&gt;0.0001) &#123; New=Now+T*(2*Rand()-1); double d=F(Now)-F(New); if(d&gt;0||exp(d/T)&gt;Rand())Now=New; T*=0.9; &#125; for(int i=1;i&lt;=500;i++) &#123; New=Now+T*(2*Rand()-1); if(F(New)&lt;F(Now))Now=New; &#125;&#125;int main()&#123; srand(19260817); int i,j,k,x,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;X[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;Y[i]); for(i=1;i&lt;n;i++)L[i]=GetLine(X[i],Y[i],X[i+1],Y[i+1]); for(i=1;i&lt;=50;i++)SA(2000000); printf("%.3lf",ans);&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>半平面交</category>
        <category>近似算法</category>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>半平面交</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3961 zMy的lcm （Pollard_Rho+欧拉函数+高精度）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3961-zMy%E7%9A%84lcm-%EF%BC%88Pollard-Rho-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3961zMy的lcm问题描述 首先注意到，题目中的异或是不存在的，因为出题人懒得写高精度异或。先推导一番$$Ans=\sum_{i=1}^{n}lcm(n,i)=n\sum_{i=1}^{n}\frac{i}{gcd(n,i)}=n\sum_{d|n}\sum_{i=1}^{n}\frac{i}{d}[gcd(n,i)==d]=n\sum_{d|n}\sum_{i=1}^{\frac{n}{d}}i[gcd(\frac{n}{d},i)==1]$$这里用到一个公式，$\sum_{i=1}^{n}i[gcd(n,i)==1]=\frac{n\varphi(n)}{2}$关于证明，考虑到如果$gcd(i,n)=1$，那么$gcd(n-i,n)=1$，由此得证。 因此$$Ans=\frac{n}{2}\sum_{d|n}\frac{n}{d}\varphi(\frac{n}{d})=\frac{n}{2}\sum_{d|n}d\varphi(d)，令f(n)=\sum_{d|n}d\varphi(d)$$考虑如何求$f(n)$，观察发现，$f(n)$可能是积性函数，尝试证明一下。 $$f(a)=\sum_{i|a}i\varphi(i)，f(b)=\sum_{j|b}j\varphi(j)，gcd(a,b)=1$$ $$那么显然f(ab)=\sum_{i|a}\sum_{j|b}ij\varphi(ij)=\sum_{i|a}\sum_{j|b}ij\varphi(i)\varphi(j)=\sum_{i|a}i\varphi(i)\sum_{j|b}j\varphi(j)=f(a)f(b)$$ 因此可以分解质因数后求$f(n)$，只需要考虑求$f(p^k)$，推导一下容易发现$f(p^k)=\frac{p^{2k}-1}{p+1}p+1$ 因此只需要用$Pollard\ Rho$求质因数分解，然后高精度算一算就行了。总复杂度$O(Tn^{\frac{1}{4}}+高精度复杂度)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#define ll long longusing namespace std;const ll mod=1e9;struct Big&#123; ll cur,S[500]; void Output() &#123; printf("%lld",S[cur]); ll i,k; for(i=cur-1;i&gt;=0;i--) &#123; k=mod/10; while(k&gt;S[i])putchar('0'),k/=10; if(k)printf("%lld",S[i]); &#125; &#125; void add(ll k) &#123; S[0]+=k;ll i=0; while(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i++]%=mod,cur=max(i,cur); while(S[cur+1])cur++; &#125; void Add(const Big&amp; o) &#123; ll i,r=max(o.cur,cur); for(i=0;i&lt;=r;i++) &#123; S[i]+=o.S[i]; if(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i]%=mod; &#125; cur=r+5;while(cur&amp;&amp;S[cur]==0)cur--; &#125; void multiply(ll k) &#123; for(ll i=0;i&lt;=cur;i++)S[i]*=k; for(ll i=0;i&lt;cur;i++)if(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i]%=mod; while(S[cur]&gt;=mod)S[cur+1]+=S[cur]/mod,S[cur]%=mod,cur++; &#125; void Multiply(const Big o,Big&amp; E) &#123; ll i,j;memset(&amp;E,0,sizeof(E)); for(i=0;i&lt;=cur;i++) for(j=0;j&lt;=o.cur;j++) &#123; E.S[i+j]+=S[i]*o.S[j]; if(E.S[i+j]&gt;=mod)E.S[i+j+1]+=E.S[i+j]/mod,E.S[i+j]%=mod; &#125; E.cur=cur+o.cur+5;while(E.cur&gt;0&amp;&amp;E.S[E.cur]==0)E.cur--; &#125; void divide(ll k) &#123; for(ll i=cur;i&gt;0;i--) &#123; S[i-1]+=S[i]%k*mod;S[i]/=k; if(S[cur]==0)cur--; &#125; S[0]/=k; &#125; void operator=(const Big&amp; B) &#123; memset(S,0,sizeof(S));cur=B.cur; for(ll i=cur;i&gt;=0;i--)S[i]=B.S[i]; &#125;&#125;Ans,A,B,D,Zero;ll T,P[5]=&#123;2,3,5,7,11&#125;,C[233],tot;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;ll QC(ll a,ll b,ll c)&#123; ll o=0;a%=c; while(b) &#123; if(b&amp;1)o+=a,o-=o&gt;=c?c:0; b&gt;&gt;=1;a+=a;a-=a&gt;=c?c:0; &#125; return o;&#125;ll QM(ll a,ll b,ll c)&#123; ll o=1; while(b) &#123; if(b&amp;1)o=QC(o,a,c); b&gt;&gt;=1;a=QC(a,a,c); &#125; return o;&#125;ll QQ(ll a,ll b)&#123; ll o=1; while(b) &#123; if(b&amp;1)o*=a; b&gt;&gt;=1;a*=a; &#125; return o;&#125;bool MR(ll x)&#123; if(!x&amp;1)return x==2; if(x==1)return 0; ll i,j,k,p,t=0,m,pre; m=x-1;while(!m&amp;1)m&gt;&gt;=1,t++; for(i=0;i&lt;5;i++) &#123; p=P[i];if(x%p==0)return x==p; p=QM(p,m,x); if(p==1)continue; for(j=1;j&lt;=t;j++) &#123; pre=p;p=QC(p,p,x); if(p==1) &#123; if(pre!=1&amp;&amp;pre!=x-1)return 0; break; &#125; &#125; if(p!=1)return 0; &#125; return 1;&#125;void RHO(ll x)&#123; if(MR(x))&#123;C[++tot]=x;return;&#125; ll i,k,a,b,c,t; while(1) &#123; i=1;k=2; a=b=1ll*rand()*rand()%x; c=1ll*rand()*rand()%x; while(i++) &#123; b=(QC(b,b,x)+c)%x; if(a==b)break; t=gcd(a&gt;b?a-b:b-a,x); if(t!=1)&#123;RHO(t);RHO(x/t);return;&#125; if(i==k)k&lt;&lt;=1,a=b; &#125; &#125;&#125;int main()&#123; srand(time(NULL)); ll i,j,tmp;ll n; scanf("%lld",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); if(n==1)&#123;printf("1\n");continue;&#125; Ans=Zero;Ans.add(1ll); tot=0;RHO(n); sort(C+1,C+tot+1); for(i=1;i&lt;=tot;i=j) &#123; j=i+1;while(j&lt;=tot&amp;&amp;C[j]==C[i])j++; tmp=QQ(C[i],j-i); if(j-i&gt;1) &#123; A=Zero;B=Zero; A.add(tmp+1); B.add(tmp-1); A.Multiply(B,D); D.multiply(C[i]); D.divide(C[i]+1); D.add(1); Ans.Multiply(D,B); Ans=B; &#125; else &#123; A=Zero;B=Zero; A.add(tmp); B.add(tmp-1); A.Multiply(B,D); D.add(1); Ans.Multiply(D,B); Ans=B; &#125; &#125; A=Zero; A.add(n); Ans.divide(2); Ans.Multiply(A,B); B.add(n); B.Output();putchar('\n'); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高精度</category>
        <category>Pollard_Rho</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>Pollard_Rho</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3957 （BZOJ 2820）YY的GCD （莫比乌斯反演+线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3957-%EF%BC%88BZOJ-2820%EF%BC%89YY%E7%9A%84GCD-%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3957YY的GCD问题描述 神犇YY虐完数论后给傻×kAc出了一题给定N, M,求1&lt;=x&lt;=N, 1&lt;=y&lt;=M且gcd(x, y)为质数的(x, y)有多少对kAc这种傻×必然不会了，于是向你来请教…… 输入格式 第一行一个整数T 表述数据组数 接下来T行，每行两个正整数，表示N, M 输出格式 T行，每行一个整数表示第i组数据的结果 样例输入 210 10100 100 样例输出 302791 提示 T = 10000 N, M &lt;= 10000000 显然$Ans=\sum_{p}^{min(n,m)}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==p]，p为质数$$$令f(p)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==p],F(p)=\sum_{i=1}^{n}\sum_{j=1}^{m}[p|gcd(i,j)]$$ $$令N=min(n,m)，那么F(p)=\sum_{p|k}^{N}f(k)=\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor$$ $$反演一下，f(p)=\sum_{p|k}^{N}\mu(\frac{k}{p})F(k)=\sum_{p|k}^{N}\mu(\frac{k}{p})\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$$ $$那么Ans=\sum_{p}^{N}f(p)=\sum_{p}^{N}\sum_{p|k}^{N}\mu(\frac{k}{p})\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$$ 如果是单组询问，到这里已经可以了，但本题有多组询问，因此$$交换一下枚举顺序，Ans=\sum_{k=1}^{N}\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor\sum_{p|k}\mu(\frac{k}{p})，p为质数$$后面的部分可以直接枚举质数再枚举倍数预处理，复杂度接近 $O(n)​$ 但显然可以线性筛处理，令其为 $g[i]$ ，当 $p[j]|i$ 时， $g[i\times p[j]]=\mu(i)$，否则 $g[i\times p[j]]=mu[i]-g[i]$ 然后分块处理即可，复杂度$O(n+T\sqrt{n})​$ 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 10000005#define ll long longusing namespace std;ll T,P[N],tot,mu[N],g[N];bool mark[N];void EU()&#123; ll i,j;mu[1]=1;g[1]=0; for(i=2;i&lt;N;i++) &#123; if(!mark[i])P[++tot]=i,mu[i]=-1,g[i]=1; for(j=1;j&lt;=tot&amp;&amp;i*P[j]&lt;N;j++) if(i%P[j])mu[i*P[j]]=-mu[i],g[i*P[j]]=mu[i]-g[i],mark[i*P[j]]=1; else &#123;mu[i*P[j]]=0;g[i*P[j]]=mu[i];mark[i*P[j]]=1;break;&#125; &#125; for(i=2;i&lt;N;i++)g[i]+=g[i-1];&#125;int main()&#123; ll n,m,i,j,ans; scanf("%lld",&amp;T);EU(); while(T--) &#123; scanf("%lld%lld",&amp;n,&amp;m);ans=0; for(i=1;i&lt;=n&amp;&amp;i&lt;=m;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); ans+=(n/i)*(m/i)*(g[j]-g[i-1]); &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3941 （HNOI 2014）世界树（虚树+树形dp+倍增）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3941-%EF%BC%88HNOI-2014%EF%BC%89%E4%B8%96%E7%95%8C%E6%A0%91%EF%BC%88%E8%99%9A%E6%A0%91-%E6%A0%91%E5%BD%A2dp-%E5%80%8D%E5%A2%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3941[Hnoi2014]世界树问题描述 世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 输入格式 第一行为一个正整数n，表示世界树中种族的个数。接下来n-l行，每行两个正整数x，y，表示x聚居地与y聚居地之间有一条长度为1的双向道路。接下来一行为一个正整数q，表示国王询问的年数。接下来q块，每块两行：第i块的第一行为1个正整数m[i]，表示第i年授权的临时议事处的个数。第i块的第二行为m[i]个正整数h[l]、h[2]、…、h[m[i]]，表示被授权为临时议事处的聚居地编号（保证互不相同）。 输出格式 输出包含q行，第i行为m[i]个整数，该行的第j(j=1，2…，，m[i])个数表示第i年被授权的聚居地h[j]的临时议事处管理的种族个数。 样例输入 102 13 24 35 4 6 17 38 39 410 15 26 152 7 3 6 91 848 7 10 352 9 3 5 8 样例输出 1 93 1 4 1 1101 1 3 54 1 3 1 1 提示 N&lt;=300000, q&lt;=300000,m[1]+m[2]+…+m[q]&lt;=300000 注意到多次询问的点总数和n同阶，考虑虚树。构建好虚树后，在虚树上做两次树dp，算出到每个点距离最近的关键点，然后统计答案。注意到有些点不在虚树中，但也要统计答案，这些点可以分成两类，一类是在虚树中两点之间的点，一类是虚树中点的（不在虚树中的）子树中的点。对于第二类点，可以在虚树上用原size减去在虚树中的子树的size，注意这里的size需要倍增找到该点在原树中的儿子。对于第一类点，可以枚举一条虚树中的边，然后在边上倍增找到中点，然后将两段的size分别加到两端的最近点上。总时间复杂度$O(n\log n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 600005using namespace std;int n,q,P[N],ans[N],Q[N],top,cnt,PP[N];int dfn[N],VT,F[N],G[N],Sum[N],Size[N];bool mark[N];int dep[N],fa[N][20],S=19;int TOT,LA[N],NE[N],EN[N];int tot,la[N],ne[N],st[N],en[N],le[N];bool cmp(int x,int y)&#123;return dfn[x]&lt;dfn[y];&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void add(int x,int y,int z)&#123; tot++; st[tot]=x; en[tot]=y; le[tot]=z; ne[tot]=la[x]; la[x]=tot;&#125;void DFS(int x,int f)&#123; int i,y; Size[x]=1; dfn[x]=++VT; fa[x][0]=f; dep[x]=dep[f]+1; for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)DFS(y,x),Size[x]+=Size[y]; &#125;&#125;int LCA(int x,int y)&#123; if(!x||!y)return 0; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=fa[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void BT()&#123; int i,lca; if(!mark[1])Q[++top]=1; for(i=1;i&lt;=cnt;i++) &#123; lca=LCA(P[i],Q[top]); if(lca==Q[top])&#123;Q[++top]=P[i];continue;&#125; while(dep[lca]&lt;dep[Q[top-1]]) &#123; add(Q[top-1],Q[top],dep[Q[top]]-dep[Q[top-1]]); top--; &#125; add(lca,Q[top],dep[Q[top]]-dep[lca]); if(lca!=Q[--top])Q[++top]=lca; Q[++top]=P[i]; &#125; while(--top)add(Q[top],Q[top+1],dep[Q[top+1]]-dep[Q[top]]);&#125;int Gsi(int x,int f)&#123; int i; for(i=S;i&gt;=0;i--)if(dep[fa[x][i]]&gt;dep[f])x=fa[x][i]; return Size[x];&#125;void DP1(int x)&#123; int i,y;F[x]=G[x]=1e9;Sum[x]=Size[x]; if(mark[x])F[x]=0,G[x]=x; for(i=la[x];i;i=ne[i]) &#123; y=en[i];DP1(y);Sum[x]-=Gsi(y,x); if(F[y]+le[i]&lt;F[x])F[x]=F[y]+le[i],G[x]=G[y]; else if(F[y]+le[i]==F[x]&amp;&amp;G[y]&lt;G[x])G[x]=G[y]; &#125;&#125;void DP3(int x,int d,int f)&#123; if(x!=1) &#123; if(F[x]&gt;F[f]+d)F[x]=F[f]+d,G[x]=G[f]; else if(F[x]==F[f]+d&amp;&amp;G[x]&gt;G[f])G[x]=G[f]; &#125; for(int i=la[x];i;i=ne[i])DP3(en[i],le[i],x);&#125;void DP2(int x)&#123; ans[G[x]]+=Sum[x]; for(int i=la[x];i;i=ne[i])DP2(en[i]); la[x]=mark[x]=0;&#125;int Gans(int x,int t)&#123; int sum=0,i; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)sum+=Size[fa[x][i]]-Size[x],x=fa[x][i]; return sum;&#125;int main_main()&#123; int i,j,k,x,y,d; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; DFS(1,0); scanf("%d",&amp;q); for(i=1;i&lt;=q;i++) &#123; scanf("%d",&amp;cnt); for(j=1;j&lt;=cnt;j++)scanf("%d",&amp;P[j]),mark[P[j]]=1,PP[j]=P[j]; sort(P+1,P+cnt+1,cmp);tot=0; BT();DP1(1);DP3(1,0,0);DP2(1); for(j=1;j&lt;=tot;j++) &#123; if(le[j]==1)continue; x=st[j];y=en[j]; if(dep[x]&lt;dep[y])swap(x,y); if(G[x]==G[y])ans[G[x]]+=Gans(x,dep[x]-dep[y]-1); else &#123; k=le[j]-1-(F[x]-F[y]); d=Gans(x,(k&gt;&gt;1)+(G[x]&lt;G[y]?k&amp;1:0)); ans[G[x]]+=d; ans[G[y]]+=Gans(x,dep[x]-dep[y]-1)-d; &#125; &#125; for(j=1;j&lt;=cnt;j++)printf("%d ",ans[PP[j]]),ans[PP[j]]=0; puts(""); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>分治法</category>
        <category>树形dp</category>
        <category>虚树</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>倍增</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3933 贝壳串（CDQ分治+FFT）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3933-%E8%B4%9D%E5%A3%B3%E4%B8%B2%EF%BC%88CDQ%E5%88%86%E6%B2%BB-FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3933贝壳串问题描述 海边市场有长度分别为1到n的贝壳串出售，其中长度为i的贝壳串有a[i]种，每种贝壳串有无限个，问用这些贝壳串链接成长度为n的串有多少种方案? 输入格式 第一行，一整数n，第二行，n个整数ai表示长度为i的贝壳串的种类数(n&lt;=10^5,0&lt;=ai&lt;=10^7) 输出格式 输出方案数，结果模313 样例输入 1 31 3 7 样例输出 1 14 样例输入 2 42 2 2 2 样例输出 2 54 dp方程比较显然，令$F[i]$表示组成长度为i的串的方案数，那么$F[i]=\sum_{k=0}^{i}A[k]\times F[i-k]$直接递推是$n^2$的，但是我们注意到这个转移式子是一个卷积，那么可以用$FFT$来加速，但直接$FFT$显然非常不优秀，需要用到$CDQ$来解决。 假设要算$F[l]-F[r]$的dp值，那么可以先处理出$F[l]-F[mid]$的dp值，然后做一个卷积算出$F[l]-F[mid]$对$F[mid+1]-F[r]$的贡献，这里用$FFT$处理，然后递归计算$F[mid+1]-F[r]$的dp值。 由于每次做$FFT$的长度是和区间长度相关的，因此总时间复杂度$O(n\log ^2n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;complex&gt;#define N 500000using namespace std;const int mod=313;const double pi=4.0*atan(1.0);int F[N],a[N];complex&lt;double&gt;A[N],B[N],C[N],D[N],wi[N];void FFT(complex&lt;double&gt;W[],int n,int ty)&#123; int i,j,k,m; complex&lt;double&gt;t0,t1; for(i=j=0;i&lt;n;i++) &#123; if(i&lt;j)swap(W[i],W[j]); for(k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1); &#125; wi[0]=1; for(m=1;m&lt;n;m&lt;&lt;=1) &#123; t0=exp(complex&lt;double&gt;(0,ty*pi/m)); for(i=1;i&lt;m;i++)wi[i]=wi[i-1]*t0; for(k=0;k&lt;n;k+=m&lt;&lt;1) for(i=k;i&lt;k+m;i++) &#123; t0=W[i]; t1=W[i+m]*wi[i-k]; W[i]=t0+t1; W[i+m]=t0-t1; &#125; &#125; if(ty==1)return;t0=1.0/n; for(i=0;i&lt;n;i++)W[i]*=t0;&#125;void CDQ(int l,int r)&#123; int n=1,i,j,k,mid=l+r&gt;&gt;1,l1,l2; if(l==r)return; CDQ(l,mid); l1=mid-l+1;l2=r-mid; while(n&lt;=l1+l2)n&lt;&lt;=1; fill(A,A+n+n,0); fill(B,B+n+n,0); for(i=l;i&lt;=mid;i++)A[i-l]=F[i]; for(i=0;i&lt;=r-l;i++)B[i]=a[i]; FFT(A,n,1);FFT(B,n,1); for(i=0;i&lt;n;i++)A[i]=A[i]*B[i]; FFT(A,n,-1); for(i=mid+1;i&lt;=r;i++)F[i]+=floor(A[i-l].real()+0.5),F[i]%=mod; CDQ(mid+1,r);&#125;int main()&#123; int i,x,n; scanf("%d",&amp;n);F[0]=1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),a[i]%=mod; CDQ(0,n); printf("%d",(F[n]+mod)%mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>分治法</category>
        <category>CDQ分治</category>
        <category>FFT</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3932 Meteors （整体二分+树状数组）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3932-Meteors-%EF%BC%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ P3932Meteors问题描述 Byteotian Interstellar Union有N个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为M份（第M份和第1份相邻），第i份上有第Ai个国家的太空站。 这个星球经常会下陨石雨。BIU已经预测了接下来K场陨石雨的情况。 BIU的第i个成员国希望能够收集Pi单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。 输入格式 输入： 第一行是两个数N,M。第二行有M个数，第i个数Oi表示第i段轨道上有第Oi个国家的太空站。第三行有N个数，第i个数Pi表示第i个国家希望收集的陨石数量。第四行有一个数K，表示BIU预测了接下来的K场陨石雨。接下来K行，每行有三个数Li,Ri,Ai，表示第K场陨石雨的发生地点在从Li顺时针到Ri的区间中（如果Li&lt;=Ri，就是Li,Li+1,…,Ri，否则就是Ri,Ri+1,…,m-1,m,1,…,Li），向区间中的每个太空站提供Ai单位的陨石样本。 输出格式 输出： N行。第i行的数Wi表示第i个国家在第Wi波陨石雨之后能够收集到足够的陨石样本。如果到第K波结束后仍然收集不到，输出NIE。 样例输入 3 51 3 2 1 310 5 734 2 41 3 13 5 2 样例输出 3NIE1 提示 1&lt;=n,m,k&lt;=3*10^5 1&lt;=Pi&lt;=10^9 1&lt;=Ai&lt;10^9 如果只有一个国家，那么显然的二分答案，复杂度$O(m\log k+k\log m)$，用线段树或树状差分数组来维护每个太空站的情况，每次二分后只把两次二分区间的差的区间信息进行修改，最多修改k次。 考虑多个国家的情况，仍然暴力枚举每个国家的话，复杂度是$O(m\log k+nk\log m)$，考虑优化，这时注意到枚举每个国家时要维护的线段树其实是一样的，而主要的时间花费恰好是维护这个线段树，因此可以考虑整体二分，同样二分答案，每次判断每个国家的答案区间，将答案区间在$[l,mid]$的国家甩到$Q_1$里面，把答案区间在$[mid+1,r]$的甩到$Q_2$中，对$Q_1$递归求解，同时回溯的时候还原线段树，然后对$Q_2$递归求解，在底层的时候就算出了答案。这样就只需要维护全局线段树，而不需要每次二分答案都重新维护线段树。 总时间复杂度$O(m\log k \log m+k\log k\log m)$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 400005#define ll long longusing namespace std;struct node&#123; ll v; vector&lt;ll&gt;p;&#125;C[N];ll cur,id[N],Q1[N],Q2[N],n,m,q,L[N],R[N],A[N],D[N],Ans[N];void MD(ll x,ll d)&#123;for(ll i=x;i&lt;=m;i+=(i&amp;-i))D[i]+=d;&#125;ll GS(ll x)&#123; ll i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=D[i]; return sum;&#125;void CA(ll k,ll ty)&#123; if(L[k]&lt;=R[k])MD(L[k],A[k]*ty),MD(R[k]+1,-A[k]*ty); else MD(L[k],A[k]*ty),MD(1,A[k]*ty),MD(R[k]+1,-A[k]*ty);&#125;void Solve(ll l,ll r,ll sl,ll sr)&#123; ll i,j,k,x,y,mid=sl+sr&gt;&gt;1; if(sl==sr) &#123; for(i=l;i&lt;=r;i++)if(Ans[id[i]]!=-1)Ans[id[i]]=sl; return; &#125; while(cur&lt;mid)CA(++cur,1); while(cur&gt;mid)CA(cur--,-1); x=y=0; for(i=l;i&lt;=r;i++) &#123; k=0; for(j=0;j&lt;C[id[i]].p.size();j++) &#123; k+=GS(C[id[i]].p[j]); if(k&gt;=C[id[i]].v)break; &#125; if(k&gt;=C[id[i]].v)Q1[++x]=id[i]; else Q2[++y]=id[i]; &#125; for(i=1;i&lt;=x;i++)id[l+i-1]=Q1[i]; for(i=1;i&lt;=y;i++)id[r-i+1]=Q2[y-i+1]; Solve(l,r-y,sl,mid); Solve(l+x,r,mid+1,sr);&#125;int main()&#123; ll i,j,k,x,y,z; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%lld",&amp;x); C[x].p.push_back(i); &#125; for(i=1;i&lt;=n;i++)scanf("%lld",&amp;C[i].v),id[i]=i; scanf("%lld",&amp;q); for(i=1;i&lt;=q;i++)scanf("%lld%lld%lld",&amp;L[i],&amp;R[i],&amp;A[i]); Solve(1,n,1,q+1); for(i=1;i&lt;=n;i++) if(Ans[i]==q+1)puts("NIE"); else printf("%lld\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>分治法</category>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3579 （NOI 2010）海拔（平面图最小割+对偶图）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3579-%EF%BC%88NOI-2010%EF%BC%89%E6%B5%B7%E6%8B%94%EF%BC%88%E5%B9%B3%E9%9D%A2%E5%9B%BE%E6%9C%80%E5%B0%8F%E5%89%B2-%E5%AF%B9%E5%81%B6%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3579【NOI2010】海拔问题描述 YT市是一个规划良好的城市，城市被东西向和南北向的主干道划分为n×n个区域。简单起见，可以将YT市看作一个正方形，每一个区域也可看作一个正方形。从而，YT城市中包括(n+1)×(n+1)个交叉路口和2n×(n+1)条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。下图为一张YT市的地图(n = 2)，城市被划分为2×2个区域，包括3×3个交叉路口和12条双向道路。 小Z作为该市的市长，他根据统计信息得到了每天上班高峰期间YT市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数。每一个交叉路口都有不同的海拔高度值，YT市市民认为爬坡是一件非常累的事情，每向上爬h的高度，就需要消耗h的体力。如果是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为h(注意h可能是负数)，那么一个人经过这段路所消耗的体力是max{0, h}（这里max{a, b}表示取a, b两个值中的较大值）。小Z还测量得到这个城市西北角的交叉路口海拔为0，东南角的交叉路口海拔为1(如上图所示)，但其它交叉路口的海拔高度都无法得知。小Z想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡所消耗的总体力和的最小值。 输入格式 第一行包含一个整数n，含义如上文所示。 接下来4n(n + 1)行，每行包含一个非负整数分别表示每一条道路每一个方向的人流量信息。输入顺序：n(n + 1)个数表示所有从西到东方向的人流量，然后n(n + 1)个数表示所有从北到南方向的人流量，n(n + 1)个数表示所有从东到西方向的人流量，最后是n(n + 1)个数表示所有从南到北方向的人流量。对于每一个方向，输入顺序按照起点由北向南，若南北方向相同时由西到东的顺序给出(参见样例输入)。 输出格式 仅包含一个数，表示在最理想情况下每天上班高峰期间所有人爬坡所消耗的总体力和（即总体力和的最小值），结果四舍五入到整数。 样例输入 112345678 样例输出 3 样例说明 样例数据见下图。最理想情况下所有点的海拔如上图所示。对于20%的数据：n ≤ 3；对于50%的数据：n ≤ 15；对于80%的数据：n ≤ 40；对于100%的数据：1 ≤ n ≤ 500，0 ≤ 流量 ≤ 1,000,000且所有流量均为整数。 拿到这题感觉很吓人，每个点海拔还能是分数，但是有一点比较显然，那就是任意点的海拔都在$[0,1]$之间。进一步的，感觉似乎每个点的海拔都应该是整数，那么不妨假设每个点海拔都是${0,1}$之一，不妨来验证一下。假设有三个点$A,B,C$存在$A-&gt;B-&gt;C$的路径，那么对于$A-&gt;C$人，体力消耗等于$|A-C|$，对于$A-&gt;B$，消耗为$sum_{A-B}|A-B|$，对于$B-&gt;C$，消耗为$sum_{B-C}|B-C|$,我们发现，最优情况下$B$的海拔总是要等于$A$的海拔或者$C$的海拔。由于原图中给定了两个点的海拔，那么图中每个点的海拔必然是$0$或$1$ 再进一步观察，最优情况下必然$0$和$1$构成了两个联通块，他们之间有一条分界线，而最终的总体力消耗就是从0走到1的人的体力消耗之和。即分界线上有向流量之和。这个根据上面所说的就比较显然了。 因此一个直接的想法是以左上角为源点，以右下角为汇点跑一个最小割，这个最小割就是答案。但直接这么做复杂度是$n^6$级别的，肯定过不了。 平面图最小割可以转化成对偶图最短路，所以这题直接转化成对偶图求最短路，建对偶图的时候由于是有向边，因此要特别注意连边的方向，这个画个图手算一下就能看出来。 关于平面图最小割转化成对偶图最短路，只需要连接源点和汇点将原来无界的一个面拆成两个，形成一个额外的面，然后原图的面当成点，相邻的面之间连边，边权等于两个面的公共边的容量。然后删掉直接无界面和额外面之间的边。具体可以百度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 505#define M 5000000using namespace std;typedef pair&lt;int,int&gt; par;int n,S,T,WE[N][N],EW[N][N],NS[N][N],SN[N][N];int TOT,LA[N*N],NE[M],EN[M],LE[M];int dis[N*N];priority_queue&lt;par&gt;Q;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int Gid(int x,int y)&#123; if(x==0||y==n+1)return S; if(x==n+1||y==0)return T; return (x-1)*n+y;&#125;void Dijkstra(int s)&#123; int i,x,y,d;par t; memset(dis,60,sizeof(dis)); dis[s]=0;Q.push(par(0,s)); while(Q.size()) &#123; t=Q.top();Q.pop(); x=t.second; d=-t.first; if(dis[x]!=d)continue; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(dis[y]&gt;d+LE[i]) &#123; dis[y]=d+LE[i]; Q.push(par(-dis[y],y)); &#125; &#125; &#125;&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d",&amp;n);S=n*n+1;T=S+1; for(i=1;i&lt;=n+1;i++) for(j=1;j&lt;=n;j++)scanf("%d",&amp;x),ADD(Gid(i-1,j),Gid(i,j),x); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n+1;j++)scanf("%d",&amp;x),ADD(Gid(i,j),Gid(i,j-1),x); for(i=1;i&lt;=n+1;i++) for(j=1;j&lt;=n;j++)scanf("%d",&amp;x),ADD(Gid(i,j),Gid(i-1,j),x); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n+1;j++)scanf("%d",&amp;x),ADD(Gid(i,j-1),Gid(i,j),x); Dijkstra(S); printf("%lld",dis[T]);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
        <category>对偶图</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4128 （JSOI 2016）独特的树叶（树哈希）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4128-%EF%BC%88JSOI-2016%EF%BC%89%E7%8B%AC%E7%89%B9%E7%9A%84%E6%A0%91%E5%8F%B6%EF%BC%88%E6%A0%91%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4128[Jsoi2016]独特的树叶问题描述 JYY有两棵树A和B：树A有N个点，编号为1到N；树B有N+1个点，编号为1到N+1。JYY知道树B恰好是由树A加上一个叶 节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树B中的哪一个叶节点呢？ 输入格式 输入一行包含一个正整数N。 接下来N-1行，描述树A，每行包含两个整数表示树A中的一条边； 接下来N行，描述树B，每行包含两个整数表示树B中的一条边。 1≤N≤10^5 输出格式 输出一行一个整数，表示树B中相比树A多余的那个叶子的编号。如果有多个符合要求的叶子，输出B中编号最小的那一个的编号。 样例输入 51 22 31 41 51 22 33 44 53 6 样例输出 1 这道题用树哈希来处理比较方便。先将树A以每个点作为根的哈希值都算出来存到一个set中，然后将树B去掉一个叶子节点后算出哈希值，再在set中查找。如果直接算n次哈希会超时，需要用到递推求哈希值。 这里为了方便递推，我用的哈希函数是$父节点Hash=(Hash[son_1]+p)\bigoplus (Hash[son_2]+p)\bigoplus……+size*q+1$ 那么递推的方式就比较显然了，具体可以参见代码。只需要做一次树dp就可以求出以每个点为根的哈希值。 至于树B去掉一个叶子后的哈希值，事实上也可以同样的递推，只需要在处理到叶子节点的父节点时算一下以他为根，且去掉这个叶子的哈希值然后在set中查找即可。 用unordered_set可以做到近似$O(n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;unordered_set&gt;#define ll long long#define N 200005using namespace std;const ll p=1e9+7;unordered_set&lt;ll&gt;Q;ll Hash[N];int n,D[N],si[N],Ans=1e9;int TOT,LA[N],NE[N],EN[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Ghash(int x,int f)&#123; int i,y;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; Ghash(y,x);si[x]+=si[y]; Hash[x]=Hash[x]^Hash[y]+17; &#125; Hash[x]+=si[x]*p+1;&#125;void DFS1(int x,int f)&#123; int i,y;Q.insert(Hash[x]); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; ll tmp=(Hash[x]-si[x]*p-1)^(Hash[y]+17); tmp+=(n-si[y])*p+1; Hash[y]-=si[y]*p+1; Hash[y]^=tmp+17; Hash[y]+=n*p+1; si[y]=n;DFS1(y,x); &#125;&#125;void DFS2(int x,int f)&#123; int i,y; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(y==f)continue; if(D[y]&gt;1) &#123; ll tmp=(Hash[x]-si[x]*p-1)^(Hash[y]+17); tmp+=(si[x]-si[y])*p+1; Hash[y]-=si[y]*p+1; Hash[y]^=tmp+17; Hash[y]+=si[x]*p+1; si[y]=si[x];DFS2(y,x); &#125; else &#123; ll tmp=(Hash[x]-si[x]*p-1)^(Hash[y]+17); tmp+=(si[x]-si[y])*p+1; if(Q.count(tmp))Ans=min(Ans,y); &#125; &#125;&#125;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; Ghash(1,0);DFS1(1,0);TOT=0; memset(LA,0,sizeof(LA)); memset(Hash,0,sizeof(Hash)); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); D[x]++;D[y]++; ADD(x,y);ADD(y,x); &#125; for(x=1;x&lt;=n;x++)if(D[x]&gt;1)break; Ghash(x,0);DFS2(x,0); printf("%d",Ans);&#125;]]></content>
      <categories>
        <category>杂学</category>
        <category>树哈希</category>
      </categories>
      <tags>
        <tag>树哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3652 shallot （线性基+CDQ分治）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3652-shallot-%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9F%BA-CDQ%E5%88%86%E6%B2%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3652 shallot问题描述 小苗去市场上买了一捆小葱苗，她突然一时兴起，于是她在每颗小葱苗上写上一个数字，然后把小葱叫过来玩游戏。每个时刻她会给小葱一颗小葱苗或者是从小葱手里拿走一颗小葱苗，并且让小葱从自己手中的小葱苗里选出一些小葱苗使得选出的小葱苗上的数字的异或和最大。这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？你只需要输出最大的异或和即可，若小葱手中没有小葱苗则输出嬰。 输入格式 输入第一行一个正整数T，表示测试数据组数。对于每组数据，第一行两个正整数n表示总时间；第二行n个整数a1; a2; …; an，若ai大于0代表给了小葱一颗数字为ai的小葱苗，否则代表从小葱手中拿走一颗数字为ai的小葱苗。 输出格式 输出共n行，每行一个整数代表第i个时刻的最大异或和 样例输入 61 2 3 4 -2 -3 样例输出 133775 提示 n&lt;=500000,ai&lt;=2^31-1 求从一些数中选取若干个的最大异或和，可以用线性基来做，求出这些数的一组基即可知道答案。 但是线性基只支持插入而不支持删除，因此采用CDQ分治来维护。预处理出每个数存在的区间$[L,R]$，对时间分治，每次将存在区间与分治子区间无交的数字插入到子区间的线性基中。底层的线性基就是$[L,L]$时刻的答案。 实际实现时，对于每个添加，找到它对应的删除位置，同样对每个删除找到对应的添加位置，然后将在左子区间添加且删除位置在右区间右边的数插入到右区间，将在右区间删除且添加位置在左区间左边的数插入到左区间，然后递归处理。 并不需要每个区间都维护一个线性基，而只需要每一层分治维护一个线性基，回溯的时候将上一层的copy到下一层再插入即可。 时间复杂度$O(n log^2n)$ 事实上也可以预处理完了之后直接用线段树维护每个位置的线性基，同样只有插入操作，复杂度也一样。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define N 543210using namespace std;struct node&#123; int cnt,c[32]; void Ins(int x) &#123; for(int i=1;i&lt;=cnt;i++) if((x^c[i])&lt;x)x^=c[i]; if(x)c[++cnt]=x; &#125; int Gans() &#123; int sum=0; for(int i=1;i&lt;=cnt;i++) if((sum^c[i])&gt;sum)sum^=c[i]; return sum; &#125;&#125;;int n,a[N],ST[N],EN[N],ans[N];node s[99];map&lt;int,int&gt;fa,ct;void CDQ(int l,int r,int x)&#123; if(l==r) &#123; if(a[l]&gt;0)s[x].Ins(a[l]); ans[l]=s[x].Gans(); return; &#125; int mid=l+r&gt;&gt;1,i; s[x+1]=s[x]; for(i=mid+1;i&lt;=r;i++) if(a[i]&lt;0&amp;&amp;ST[i]&lt;=l)s[x+1].Ins(-a[i]); CDQ(l,mid,x+1); s[x+1]=s[x]; for(i=l;i&lt;=mid;i++) if(a[i]&gt;0&amp;&amp;EN[i]&gt;r)s[x+1].Ins(a[i]); CDQ(mid+1,r,x+1);&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++) &#123; if(a[i]&gt;0) &#123; ct[a[i]]++; if(ct[a[i]]==1)fa[a[i]]=i; else a[i]=0; &#125; else &#123; ct[-a[i]]--; if(!ct[-a[i]]) &#123; ST[i]=fa[-a[i]]; EN[fa[-a[i]]]=i; &#125; else a[i]=0; &#125; &#125; for(i=1;i&lt;=n;i++) if(a[i]&gt;0&amp;&amp;!EN[i])EN[i]=n+1; CDQ(1,n,0); for(i=1;i&lt;=n;i++)printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>分治法</category>
        <category>CDQ分治</category>
        <category>线性基</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2640 （SDOI 2013）方程（扩展Lucas+容斥原理）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2640-%EF%BC%88SDOI-2013%EF%BC%89%E6%96%B9%E7%A8%8B%EF%BC%88%E6%89%A9%E5%B1%95Lucas-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2640【SDOI2013 R1 Day2】方程问题描述 输入格式 输入含有多组数据 ，第一行两个 正整数 T，p。T表示这个测试点内的 数据 组数 ，p的含义见题目描述 。对于每组数据，第一行 四个非负 整数 n，n1 ，n2 ，m。第二行 n1+ n2 个正整数，表示 整数，表示 A1…An1+n2 。请注意，如果 。请注意，如果 n1+ n2 等于 0，那么这一行将成为空行 输出格式 共 T行，每一个正整数表示取模后的答案 样例输入 3 100073 1 1 63 33 0 0 53 1 1 33 3 样例输出 360 提示 考虑没有限制的情况，那么显然用隔板法求解，$Ans=C_{m-1}^{n-1}$考虑大于等于的限制，那么显然直接$m=m-\sum A_i-1$即可。考虑小于等于的限制，不好做，但限制数很少，考虑容斥。那么$Ans=C_{m-sum}^{n-1}-有一个X_i不满足条件的方案+有两个X_i不满足条件的方案……$显然，后面的东西也是一个隔板法，那么剩下的问题就是算组合数。 如果p是质数，直接Lucas，而本题p可能是合数，需要用到扩展Lucas，大体思路是利用CRT解方程，即将p分解质因数，分别对每个$p_i^{a_i}$计算答案得到一组同余方程，然后因为模数互质，可以用CRT合并得到最终答案，具体请百度扩展Lucas 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;map&gt;#define N 15#define ll long longusing namespace std;struct node&#123;ll a,b;&#125;;bool operator&lt;(node a,node b)&#123; if(a.b==b.b)return a.a&lt;b.a; return a.b&lt;b.b;&#125;map&lt;node,ll&gt;Q;ll T,p,A[N];ll QM(ll a,ll b,ll c)&#123; ll o=1; while(b) &#123; if(b&amp;1)o=o*a%c; b&gt;&gt;=1;a=a*a%c; &#125; return o;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)x=1,y=0; else exgcd(b,a%b,y,x),y-=a/b*x;&#125;ll inv(ll a,ll b)&#123; ll x,y;exgcd(a,b,x,y); x=(x%b+b)%b; return x?x:x+b;&#125;ll fac(ll n,ll px,ll pi)&#123; if(!n)return 1; node tmp=(node)&#123;n,px&#125;; if(Q[tmp])return Q[tmp]; ll i,ans=1; if(n/px) &#123; for(i=2;i&lt;=px;i++)if(i%pi)ans=ans*i%px; ans=QM(ans,n/px,px); &#125; for(i=2;i&lt;=n%px;i++)if(i%pi)ans=ans*i%px; return Q[tmp]=ans*fac(n/pi,px,pi)%px;&#125;ll C(ll n,ll m,ll px,ll pi)&#123; if(m&gt;n)return 0ll; ll a=fac(n,px,pi),b=fac(m,px,pi),c=fac(n-m,px,pi); ll i,k=0,ans=0; for(i=n;i;i/=pi)k+=i/pi; for(i=m;i;i/=pi)k-=i/pi; for(i=n-m;i;i/=pi)k-=i/pi; ans=a*inv(b,px)%px*inv(c,px)%px*QM(pi,k,px)%px; return ans*(p/px)%p*inv(p/px,px)%p;&#125;ll Cal(ll n,ll m)&#123; ll i,ans=0,x=p,px; for(i=2;i&lt;=x;i++) &#123; if(x%i)continue;px=1; while(x%i==0)px*=i,x/=i; ans=(ans+C(n,m,px,i))%p; &#125; return ans;&#125;int main()&#123; ll n,n1,n2,m,i,j,k,x,y,ans,S; scanf("%lld%lld",&amp;T,&amp;p); while(T--) &#123; scanf("%lld%lld%lld%lld",&amp;n,&amp;n1,&amp;n2,&amp;m); for(i=1;i&lt;=n1;i++)scanf("%lld",&amp;A[i]); for(i=1;i&lt;=n2;i++)scanf("%lld",&amp;x),m-=x-1; ans=Cal(m-1,n-1);S=(1&lt;&lt;n1)-1; for(i=1;i&lt;=S;i++) &#123; x=0;y=m; for(j=1;j&lt;=n1;j++)if(i&gt;&gt;j-1&amp;1)x++,y-=A[j]; if(x&amp;1)ans-=Cal(y-1,n-1),ans%=p; else ans+=Cal(y-1,n-1),ans%=p; &#125; printf("%lld\n",(ans%p+p)%p); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>容斥原理</category>
        <category>Lucas</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3458 （POJ 1635）地铁系统 （树哈希）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3458-%EF%BC%88POJ-1635%EF%BC%89%E5%9C%B0%E9%93%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E6%A0%91%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3458地铁系统问题描述 一些大城市的地铁线路呈一棵树状，一条树枝就是一条双向地铁道路，它直接连接两个站点。任意两个站点间，有且仅有一条路径可以到达。大多数这样的城市都有一个中央地铁站，你是一个地铁迷，假设你现在就在一座这样的城市，你想要探索所有的地铁站。你从中央地铁站出发，随机选了一条地铁线就出发了。每到一个地铁站，你都会选一条没走过的道路继续乘地铁旅行。如果当前你所在的地铁站连接的所有道路你都探索过了，那么你会回到上一个车站，继续探索，直到你探索玩所有地铁站，也就是每条道路来回走过两次（其实就是深度优先搜索遍历一棵树的过程）。那时，你会身处中央车站，你凭记忆写下了一串由0和1构成的数字，来表示整个旅行的过程，其中0表示你离中央车站远了一点，1表示你离中央车站近了一点(0表示向下搜索，1表示回溯)。如上图所示，中间的大黑圆点表示中央车站，从它出法，遍历整棵树的顺序可以有很多种，右侧给出了其中的3中顺序。它们都表示遍历同一棵树。你的记事本上记下了两次探索过程，问这两次探索的是否是相同的地铁系统？ 输入格式 两行，每行一个由0和1构成的字符串，字符串的长度不超过3000. 输出格式 如果两个字符串表示的是相同的地铁系统，输出“same”，否则输出”different” 样例输入 样例1：00100111010010110100011011001011样例2：01001011001001110011000111010101 样例输出 样例1：same样例2：different 用栈模拟递归过程来连边，连完边之后直接树哈希。 关于树哈希，这道题我用的是，令父亲节点的哈希值为 $Hash[fa]=(a\times p \bigoplus Hash[son_1] ) \% q\times p\bigoplus Hash[son_2] \% q……\times b \% q$ 递归计算即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 5005using namespace std;const int a=233;const int p=1223;const int mod=1000007;const int b=1926;int T,S[N],top,tot;vector&lt;int&gt;to[N];char s[N];int Hash(int x)&#123; int i,y,ans=a; vector&lt;int&gt;tmp; if(!to[x].size())return 1; for(i=0;i&lt;to[x].size();i++)tmp.push_back(Hash(to[x][i])); sort(tmp.begin(),tmp.end()); for(i=0;i&lt;tmp.size();i++)ans=(ans*p^tmp[i])%mod; return ans*b%mod;&#125;int Work()&#123; int i,j,k,l=strlen(s); S[top=1]=tot=1; to[1].clear(); for(i=0;i&lt;l;i++) &#123; if(s[i]=='0') &#123; to[S[top]].push_back(++tot); S[++top]=tot;to[tot].clear(); &#125; else top--; &#125; return Hash(1);&#125;int main()&#123; int x,y; scanf("%d",&amp;T); while(T--) &#123; scanf("\n%s",s);x=Work(); scanf("\n%s",s);y=Work(); if(x==y)puts("same"); else puts("different"); &#125;&#125;]]></content>
      <categories>
        <category>杂学</category>
        <category>树哈希</category>
      </categories>
      <tags>
        <tag>树哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2936 （BZOJ 2001）城市建设（CDQ分治+LCT）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2936-%EF%BC%88BZOJ-2001%EF%BC%89%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%EF%BC%88CDQ%E5%88%86%E6%B2%BB-LCT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2936【FJ Training 2014 Day2】城市建设问题描述 PS国是一个拥有诸多城市的大国，国王Louis为城市的交通建设可谓绞尽脑汁。Louis可以在某些城市之间修建道路，在不同的城市之间修建道路需要不同的花费。Louis希望建造最少的道路使得国内所有的城市连通。但是由于某些因素，城市之间修建道路需要的花费会随着时间而改变，Louis会不断得到某道路的修建代价改变的消息，他希望每得到一条消息后能立即知道使城市连通的最小花费总和，Louis决定求助于你来完成这个任务。因版权问题，题目已隐藏。如有需要请私下联系root或nodgd。 输入格式 第一行包含三个整数N,M,Q，分别表示城市的数目，可以修建的道路个数，及收到的消息个数。接下来有M行，第i+1行有三个用空格隔开的整数Xi,Yi,Zi(1&lt;=Xi,Yi&lt;=N, 0&lt;=Zi&lt;=5*107)，表示在城市Xi与城市Yi之间修建道路的代价为Zi。接下来Q行，每行包含两个数k,d，表示输入的第k个道路的修建代价修改为d(即将Zi修改为d)。 输出格式 包含Q行，第i行输出得知前i条消息后使城市连通的最小花费总和。 样例输入 5 5 31 2 12 3 23 4 34 5 45 1 51 61 15 3 样例输出 14109 提示 对于20%的数据, n≤1000，m≤6000，Q≤6000。另有20%的数据，n≤1000，m≤50000，Q≤8000，修改后的代价不会比之前的代价低。对于100%的数据, n≤20000，m≤50000，Q≤50000。 题目让维护一个边权不断变化的动态最小生成树。容易发现修改边权相当于删除一条边再添加一条边。容易发现LCT可以轻松维护加边操作，但无法维护删边操作。此时考虑用CDQ分治去掉删边操作。预处理每条边存在的时间，按时间分治，每次将覆盖了整个左区间或右区间的边插入到左区间或右区间的LCT中。分治底层就是每一个时刻的答案LCT。但是并不能开$n\log n$个LCT，空间承受不了，容易发现LCT上的操作是可以撤销的，LINK和CUT互为逆操作，因此只需要用栈记录一下操作，回溯的时候撤销就行。这样就只需要开一颗全局LCT。 最终时间复杂度$O(2m\log q\log(2n))$，加上LCT的大常数，导致这样做非常地卡常，想要通过此题需要优秀的常数。 另外本题有另一个利用MST性质的做法，大致是利用MST将边分成三类同时缩点，不断缩小边集和点集。时间复杂度一样，但常数小。 代码（常数巨大以至于不能AC）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 800005#define ll long longusing namespace std;struct node&#123;int x,y,z,id;&#125;E[N],LE[N],RE[N];int n,m,q,L[N],R[N],TOT,tot,Hash[N],la[N];int ls[N],rs[N],fa[N],Max[N],id[N],v[N],rev[N],S[N],top;ll ans,Ans[N],Atop;node AS[N];inline char getc()&#123; static char *SS,*TT,buf[N]; if(SS==TT) &#123; TT=(SS=buf)+fread(buf,1,N,stdin); if(SS==TT)return EOF; &#125; return *SS++;&#125;inline bool isdigit(char x)&#123;return '0'&lt;=x&amp;&amp;x&lt;='9';&#125;inline int read()&#123; static char ch; static int D; while(!isdigit(ch=getc())); for(D=ch-'0';isdigit(ch=getc());)D=D*10+ch-'0'; return D;&#125; int GM(int x,int y,int z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;bool Isroot(int x)&#123;return ls[fa[x]]!=x&amp;&amp;rs[fa[x]]!=x;&#125;void MT(int p)&#123; Max[p]=GM(v[p],Max[ls[p]],Max[rs[p]]); if(Max[p]==v[p])id[p]=p; else if(Max[p]==Max[ls[p]])id[p]=id[ls[p]]; else id[p]=id[rs[p]];&#125;void PD(int p)&#123; if(rev[p]) &#123; swap(ls[p],rs[p]); rev[ls[p]]^=1; rev[rs[p]]^=1; rev[p]^=1; &#125;&#125;void Zig(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Zag(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Splay(int x)&#123; int i,y,z; S[++top]=x; for(i=x;!Isroot(i);i=fa[i])S[++top]=fa[i]; while(top)PD(S[top--]); while(!Isroot(x)) &#123; y=fa[x];z=fa[y]; if(!Isroot(y)) &#123; if(y==ls[z])x==ls[y]?(Zig(y),Zig(x)):(Zag(x),Zig(x)); else x==rs[y]?(Zag(y),Zag(x)):(Zig(x),Zag(x)); &#125; else x==ls[y]?Zig(x):Zag(x); &#125;&#125;void Access(int x)&#123; for(int t=0;x;x=fa[x]) &#123; Splay(x); rs[x]=t; MT(x);t=x; &#125;&#125;void Makeroot(int x)&#123; Access(x); Splay(x); rev[x]^=1;&#125;int Findroot(int x)&#123; Access(x); Splay(x); while(ls[x])x=ls[x]; return x;&#125;void Link(int x,int y)&#123; Makeroot(x); fa[x]=y;&#125;void Cut(int x,int y)&#123; Makeroot(x); Access(y); Splay(y); ls[y]=fa[x]=0;&#125;void Insert(node &amp;p,int ty)&#123; int x=p.x,y=p.y,t,d; if(Findroot(x)!=Findroot(y)) &#123; Link(x,p.id); Link(y,p.id); if(ty)AS[++Atop]=(node)&#123;x,p.id,1,0&#125;,AS[++Atop]=(node)&#123;y,p.id,1,0&#125;; ans+=p.z; &#125; else &#123; Makeroot(x); Access(y); Splay(y); if(Max[y]&gt;p.z) &#123; t=id[y]; d=Hash[t]; Cut(t,E[d].x); Cut(t,E[d].y); ans-=v[t]; if(ty)AS[++Atop]=(node)&#123;t,E[d].x,2,0&#125;,AS[++Atop]=(node)&#123;t,E[d].y,2,0&#125;; Link(x,p.id); Link(y,p.id); ans+=p.z; if(ty)AS[++Atop]=(node)&#123;x,p.id,1,0&#125;,AS[++Atop]=(node)&#123;y,p.id,1,0&#125;; &#125; &#125;&#125;void Recover(int T)&#123; while(Atop!=T) &#123; if(AS[Atop].z==1)Cut(AS[Atop].x,AS[Atop].y); else Link(AS[Atop].x,AS[Atop].y); Atop--; &#125;&#125;void CDQ(int l,int r)&#123; int i,j,k,x,y,las=Atop; ll pans=ans; if(l==r)&#123;Ans[l]=ans;return;&#125; int mid=l+r&gt;&gt;1; for(i=mid+1;i&lt;=r;i++)if(L[i]&lt;=l)Insert(LE[i],1); CDQ(l,mid);Recover(las);ans=pans; for(i=l;i&lt;=mid+1;i++)if(R[i]&gt;r)Insert(RE[i],1); CDQ(mid+1,r);Recover(las);ans=pans;&#125;int main()&#123; int i,j,k,x,y,z; n=read();m=read();q=read();tot=n; for(i=1;i&lt;=m;i++) &#123; x=read();y=read();z=read(); E[++TOT]=(node)&#123;x,y,z,0&#125;; la[TOT]=0; &#125; for(i=1;i&lt;=q;i++) &#123; x=read();y=read(); L[i]=la[x];la[x]=i; LE[i]=E[x];E[x].z=y; R[L[i]]=i;RE[L[i]]=LE[i]; LE[i].id=++tot;v[tot]=LE[i].z;Hash[tot]=x; RE[L[i]].id=++tot;v[tot]=LE[i].z;Hash[tot]=x; &#125; for(i=1;i&lt;=TOT;i++) &#123; k=la[i]; if(k==0||k==1)E[i].id=++tot,v[tot]=E[i].z,Hash[tot]=i,Insert(E[i],0); else R[k]=q+1,RE[k]=E[i],RE[k].id=++tot,v[tot]=RE[k].z,Hash[tot]=i; &#125; CDQ(1,q); for(i=1;i&lt;=q;i++)printf("%lld\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>分治法</category>
        <category>CDQ分治</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5716 带可选字符的多字符串匹配 （shift-and）]]></title>
    <url>%2F2018%2F03%2F15%2FHDU-5716-%E5%B8%A6%E5%8F%AF%E9%80%89%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%EF%BC%88shift-and%EF%BC%89%2F</url>
    <content type="text"><![CDATA[带可选字符的多字符串匹配Problem Description 有一个文本串，它的长度为m(1≤m≤2000000)，现在想找出其中所有的符合特定模式的子串位置。符合特定模式是指，该子串的长度为n(1≤n≤500)，并且第i个字符需要在给定的字符集合Si中。因此，描述这一特定模式，共需要S1,S2,…,Sn这n个字符集合。每个集合的大小都在1∼62之间，其中的字符只为数字或大小写字母。 Input 第一行为一个字符串，表示待匹配的文本串。注意文本串中可能含有数字和大小写字母之外的字符。第二行为一个整数n。以下n行，分别描述n个字符集合。每行开始是一个1∼62之间的整数，随后有一个空格，接下来有一个字符串表示对应字符集合的内容。整数表示字符集合的大小，因此它也就是字符串的长度。输入保证字符串中的字符只为数字或大小写字母且没有重复。（注：本题有多组测试数据） Output 每当从某个位置开头的，长度为n的子串符合输入的模式，就输出一行，其中包含一个整数，为它在文本串的起始位置。位置编号从1开始。如果文本串没有任何位置符合输入模式，则最后输出一个字符串”NULL”，占一行。 Sample Input aaaabacabcabd33 abc2 bc3 abc Sample Output 4689 这应该是一道shift-and的模板题了。注意到每个位置是一个字符集对shift-and并没有影响，仍然只需要处理出文本串中每个字符在匹配串中出现位置，然后直接shift-and即可。 关于shift-and算法，用了一个数组$F[i][j]$,$F[i][j]$表示匹配串以$j$结尾的前缀是否是文本串以$i$结尾的前缀的后缀，简单来说就是模式串以$j$结尾能否匹配当前位置。 考虑转移，$F[i+1][j+1]=1$当且仅当$F[i][j]=1$&amp;&amp;$S[i+1]=T[j+1]$，令$B[i]$表示字符i在串$T$中出现位置的状压。那么有$F[i+1]=(F[i]&lt;&lt;1|1)$&amp;$B[S[i+1]]$，利用bitset实现，可做到$\frac{mn}{32}$，当匹配串较短时可认为是线性。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;bitset&gt;#define N 2000005using namespace std;char s[N],ss[N];bitset&lt;501&gt;F,B[63];int id(char t)&#123; if(t&gt;='0'&amp;&amp;t&lt;='9')return t-47; if(t&gt;='A'&amp;&amp;t&lt;='Z')return 11+t-'A'; if(t&gt;='a'&amp;&amp;t&lt;='z')return 37+t-'a'; return 0;&#125;int main()&#123; int i,j,k,n;char c;bool f; while(gets(s+1)) &#123; int l=strlen(s+1); F.reset();f=0; for(i=0;i&lt;63;i++)B[i].reset(); scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;k); scanf("%s",&amp;ss[1]); for(j=1;j&lt;=k;j++)B[id(ss[j])][i]=1; &#125; for(i=1;i&lt;=l;i++) &#123; F&lt;&lt;=1;F[1]=1; F&amp;=B[id(s[i])]; if(F[n]==1)printf("%d\n",i-n+1),f=1; &#125; if(!f)puts("NULL"); c=getchar(); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>杂学</category>
        <category>压位</category>
        <category>shift-and</category>
      </categories>
      <tags>
        <tag>压位</tag>
        <tag>shift-and</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4939 （Ynoi 2016）掉进兔子洞（莫队+压位）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-4939-%EF%BC%88Ynoi-2016%EF%BC%89%E6%8E%89%E8%BF%9B%E5%85%94%E5%AD%90%E6%B4%9E%EF%BC%88%E8%8E%AB%E9%98%9F-%E5%8E%8B%E4%BD%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[4939: [Ynoi2016]掉进兔子洞Description 您正在打galgame，然后突然发现您今天太颓了，于是想写个数据结构题练练手：一个长为 n 的序列 a。有 m 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，比如三个区间是 [1,2,2,3,3,3,3] , [1,2,2,3,3,3,3] 与 [1,1,2,3,3]，就一起扔掉了 1 个 1，1 个 2，2 个 3。 Input 第一行两个数表示 n , m。第二行 n个数表示 a[i]。之后 m 行，每行 6 个数 l1 , r1 , l2, r2 , l3 , r3 表示这三个区间。 Output 对于每个询问，输出一个数表示答案。 Sample Input 5 21 2 2 3 31 2 2 3 3 41 5 1 5 1 5 Sample Output 30 HINT n , m &lt;= 100000 , 1 &lt;= a[i] &lt;= 1000000000 显然是要求$\sum_{i=1}^{3}(r_i-l_i+1)-\sum_{i=1}^{Max}min(cnt_1[i],cnt_2[i],cnt_3[i])$，$cnt_j[i]表示数字i在区间j中出现次数$ 考虑求后面的部分。首先肯定要离散化。可以将每个询问拆成三个，分别处理出每个区间的$cnt$数组。而$cnt$数组可以用莫队来得到。 现在考虑如何较快的将三个$cnt$取最小后求和。这个可以用$bitset$来做到。考虑离散化的时候，比如样例1 2 2 3 3，离散化后得到1 2 2 4 4，那么在$bitset$中，就可以用第3个bit位来表示第二个出现的2，用第2个bit位来表示第一个出现的2。然后只需要把三个bitset与起来就得到答案了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;#define N 100005using namespace std;const int T=25000;bitset&lt;100000&gt;F[25001],f;int n,A[N],B[N],cnt[N],id[N],S,tot,ans[N],Ans[N],TOT;bool mark[N];struct node&#123;int l,r,id;&#125;K[N];bool cmp(node a,node b)&#123; if(id[a.l]==id[b.l])return a.r&lt;b.r; return id[a.l]&lt;id[b.l];&#125;void UD(int k,int ty)&#123; k=A[k];cnt[k]+=ty; if(ty==1)f[k+cnt[k]-2]=1; else f[k+cnt[k]-1]=0;&#125;void Solve(int m)&#123; int i,j,k,L,R,l1,l2,l3,r1,r2,r3; memset(cnt,0,sizeof(cnt)); memset(mark,0,sizeof(mark)); f.reset();tot=0; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d%d%d",&amp;l1,&amp;r1,&amp;l2,&amp;r2,&amp;l3,&amp;r3); K[++tot]=(node)&#123;l1,r1,i&#125;; K[++tot]=(node)&#123;l2,r2,i&#125;; K[++tot]=(node)&#123;l3,r3,i&#125;; ans[i]=r3+r2+r1-l3-l2-l1+3; &#125; sort(K+1,K+tot+1,cmp); L=1;R=0; for(i=1;i&lt;=tot;i++) &#123; while(R&lt;K[i].r)UD(++R,1); while(R&gt;K[i].r)UD(R--,-1); while(L&lt;K[i].l)UD(L++,-1); while(L&gt;K[i].l)UD(--L,1); if(mark[K[i].id])F[K[i].id]&amp;=f; else F[K[i].id]=f,mark[K[i].id]=1; &#125; for(i=1;i&lt;=m;i++) &#123; k=F[i].count(); printf("%d\n",ans[i]-3*k); &#125;&#125;int main()&#123; int i,j,k,m,x,y,l,r; scanf("%d%d",&amp;n,&amp;m);S=sqrt(n); for(i=j=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),B[i]=A[i],id[i]=i%S?j:j++; sort(B+1,B+n+1); for(i=1;i&lt;=n;i++)A[i]=lower_bound(B+1,B+n+1,A[i])-B; while(m) &#123; if(m&lt;=T)Solve(m),m=0; else Solve(T),m-=T; &#125;&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>杂学</category>
        <category>压位</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>压位</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4810 由乃的玉米田 （莫队+压位）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-4810-%E7%94%B1%E4%B9%83%E7%9A%84%E7%8E%89%E7%B1%B3%E7%94%B0-%EF%BC%88%E8%8E%AB%E9%98%9F-%E5%8E%8B%E4%BD%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[4810: [Ynoi2017]由乃的玉米田Description 由乃在自己的农田边散步，她突然发现田里的一排玉米非常的不美。这排玉米一共有N株，它们的高度参差不齐。由乃认为玉米田不美，所以她决定出个数据结构题 这个题是这样的：给你一个序列a，长度为n，有m次操作，每次询问一个区间是否可以选出两个数它们的差为x，或者询问一个区间是否可以选出两个数它们的和为x，或者询问一个区间是否可以选出两个数它们的乘积为x ，这三个操作分别为操作1,2,3选出的这两个数可以是同一个位置的数 Input 第一行两个数n,m后面一行n个数表示ai后面m行每行四个数opt l r xopt表示这个是第几种操作，l,r表示操作的区间，x表示这次操作的x定义c为每次的x和ai中的最大值，ai &gt;= 0，每次的x&gt;=2n,m,c &lt;= 100000 Output 对于每个询问，如果可以，输出yuno，否则输出yumi Sample Input 5 51 1 2 3 42 1 1 21 1 2 23 1 1 13 5 5 161 2 3 4 Sample Output yunoyumiyunoyunoyumi 首先，如果维护了$[l,r]$的权值出现情况，用一个bitset $F$表示数字$i$是否存在那么对于询问1，就是$F$&amp;$(F&lt;&lt;x)$是否存在1对询问二，令$G[i]=F[n-i]$，那么就是$G$&amp;$(F&lt;&lt;100000-x)$对询问三，分解因数暴力判断即可。 关于如何维护$[l,r]$的bitset，用莫队即可。总复杂度$O(n\sqrt{n}+\frac{nm}{32})$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;#define N 100005using namespace std;const int T=100000;bitset&lt;100000&gt;F,G;int n,m,A[N],cnt[N],id[N],S;bool Ans[N];struct node&#123;int l,r,x,ty,id;&#125;K[N];bool cmp(node a,node b)&#123; if(id[a.l]==id[b.l])return a.r&lt;b.r; return id[a.l]&lt;id[b.l];&#125;void UD(int k,int ty)&#123; k=A[k]; if(cnt[k])F[k]=0,G[T-k]=0; cnt[k]+=ty; if(cnt[k])F[k]=1,G[T-k]=1;&#125;bool Gans(int ty,int x)&#123; if(ty==1) &#123; bitset&lt;100000&gt;tmp=(F&lt;&lt;x)&amp;F; return tmp.any(); &#125; if(ty==2) &#123; bitset&lt;100000&gt;tmp=(F&lt;&lt;T-x)&amp;G; return tmp.any(); &#125; if(ty==3) &#123; for(int i=1;i*i&lt;=x;i++) if(x%i==0&amp;&amp;F[i]&amp;&amp;F[x/i])return 1; return 0; &#125;&#125;int main()&#123; int i,j,k,x,y,z,L,R; scanf("%d%d",&amp;n,&amp;m); S=sqrt(n); for(i=j=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),id[i]=i%S?j:j++; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;k,&amp;L,&amp;R,&amp;x); K[i]=(node)&#123;L,R,x,k,i&#125;; &#125; sort(K+1,K+m+1,cmp); L=1;R=0; for(i=1;i&lt;=m;i++) &#123; while(K[i].r&lt;R)UD(R--,-1); while(K[i].r&gt;R)UD(++R,1); while(K[i].l&lt;L)UD(--L,1); while(K[i].l&gt;L)UD(L++,-1); Ans[K[i].id]=Gans(K[i].ty,K[i].x); &#125; for(i=1;i&lt;=m;i++)Ans[i]?puts("yuno"):puts("yumi");&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>杂学</category>
        <category>压位</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>压位</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3446 （HN Training 2015）Shopping （点分治+树形dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3446-%EF%BC%88HN-Training-2015%EF%BC%89Shopping-%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB-%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3446【HN Training 2015 Round7】问题描述 容易发现最后答案是树上的一个联通块，但直接dp难度较大，考虑用点分治转化成一定包含根的联通块。 点分治后，每一层考虑包含根的联通块，那么转化成一个树形依赖背包，只有选了父节点才能选子节点，并且每个物品有个数限制。 这里对于这种树形依赖dp，可以采用dfs序来简化，因为在dfs序中，一颗子树必然是连续的一段，那么令$F[i][j]$表示在$dfs序i-n这些节点中容积为j的背包的最优解$,因此在物品数量均为1时可以得到dp方程$$F[i][j]=max(F[i+size[i]][j],F[i+1][j-c[i]]+w[i])$$第一个转移表示不选i节点的物品，那么跳过i这颗子树，第二个转移表示选。答案就是$F[1][m]$ 接着考虑物品数量的限制，这里我用的二进制拆分的方法，即将d个物品拆成$log\ d$个物品，举个例子，比如将$10$个物品可以拆成$1,2,4,3$这4个物品，容易发现，无论从这10个物品中取多少个，都可以用上述4个物品表示出来。 修改后的dp方程可以参照代码，改动不大，只是多了一个$log$的复杂度。最终复杂度$Tnm\log n\log d$，实际上跑得还是很快。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 505#define M 4005using namespace std;int T,n,m,w[N],c[N],d[N],F[N][M],ans;int TOT,LA[N],NE[N*2],EN[N*2];int Min,rt,si[N],VT,sz[N],wi[N],ci[N],di[N];bool mark[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Gsi(int x,int f)&#123; int i,y;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Gsi(y,x);si[x]+=si[y]; ans=max(ans,F[1][m]); &#125;&#125;void Grt(int x,int f,int s)&#123; int i,y,Max=s-si[x]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Grt(y,x,s); if(Max&lt;si[y])Max=si[y]; &#125; if(Max&lt;Min)Min=Max,rt=x;&#125;void DFS(int x,int f)&#123; int i,y,p=++VT;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y]||y==f)continue; DFS(y,x);si[x]+=si[y]; &#125; sz[p]=si[x];wi[p]=w[x];ci[p]=c[x];di[p]=d[x];&#125;void Gans(int x)&#123; int i,j,k,y;VT=0;DFS(x,0);//DFS序 for(i=VT;i&gt;0;i--) &#123; for(j=0;j&lt;=m;j++)F[i][j]=F[i+sz[i]][j]; for(k=1,y=di[i];y&gt;0;y-=k,k&lt;&lt;=1)//拆分物品 for(j=m;j&gt;=k*ci[i]||j&gt;=y*ci[i];j--)//背包 if(k&lt;y)F[i][j]=max(F[i][j],max(F[i][j-k*ci[i]],F[i+1][j-k*ci[i]])+k*wi[i]); else F[i][j]=max(F[i][j],max(F[i][j-y*ci[i]],F[i+1][j-y*ci[i]])+y*wi[i]); &#125; ans=max(ans,F[1][m]); for(i=VT;i&gt;0;i--) for(j=0;j&lt;=m;j++)F[i][j]=0;&#125;void DC(int x)&#123; int i,y;mark[x]=1; Gans(x); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];if(mark[y])continue; Min=1e9;Gsi(y,0);Grt(y,x,si[y]);DC(rt); &#125;&#125;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;T); while(T--) &#123; TOT=0;ans=0; memset(LA,0,sizeof(LA)); memset(mark,0,sizeof(mark)); scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;w[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;c[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;d[i]); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; Min=1e9;Gsi(1,0);Grt(1,0,n);DC(rt); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>分治法</category>
        <category>树形dp</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 666E Forensic Examination （后缀自动机+线段树合并）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-666E-Forensic-Examination-%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Forensic Examination The country of Reberland is the archenemy of Berland. Recently the authorities of Berland arrested a Reberlandian spy who tried to bring the leaflets intended for agitational propaganda to Berland illegally . The most leaflets contain substrings of the Absolutely Inadmissible Swearword and maybe even the whole word. Berland legal system uses the difficult algorithm in order to determine the guilt of the spy. The main part of this algorithm is the following procedure. All the m leaflets that are brought by the spy are numbered from 1 to m. After that it’s needed to get the answer to q queries of the following kind: “In which leaflet in the segment of numbers [l, r] the substring of the Absolutely Inadmissible Swearword [pl, pr] occurs more often?”. The expert wants you to automate that procedure because this time texts of leaflets are too long. Help him! Input The first line contains the string s (1 ≤ |s| ≤ 5·105) — the Absolutely Inadmissible Swearword. The string s consists of only lowercase English letters. The second line contains the only integer m (1 ≤ m ≤ 5·104) — the number of texts of leaflets for expertise. Each of the next m lines contains the only string ti — the text of the i-th leaflet. The sum of lengths of all leaflet texts doesn’t exceed 5·104. The text of the leaflets consists of only lowercase English letters. The next line contains integer q (1 ≤ q ≤ 5·105) — the number of queries for expertise. Finally, each of the last q lines contains four integers l, r, pl, pr (1 ≤ l ≤ r ≤ m, 1 ≤ pl ≤ pr ≤ |s|), where |s| is the length of the Absolutely Inadmissible Swearword. Output Print q lines. The i-th of them should contain two integers — the number of the text with the most occurences and the number of occurences of the substring [pl, pr] of the string s. If there are several text numbers print the smallest one. input suffixtree3suffixtreesareawesomecartesiantreeisworsethansegmenttreenyeeheeheee21 2 1 101 3 9 10 output 1 13 4 题目大意：给定一个字符串$s$，和$m$个字符串$p_1…….p_m$，$q$次询问，每次询问在$p_l……p_r$中，$s$的一个子串$s[x…y]$在哪一个串中出现次数最多。 询问子串的出现次数，考虑构建后缀自动机，由于有多个串，因此需要分开维护$Right$集合的大小，构建串$s+@+p_1+@+……+p_m$的后缀自动机。对于每个节点，维护一颗线段树，表示该节点表示的子串在每一个$p$中出现的次数，这个在每次添加新的$np$节点时直接往线段树中插入就行。 自动机建好了之后按照$parent$树，自底向上将子节点的线段树合并到父节点上，利用可持久化线段树可以完成。 然后对于每次询问，预先记录每个$s$每个前缀在自动机上的位置，然后在$parent$树上倍增查找子串对应节点，找到对应节点后直接在线段树上询问区间$[l,r]$的最大值即可。 总时间复杂度$O(nlog^2n)$，注意在合并线段树的时候一定要新开节点。 同时这题有个坑点就是当出现次数是$0$时，直接输出查询的左界。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1200000#define M 20000000using namespace std;typedef pair&lt;int,int&gt; par;namespace Seg&#123; int rt[N],ls[M],rs[M],Max[M],id[M],tot; int CP(int p) &#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; Max[o]=Max[p]; id[o]=id[p]; return o; &#125; void UD(int p) &#123; Max[p]=max(Max[ls[p]],Max[rs[p]]); if(Max[ls[p]]&lt;Max[rs[p]])id[p]=id[rs[p]]; else id[p]=id[ls[p]]; &#125; int ADD(int p,int l,int r,int k,int d) &#123; int o=CP(p); if(l==r)return Max[o]+=d,id[o]=k,o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k,d); else rs[o]=ADD(rs[o],mid+1,r,k,d); UD(o);return o; &#125; par GS(int p,int l,int r,int x,int y) &#123; if(Max[p]==0)return par(0,max(l,x)); if(x&lt;=l&amp;&amp;y&gt;=r)return par(Max[p],id[p]); int mid=l+r&gt;&gt;1;par t1=par(-1,0),t2=par(-1,0); if(x&lt;=mid&amp;&amp;y&gt;=l)t1=GS(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)t2=GS(rs[p],mid+1,r,x,y); if(t1.first&gt;=t2.first)return t1; return t2; &#125; int Merge(int p1,int p2,int l,int r) &#123; if(!p1)return CP(p2); if(!p2)return CP(p1); int o=++tot,mid=l+r&gt;&gt;1; if(l==r)return Max[o]=Max[p1]+Max[p2],id[o]=l,o; ls[o]=Merge(ls[p1],ls[p2],l,mid); rs[o]=Merge(rs[p1],rs[p2],mid+1,r); UD(o);return o; &#125;&#125;char s[N];int TOT,LA[N],NE[N],EN[N],S=21;int m,q,tot=1,rt=1,las=1,son[N][27],pra[N],Max[N],en[N],fa[N][22];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int NP(int x)&#123; Max[++tot]=x; return tot;&#125;void Ins(int t,int ty)&#123; int p=las,np,q,nq; np=NP(Max[p]+1); if(ty)Seg::rt[np]=Seg::ADD(Seg::rt[np],1,m,ty,1); while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p]; if(!p)pra[np]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); pra[nq]=pra[q]; pra[q]=pra[np]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p]; &#125; &#125; las=np;&#125;void DFS(int x,int f)&#123; int i,y;fa[x][0]=f; for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; DFS(EN[i],x); Seg::rt[x]=Seg::Merge(Seg::rt[x],Seg::rt[EN[i]],1,m); &#125;&#125;int Find(int x,int le)&#123; for(int i=S;i&gt;=0;i--)if(Max[fa[x][i]]&gt;=le)x=fa[x][i]; return x;&#125;void Query(int l,int r,int x,int y)&#123; int p=Find(en[y],y-x+1); par t=Seg::GS(Seg::rt[p],1,m,l,r); printf("%d %d\n",t.second,t.first);&#125;int main()&#123; int i,j,k,L,l,r,x,y; scanf("%s\n%d",s,&amp;m); L=strlen(s); for(i=0;i&lt;L;i++)Ins(s[i]-'a',0),en[i]=las; for(i=1;i&lt;=m;i++) &#123; scanf("\n%s",s); L=strlen(s);Ins(26,0); for(j=0;j&lt;L;j++)Ins(s[j]-'a',i); &#125; for(i=1;i&lt;=tot;i++)ADD(pra[i],i); DFS(1,0); scanf("%d",&amp;q); while(q--) &#123; scanf("%d%d%d%d",&amp;l,&amp;r,&amp;x,&amp;y); Query(l,r,x-1,y-1); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2966 （BZOJ 3622）已经没什么好害怕的了 （DP+二项式反演）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2966-%EF%BC%88BZOJ-3622%EF%BC%89%E5%B7%B2%E7%BB%8F%E6%B2%A1%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86-%EF%BC%88DP-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2966【2014湖北省队互测week2】已经没什么好害怕的了问题描述 已经使Modoka有签订契约，和自己一起战斗的想法后，Mami忽然感到自己不再是孤单一人了呢。 于是，之前的谨慎的战斗作风也消失了，在对Charlotte的傀儡使用终曲——Tiro Finale后，Mami面临着即将被Charlotte的本体吃掉的局面。 这时，已经多次面对过Charlotte的Homura告诉了学OI的你这样一个性质——Charlotte的结界中有两种具有能量的元素——一种是“糖果”，另一种是“药片”，每种各有n个。在Charlotte发动进攻前，“糖果”和“药片”会两两配对，若恰好“糖果”比“药片”能量大的组数比“药片”比“糖果”能量大的组数多k组，则在这种局面下，Charlotte的攻击会丢失，从而Mami仍有消灭Charlotte的可能。你必须根据Homura告诉你的“糖果”和“药片”的能量的信息迅速告诉Homura这种情况的个数。 输入格式 第一行两个整数n,k，含义如题目描述。 接着第二行n个整数，第i个数表示第i个糖果的能量。 第三行n个整数，第j个数表示第j个药片的能量。 输出格式 一个整数，表示消灭Charlotte的情况个数。答案可能会很大,所以mod (109+9) 样例输入 4 25 35 15 4540 20 10 30 样例输出 4 数据范围： 约定：给出的2*n个能量值两两不同对于10%的数据：1&lt;=n&lt;=10对于40%的数据：1&lt;=n&lt;=500对于100%的数据：1&lt;=n&lt;=2000，0&lt;=k&lt;=n 先将$A_i$和$B_i$排序考虑如何计算恰有K对$A_i&gt;B_i$的方案数。 令$F[i]$表示恰有$i$对的方案数，令$f[i][j]$表示$A_i$的前$i$个数有$j$对的方案数。令$t[i]$表示$B$中小于$A_i$的数的数量。那么有转移方程$f[i][j]=f[i-1][j]+f[i-1][j-1]*(t[i]-j+1)$，$t[i]-j+1$表示总共有$t[i]$个数可以与$A[i]$匹配，而其中已经匹配了$j-1$个。 然后令$G[i]=(n-i)!f[n][i]$，注意到，这里的$G[i]$意思是先确定$i$对$A_x&gt;B_x$，然后剩下的随便排列。考虑$G[i]$与$F[i]$的关系，能够推出$$G[i]=\sum_{j=i}^{n}C_{j}^{i}F[j]$$这里我们考虑对于$G[i]$，肯定至少有$i$对，但剩下的任意排列可能使得对数增加，同时可能造成重复。因此枚举总共有多少对，然后考虑重复，对于有$j$对的方案，在$G[i]$中被重复算的次数恰好就是$C_{j}^{i}$，意思是从这$j$对中选出$i$对作为一开始在$f[n][i]$中确定的$i$对。 最后二项式反演得到$$F[i]=\sum_{j=i}^{n}(-1)^{j-i}C_{j}^{i}G[j]$$总时间复杂度$O(n^2)$ 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2005#define ll long longusing namespace std;const ll mod=1e9+9;ll n,m,A[N],B[N],f[N][N],C[N][N],F[N],G[N],fac[N],t[N];int main()&#123; ll i,j,k;fac[0]=1; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;B[i]); if(n+m&amp;1)return puts("0"),0; m=(n+m)&gt;&gt;1; for(i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%mod; for(i=0;i&lt;=n;i++)C[i][0]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; sort(A+1,A+n+1); sort(B+1,B+n+1); for(i=j=1;i&lt;=n;i++) &#123; while(j&lt;=n&amp;&amp;A[i]&gt;B[j])j++; t[i]=j-1; &#125; for(i=0;i&lt;=n;i++)f[i][0]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)f[i][j]=(f[i-1][j]+f[i-1][j-1]*max(0ll,t[i]-j+1)%mod)%mod; for(i=0;i&lt;=n;i++)G[i]=fac[n-i]*f[n][i]%mod; for(i=m,k=1;i&lt;=n;i++,k=-k)F[m]+=k*C[i][m]*G[i]%mod,F[m]%=mod; printf("%lld",(F[m]+mod)%mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>二项式反演</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3441 Lucas的数论（杜教筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3441-Lucas%E7%9A%84%E6%95%B0%E8%AE%BA%EF%BC%88%E6%9D%9C%E6%95%99%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3441【HN Training 2015 Round5】lucas的数论问题描述数据范围 对于100%的数据:n&lt;=1000000000 直接推式子，用到一个公式，这个公式也比较显然，就是根据定义直接得到，注意到不互质的数对乘积也一定会被乘积相同的一个互质数对算到。$$Ans=\sum_{i=1}^{N}\sum_{j=1}^{N}\tau (i\times j)，已知\tau (i \times j)=\sum_{x|i}\sum_{y|j}1[gcd(x,y)=1]$$ $$Ans=\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{x|i}\sum_{y|j}\sum_{p|gcd(x,y)}\mu(p)=\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{p|gcd(i,j)}\tau(\frac{i}{p})\tau(\frac{j}{p})\mu(p)$$ $$Ans=\sum_{p=1}^{N}\mu(p)\sum_{i=1}^{\lfloor{\frac{N}{p}}\rfloor}\tau(i)\sum_{j=1}^{\lfloor{\frac{N}{p}}\rfloor}\tau(j)=\sum_{p=1}^{N}\mu(p)[\sum_{i=1}^{\lfloor{\frac{N}{p}}\rfloor}\tau(i)]^2$$ 注意到后面是取整的形式，如果知道$\tau(i)​$和$\mu(i)​$的前缀和，那么可以分块在$O(\sqrt{n})​$内求解考虑如何快速求出$\tau(i)​$的前缀和与$\mu(i)​$的前缀和，考虑杜教筛。 对于$\mu(i)$，注意到$\sum_{d|n}\mu(d)=[n==1]$，那么有$\sum_{i=1}^{n}\sum_{d|i}\mu(d)=1$，于是$\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=1$$$\sum_{i=1}^{n}\mu(d)=1-\sum_{i=2}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)，令\sum_{i=1}^{n}\mu(i)=M(n)$$ $$那么M(n)=1-\sum_{i=2}^{n}M(\lfloor\frac{n}{i}\rfloor)$$ 上式显然可以分块迭代处理，预处理一部分后做到$O(n^{\frac{2}{3}})$，从狄利克雷卷积的角度就是$\mu\small\bigotimes I=e$ 对于$\tau(i)$，注意到$\tau(i)=\sum_{d|i}1$，即 $\tau=I \small\bigotimes I$ ，那么 $\mu \small\bigotimes \tau=I \small\bigotimes e=I$ ，即$\sum_{d|n}\mu(\frac{n}{d})\tau(d)=1$，同样有$\sum_{i=1}^{n}\sum_{d|i}\mu(\frac{n}{d})\tau(d)=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(i)\tau(d)=1$，于是$$\sum_{i=1}^{n}\tau(i)=1-\sum_{i=2}^{n}\mu(i)\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\tau(d)，令T(n)=\sum_{i=1}^{n}\tau(i)$$$$那么T(n)=1-\sum_{i=2}^{n}\mu(i)T(\lfloor\frac{n}{i}\rfloor)$$上式显然还是分块迭代处理，但是需要用到$\mu(i)$的前缀和，复杂度不好说，但还是比较快的。 关于预处理一部分$tau(i)$，线性筛的时候需要增加两个数组，一个记录$i$的最小质因子，另一个记录最小质因子的指数，由于线性筛每次筛掉一个数一定是用他的最小质因数，因此可以方便的转移，具体可以看代码。 事实上，求$\tau(i)$的前缀和有更快的方法，因为$\sum_{i=1}^{n}\tau(i)=\sum_{i=1}^{n}\sum_{d|i}1=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}1=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$，直接分块+预处理可以做到$O(\sqrt{n})$，最终复杂度$O(n^{\frac{3}{4}})$，复杂度并不会证，看看就好。 代码（杜教筛求$\tau(i)$）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#define N 12345678#define ll long longusing namespace std;const ll mod=1e9+7;map&lt;ll,ll&gt;Mu,G;ll n,K,tot,P[N],g[N],mu[N],pc[N],pd[N];void EU()&#123; ll i,j;mu[1]=g[1]=1; for(i=2;i&lt;=K;i++) &#123; if(!g[i])P[++tot]=i,mu[i]=-1,g[i]=2,pc[i]=1,pd[i]=tot; for(j=1;j&lt;=tot&amp;&amp;i*P[j]&lt;=K;j++) &#123; if(i%P[j]) &#123; pc[i*P[j]]=1; pd[i*P[j]]=j; mu[i*P[j]]=-mu[i]; g[i*P[j]]=g[i]&lt;&lt;1; &#125; else &#123; pc[i*P[j]]=j==pd[i]?pc[i]+1:1; pd[i*P[j]]=j; g[i*P[j]]=j==pd[i]?(g[i]/(pc[i]+1)*(pc[i]+2)):(g[i]&lt;&lt;1); &#125; &#125; &#125; for(i=2;i&lt;=K;i++)g[i]+=g[i-1],mu[i]+=mu[i-1],g[i]%=mod;&#125;ll Gmu(ll x)&#123; if(x&lt;=K)return mu[x]; if(Mu[x])return Mu[x]; ll i,j,ans=1; for(i=2;i&lt;=x;i=j+1) &#123; j=x/(x/i); ans-=(j-i+1)*Gmu(x/i); &#125; return Mu[x]=ans;&#125;ll Gg(ll x)&#123; if(x&lt;=K)return g[x]; if(G[x])return G[x]; ll i,j,ans=x; for(i=2;i&lt;=x;i=j+1) &#123; j=x/(x/i); ans-=(Gmu(j)-Gmu(i-1))*Gg(x/i)%mod;ans%=mod; &#125; return G[x]=ans;&#125;int main()&#123; ll ans=0,i,j; scanf("%lld",&amp;n); K=pow(n,0.66);EU(); for(i=1;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans+=(Gmu(j)-Gmu(i-1))*Gg(n/i)%mod*Gg(n/i)%mod;ans%=mod; &#125; printf("%lld",(ans+mod)%mod);&#125; 另附$O(\sqrt{n})$求$\tau$做法，实测并快不了多少，但如果是算单个应该快很多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#define N 12345678#define ll long longusing namespace std;const ll mod=1e9+7;map&lt;ll,ll&gt;Mu,G;ll n,K,tot,P[N],g[N],mu[N],pc[N],pd[N];void EU()&#123; ll i,j;mu[1]=g[1]=1; for(i=2;i&lt;=K;i++) &#123; if(!g[i])P[++tot]=i,mu[i]=-1,g[i]=2,pc[i]=1,pd[i]=tot; for(j=1;j&lt;=tot&amp;&amp;i*P[j]&lt;=K;j++) &#123; if(i%P[j]) &#123; pc[i*P[j]]=1; pd[i*P[j]]=j; mu[i*P[j]]=-mu[i]; g[i*P[j]]=g[i]&lt;&lt;1; &#125; else &#123; pc[i*P[j]]=j==pd[i]?pc[i]+1:1; pd[i*P[j]]=j; g[i*P[j]]=j==pd[i]?(g[i]/(pc[i]+1)*(pc[i]+2)):(g[i]&lt;&lt;1); &#125; &#125; &#125; for(i=2;i&lt;=K;i++)g[i]+=g[i-1],mu[i]+=mu[i-1],g[i]%=mod;&#125;ll Gmu(ll x)&#123; if(x&lt;=K)return mu[x]; if(Mu[x])return Mu[x]; ll i,j,ans=1; for(i=2;i&lt;=x;i=j+1) &#123; j=x/(x/i); ans-=(j-i+1)*Gmu(x/i); &#125; return Mu[x]=ans;&#125;ll Gg(ll x)&#123; if(x&lt;=K)return g[x]; if(G[x])return G[x]; ll ans=0,i,j; for(i=1;i&lt;=x;i=j+1) &#123; j=x/(x/i); ans+=(j-i+1)*(x/i)%mod;ans%=mod; &#125; return G[x]=ans;&#125;int main()&#123; ll ans=0,i,j; scanf("%lld",&amp;n); K=pow(n,0.66);EU(); for(i=1;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans+=(Gmu(j)-Gmu(i-1))*Gg(n/i)%mod*Gg(n/i)%mod;ans%=mod; &#125; printf("%lld",(ans+mod)%mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2003 （CQOI 2006）凸多边形（半平面交）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2003-%EF%BC%88CQOI-2006%EF%BC%89%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%EF%BC%88%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2003【CQOI2006】凸多边形问题描述 逆时针给出n个凸多边形的顶点坐标，求它们交的面积。例如n=2时，两个凸多边形如下图：则相交部分的面积为5.233。 输入格式 第一行有一个整数n，表示凸多边形的个数，以下依次描述各个多边形。第i个多边形的第一行包含一个整数mi，表示多边形的边数，以下mi行每行两个整数，逆时针给出各个顶点的坐标。 输出格式 仅包含一个实数，表示相交部分的面积，保留三位小数。 样例输入 26-2 0-1 -21 -22 01 2-1 240 -31 -12 2-1 0 样例输出 5.233 提示 50%的数据满足：n=2100%的数据满足：2&lt;=n&lt;=10，3&lt;=mi&lt;=50，每维坐标为[-1000,1000]内的整数 向量表示直线，做暴力半平面交，复杂度$O(n^2)$，保存模板。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2005using namespace std;const double eps=1e-9;struct node&#123; double x,y; double operator*(const node &amp;b)const &#123;return x*b.y-y*b.x;&#125; node operator+(const node &amp;b)const &#123;return (node)&#123;x+b.x,y+b.y&#125;;&#125; node operator-(const node &amp;b)const &#123;return (node)&#123;x-b.x,y-b.y&#125;;&#125; node operator*(const double b)const &#123;return (node)&#123;b*x,b*y&#125;;&#125;&#125;A[15][N],S[N],T[N];struct nodd&#123;node p,v;&#125;Line[N];int n,m,top;node Intersection(nodd a,nodd b)&#123; double k=((a.p-b.p)*a.v)/(b.v*a.v); return b.p+b.v*k;&#125;void Cut(nodd D)&#123; int i,j,k=0; S[0]=S[top]; S[top+1]=S[1]; for(i=1;i&lt;=top;i++) &#123; if(D.v*(S[i]-D.p)&lt;-eps) &#123; if(D.v*(S[i-1]-D.p)&gt;-eps)T[++k]=Intersection(D,nodd&#123;S[i-1],S[i]-S[i-1]&#125;); if(D.v*(S[i+1]-D.p)&gt;-eps)T[++k]=Intersection(D,nodd&#123;S[i],S[i+1]-S[i]&#125;); &#125; else T[++k]=S[i]; &#125; copy(T+1,T+k+1,S+1);top=k;&#125;double Garea()&#123; int i,j,k=0; S[top+1]=S[1]; double ans=0; for(i=1;i&lt;=top;i++)ans+=S[i]*S[i+1]; return ans;&#125;int main()&#123; int i,j,k;double x,y,z; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;k); for(j=1;j&lt;=k;j++)scanf("%lf%lf",&amp;A[i][j].x,&amp;A[i][j].y); for(j=1;j&lt;=k;j++)Line[++m]=(nodd)&#123;A[i][j],A[i][j%k+1]-A[i][j]&#125;; &#125; S[++top]=(node)&#123;-1e5,1e5&#125;; S[++top]=(node)&#123;-1e5,-1e5&#125;; S[++top]=(node)&#123;1e5,-1e5&#125;; S[++top]=(node)&#123;1e5,1e5&#125;; for(i=1;i&lt;=m;i++)Cut(Line[i]); printf("%.3lf",0.5*Garea());&#125;]]></content>
      <categories>
        <category>计算几何</category>
        <category>半平面交</category>
      </categories>
      <tags>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1522 （NOI 2006）最大获利（最小割）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-1522-%EF%BC%88NOI-2006%EF%BC%89%E6%9C%80%E5%A4%A7%E8%8E%B7%E5%88%A9%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P1522【NOI2006 Day2 T1】最大获利问题描述 新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。 THU集团旗下的 CS&amp;T通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。在前期市场调查和站址勘测之后，公司得到了一共 N个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 i个通讯中转站需要的成本为 Pi（1≤i≤N）。另外公司调查得出了所有期望中的用户群，一共 M个。关于第 i个用户群的信息概括为 Ai, Bi和 Ci：这些用户会使用中转站 Ai和中转站 Bi进行通讯，公司可以获益 Ci。（1≤i≤M, 1≤Ai, Bi≤N）THU集团的 CS&amp;T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和） 输入格式 输入中第一行有两个正整数N 和M 。第二行中有 N 个整数描述每一个通讯中转站的建立成本，依次为P1, P2, …, PN 。以下 M 行，第(i + 2)行的三个数 Ai, Bi 和 Ci 描述第 i 个用户群的信息。所有变量的含义可以参见题目描述。 输出格式 你的程序只要输出一个整数，表示公司可以得到的最大净获利。 样例输入 5 51 2 3 4 51 2 32 3 41 3 31 4 24 5 3 样例输出 4 提示 80%的数据中：N≤200，M≤1 000。100%的数据中：N≤5 000，M≤50 000，0≤Ci≤100，0≤Pi≤100。 最大权闭合子图的模板题 每个客户权值为正，每个中转站权值为负，每个客户向对应两个中转站连边，求该图的最大权闭合子图。用最大权闭合子图的基本方法，正权连边到源点，负权连边到汇点，原来的边设为正无穷。即可求解。 建图方法：源点向每个客户连一条容量为$C_i$的边每个中转站向汇点连一条容量为$P_i$的边每个客户向对应的两个中转站连容量为正无穷的边 然后跑出上图的最小割，答案就是$\sum C_i - 最小割容量$切源点与客户之间的边相当于不选这个客户，那么少掉收益为$C_i$切汇点与中转站之间的边相当于选这个中转站，那么需要花费$P_i$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 500005using namespace std;int n,m,S,T,ans,maxflow;int dis[N],cnt[N];int TOT=1,LA[N],NE[N],EN[N],G[N],H[N];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; G[TOT]=z; NE[TOT]=LA[x]; LA[x]=H[x]=TOT;&#125;int SAP(int x,int f)&#123; int i,y,d=0,tmp; if(x==T)return f; for(i=LA[x];i;i=LA[x]=NE[i]) &#123; y=EN[i]; if(!G[i]||dis[x]!=dis[y]+1)continue; tmp=SAP(y,min(f-d,G[i])); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(d==f||dis[S]&gt;T)return LA[x]=H[x],d; &#125; if(!--cnt[dis[x]])dis[S]=T+1; cnt[++dis[x]]++; return LA[x]=H[x],d;&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d%d",&amp;n,&amp;m); S=n+m+1;T=S+1; for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;x); ADD(m+i,T,x); ADD(T,m+i,0); &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z);ans+=z; ADD(S,i,z);ADD(i,S,0); ADD(i,m+x,1e9);ADD(m+x,i,0); ADD(i,m+y,1e9);ADD(m+y,i,0); &#125; while(dis[S]&lt;=T)maxflow+=SAP(S,1e9); printf("%d",ans-maxflow);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUWC2018 游记]]></title>
    <url>%2F2018%2F03%2F15%2FPKUWC2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0 刚到长沙，下午签到很水的样子，人没到也能签到。 晚上做了几道模板题，感觉ACM赛还是很稳。 Day 1上午开幕式听了一波计算机史，很有意思。 笔试的数学水的不行，然而并没能做完，解答题四道，T1裸的归纳法，T2叉乘随便算一下，T3均值不等式+三角不等式，T4向量变换，直接用模长反证即可，详细情况可以去网上翻翻？ 下午机试，出人意料的是IOI赛制，五个小时三道题。 T1 给定一棵树，叶子节点带权，非叶子节点的权值有一个概率p取儿子节点的最大值，（1-p）的概率取儿子节点的最小值，最后让求根节点权值的可能取值从小到大排序后，每种权值乘上对应排名和对应取得的概率的平方求和。 显然可以想到利用归并排序直接暴力，然而只有50分。 后面发现合并两个子节点信息的时候可以利用数据结构(线段树/平衡树)优化，然而用了启发式复杂度也在$nlog^2n$，感觉卡不过就没去写，异常尴尬。 T2 给定两种牌，每种n张，每张牌带权，第一种打出后可以造成对应权值的伤害，第二种牌打出后可以使所有第一种牌的权值乘上它的权值，现在等概率抽取m张牌，但只能打出k张牌，一定用最优方案打牌，求造成伤害的最大值的期望乘上一个组合数，最后等价于求每种可能情况造成的伤害之和。 做法比较单一，就是DP，疯狂DP，显然最优策略是尽可能多用第二种牌，因此分开DP，求答案时用组合数搞一搞就行了。 T3 斗地主，给定n张牌，求地主包含这n张牌，且一定能打出春天的手牌方案数。 搜索神题，先搞出所有能春天的手牌，逐一枚举验证即可。主要思路是分成农民有炸弹和没炸弹两种。 Day 1 下来，T3集体爆零，T1 50,T2 100,混了一波。 Day 2 感觉今天绝无可能再考期望，然而…… 又是三道概率期望，真是…… T1 随机算法，给了一个求最大独立集的随机算法，求对于给定图的正确概率。 直接状压DP，据说数据很水，很多暴力的做法也过了。 T2 n个人，每个人有一个权值，每次开枪打死一个人，每个人被打死的概率与他的权值成正比，概率之和为1，求1号最后一个死亡的概率。 暴躁题，列出式子后用容斥转化，然后分治NTT加速求解。感觉自己是没学过容斥。 T3 一棵树，每次询问一个点集，求从点s出发，经过点集中每个点至少一次的期望步数。 题解是一个什么经典容斥，又感觉没学过容斥了。 然而可以直接令$F[x][S]$表示在x，还未走过$S$中点，要走完的期望步数，然后列出方程高斯消元，复杂度$O(n^32^n)$，利用树的性质，每个方程只与父亲和儿子有关，可以从下往上，从上往下消元，利用树上高斯消元优化成$n2^n$ Day 2容斥心态崩了。感觉已经GG，中午等面试名单各种搞笑。 下午居然进了面试。 三轮面试，每场间隔一个小时。 面试感觉还是有些套路，都是先自我介绍，印象比较深的问题就是：你和别人有什么不同的地方？这问题真是难啊。还有一个教授让用英文做自我介绍？ 面试完就感觉很GG了。 Day 3闭营仪式+拍照+领协议，结果拿到个进队一本，真是…… pkuwc的题还是很有意思，基本都是概率与期望，全部都是998244353，真是令人…… pkuwc比pkusc高到不知道哪里去了。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FJOI 2016 建筑师（斯特林数）]]></title>
    <url>%2F2018%2F03%2F15%2FFJOI-2016-%E5%BB%BA%E7%AD%91%E5%B8%88%EF%BC%88%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【FJOI2016】建筑师问题描述 小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 n 个建筑，每个建筑的高度是 1 到 n 之间的一个整数。 小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 A个建筑，从最右边（所有建筑都在左边）看能看到 B 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？ 如果建筑 i 的左(右)边没有任何建造比它高，则建筑 i 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。 输入格式 第一行一个整数 T，代表 T 组数据。接下来 T 行，每行三个整数 n,A,B 输出格式 对于每组数据输出一行答案 mod10^9+7。 样例输入 1 23 2 23 1 2 样例输出 1 21 样例输入 2 51 1 12 1 14 3 110 2 28 6 4 样例输出 2 1032191680 提示 对于 10% 的数据 ： 1≤n≤10对于 20% 的数据 ： 1≤n≤100对于 40% 的数据 ： 1≤n≤50000, 1≤T≤5对于 100%的数据 ：1≤n≤50000, 1≤A,B≤100, 1≤T≤200000 直接dp可以拿到40分，令$F[i][j]$表示$i$个数，从一端能看到$j$个递推即可。 标算需要用到第一类斯特林数。 考虑最高的建筑，他一定能被看到，那么他左右两边各还有$A-1,B-1$个建筑能被看到。左右是对称的，因此先讨论左边，那么显然每一个能被看到的建筑后面可能有一些建筑物被挡住了，考虑将每一个建筑物和他后面被挡住的建筑物，假设一个建筑物挡住了$d$个建筑，那么他们可能的构成方案有$d!$种，即等价于$d+1$个数，给定了一个数放于队首，其他数随意排列的方案数，等价于$d+1$个数的圆排列数目。 那么总共应该有$A-1$个这样的圆排列，同时考虑右边的情况，问题等价于将$n-1$（不考虑最高的）个数，划分成$A+B-2$个圆排列的方案数，就是第一类斯特林数，记为$S_{n-1}^{A+B-2}$，同时，这样的圆要选$A-1$个放到左边，因此还要乘上$C_{A+B-2}^{A-1}$ 因此最后的答案就是$S_{n-1}^{A+B-2}\times C_{A+B-2}^{A-1}$ 斯特林数和组合数都递推预处理，可以做到$O(1)$回答，$O(nA+A^2)$预处理 第一类斯特林数递推式：$S_{n}^{k}=(n-1)S_{n-1}^{k}+S_{n-1}^{k-1}$ 代码： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 50005using namespace std;const ll mod=1e9+7;ll T,n,A,B,C[205][105],S[N][205];void pre()&#123; ll i,j,k; for(i=0;i&lt;205;i++)C[i][0]=1; for(i=1;i&lt;205;i++) for(j=1;j&lt;=i&amp;&amp;j&lt;105;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; for(i=0;i&lt;205;i++)S[i][i]=1; for(i=2;i&lt;N;i++) for(j=1;j&lt;i&amp;&amp;j&lt;205;j++)S[i][j]=((i-1)*S[i-1][j]%mod+S[i-1][j-1])%mod;&#125;int main()&#123; scanf("%lld",&amp;T);pre(); while(T--) &#123; scanf("%lld%lld%lld",&amp;n,&amp;A,&amp;B); if(A+B&gt;n+1)&#123;puts("0");continue;&#125; printf("%lld\n",C[A+B-2][A-1]*S[n-1][A+B-2]%mod); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>斯特林数</category>
      </categories>
      <tags>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FJOI 2016 所有公共子序列问题（序列自动机+dp）]]></title>
    <url>%2F2018%2F03%2F15%2FFJOI-2016-%E6%89%80%E6%9C%89%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%88%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【FJOI2016】所有公共子序列问题问题描述 输入格式 输出格式 样例输入 6 6GCTACTGATCCT1 样例输出 AACACTATCCCCCTCTGGAGACGACTGATGCGCCGCCTGCTGTGTCGTCTGTTTTCTCTTT26 提示 1≤m,n≤3010 处理子序列问题，需要用到序列自动机。简单的来说，就是记录$son[i][j]$表示从第$i$个位置往后，第一个$j$出现的位置，容易发现，从根出发的一条路径代表了原串的一个子序列。 对于第一问，构建了自动机后直接同时在两个自动机上跑，边跑边输出就行了。 对于第二问，在序列自动机上DP，子序列个数就是从根出发的路径数，在DAG上DP一下就行了。 考虑一下就能发现，此题答案可能非常大，需要高精度。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 3020using namespace std;const ll mod=1e9;struct Big&#123; ll *S,cur; void Init() &#123; S=new long long[20]; for(int i=0;i&lt;20;i++)S[i]=0; &#125; void Output() &#123; printf("%lld",S[cur]); for(ll i=cur-1;i&gt;=0;i--)printf("%09lld",S[i]); &#125; void add(ll k) &#123; S[0]+=k;ll i=0; while(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i++]%=mod; while(S[cur+1])cur++; &#125; void Add(const Big&amp; o) &#123; ll i,r=max(o.cur,cur); for(i=0;i&lt;=r;i++) &#123; S[i]+=o.S[i]; if(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i]%=mod; &#125; cur=min(r+3,19ll);while(cur&amp;&amp;S[cur]==0)cur--; &#125;&#125;;struct PAM&#123; int son[N][56],las[56],nex[N],tot,rt; PAM() &#123; tot=rt=1; for(int i=0;i&lt;52;i++)las[i]=rt; &#125; void Ins(int c) &#123; tot++;nex[tot]=las[c]; for(int i=0;i&lt;52;i++) for(int j=las[i];j&amp;&amp;!son[j][c];j=nex[j])son[j][c]=tot; las[c]=tot; &#125;&#125;A,B;ll Gid(char c)&#123; if(c&gt;='a'&amp;&amp;c&lt;='z')return c-'a'+26; return c-'A';&#125;ll Gchar(ll x)&#123; if(x&lt;26)return x+'A'; return x-26+'a';&#125;ll m,n,ty;Big F[N][N];bool vis[N][N];char X[N],Y[N],s[N];void Get2(ll x,ll y,ll step)&#123; if(x==0||y==0)return; for(int i=0;i&lt;step;i++)putchar(s[i]);puts(""); for(int i=0;i&lt;52;i++) &#123; s[step]=Gchar(i); Get2(A.son[x][i],B.son[y][i],step+1); &#125;&#125;void Get1(ll x,ll y)&#123; if(vis[x][y])return; F[x][y].Init(); F[x][y].add(1); vis[x][y]=1; for(int i=0;i&lt;52;i++) &#123; if(A.son[x][i]==0||B.son[y][i]==0)continue; Get1(A.son[x][i],B.son[y][i]); F[x][y].Add(F[A.son[x][i]][B.son[y][i]]); &#125;&#125;int main()&#123; int i,j,k; scanf("%lld%lld",&amp;n,&amp;m); scanf("%s%s",X,Y); for(i=0;i&lt;n;i++)A.Ins(Gid(X[i])); for(i=0;i&lt;m;i++)B.Ins(Gid(Y[i])); scanf("%lld",&amp;ty); if(ty==1)Get2(1,1,0); Get1(1,1); F[1][1].Output();&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>序列自动机</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4385 简单计算（矩阵乘法）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4385-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%EF%BC%88%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4385简单计算问题描述 给你三个整数 N, x, 和 M, 计算$\sum_{k=1}^{N}k^xx^k$ 输入格式 一行，三个整数N, x, 和 M, 输出格式 一行，一个整数，表示计算结果 样例输入 1 100 1 10000 样例输出 1 5050 样例输入 2 3 4 1000 样例输出 2 444 提示 1 ≤ N, M ≤ 2*10^91 ≤ x ≤ 50. 注意到x很小，因此对$k^x$二项式展开，考虑推到$(k+1)^x$，显然发现可以利用矩阵乘法进行递推。至于$x^k$，只需要将构造的矩阵中每个数都乘上$x$即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll n,m,p,A[60][60],ans[60][60];void C(ll x[60][60],ll y[60][60])&#123; ll z[60][60],i,j,k; memset(z,0,sizeof(z)); for(i=0;i&lt;=m+1;i++) for(j=0;j&lt;=m+1;j++) for(k=0;k&lt;=m+1;k++)z[i][j]=(z[i][j]+x[i][k]*y[k][j]%p)%p; memcpy(x,z,sizeof(z));&#125;void KSM(ll b)&#123; int i; for(i=0;i&lt;=m+1;i++)ans[i][i]=1; while(b) &#123; if(b&amp;1)C(ans,A); b&gt;&gt;=1;C(A,A); &#125; memset(A,0,sizeof(A)); for(i=0;i&lt;=m;i++)A[0][i]=m; C(A,ans); printf("%lld",A[0][m+1]);&#125;int main()&#123; int i,j,k; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;p); for(i=0;i&lt;=m;i++)A[0][i]=1; for(i=1;i&lt;=m;i++) for(j=1;j&lt;=i;j++)A[j][i]=(A[j-1][i-1]+A[j][i-1])%p; for(i=0;i&lt;=m;i++) for(j=0;j&lt;=i;j++)A[j][i]=A[j][i]*m%p; A[m][m+1]=A[m+1][m+1]=1; KSM(n);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3254 （ZJOI 2015）幻想乡战略游戏（点分治）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3254-%EF%BC%88ZJOI-2015%EF%BC%89%E5%B9%BB%E6%83%B3%E4%B9%A1%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3254【ZJOI2015 Day1】幻想乡战略游戏问题描述 傲娇少女幽香正在玩一个非常有趣的战略类游戏，本来这个游戏的地图其实还不算太大，幽香还能管得过来，但是不知道为什么现在的网游厂商把游戏的地图越做越大，以至于幽香一眼根本看不过来，更别说和别人打仗了。 在打仗之前，幽香现在面临一个非常基本的管理问题需要解决。 整个地图是一个树结构，一共有n块空地，这些空地被n-1条带权边连接起来，使得每两个点之间有一条唯一的路径将它们连接起来。在游戏中，幽香可能在空地上增加或者减少一些军队。同时，幽香可以在一个空地上放置一个补给站。 如果补给站在点u上，并且空地v上有dv个单位的军队，那么幽香每天就要花费dv×dist(u,v)的金钱来补给这些军队。由于幽香需要补给所有的军队，因此幽香总共就要花费的代价。 其中dist(u,v)表示u个v在树上的距离（唯一路径的权和）。 因为游戏的规定，幽香只能选择一个空地作为补给站。在游戏的过程中，幽香可能会在某些空地上制造一些军队，也可能会减少某些空地上的军队，进行了这样的操作以后，出于经济上的考虑，幽香往往可以移动他的补给站从而省一些钱。但是由于这个游戏的地图是在太大了，幽香无法轻易的进行最优的安排，你能帮帮她吗？ 输入格式 第一行两个数n和Q分别表示树的点数和幽香操作的个数，其中点从1到n标号。 接下来n-1行，每行三个正整数a,b,c，表示a和b之间有一条边权为c的边。 接下来Q行，每行两个数u,e，表示幽香在点u上放了e单位个军队（如果e&lt;0，就相当于是幽香在u上减少了|e|单位个军队，说白了就是du←du+e）。数据保证任何时刻每个点上的军队数量都是非负的。 输出格式 对于幽香的每个操作，输出操作完成以后，每天的最小花费，也即如果幽香选择最优的补给点进行补给时的花费。 样例输入 10 51 2 12 3 12 4 11 5 12 6 12 7 15 8 17 9 11 10 13 12 18 13 14 1 样例输出 01456 提示 对于所有数据，1&lt;=c&lt;=1000, 0&lt;=|e|&lt;=1000, n&lt;=105, Q&lt;=105。 非常神奇的是，对于所有数据，这棵树所有节点的度数都不超过20，并且n,Q&gt;=1。 此题的关键是动态查找带权重心，而关于带权重心，对于一个点$u$，如果它不是带权重心，那么带权重心只可能在它权值最大的儿子里面，如果不存在比他更有的儿子，那么他就是带权重心。 因此只需要找到带权重心后统计答案即可，每次从根节点开始找，直到找到带权重心为止，考虑到这样找可能深度比较深，用点分治维护，每次找到一个更优的儿子的时候，跳到这个儿子所在子树的点分治重心即可。 另外需要支持修改。复杂度$O(nlog^2n)$ 另外，由于这个题数据的问题，导致每次暴力从上次的重心开始，在原树上直接转移重心比点分治跑得更快。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 400005#define ll long longusing namespace std;ll n,q,E[N],Top,Tot;ll Min,si[N],rt;bool mark[N];ll TOT,LA[N],NE[N],EN[N],LE[N];ll V[N],S[N],D[N],dep[N],fa[N],to[N][25],TO[N][25],ace[N][25],dis[N][25],S1[N][25],S2[N][25];void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Grt(ll x,ll s,ll f)&#123; ll i,y,Max=0;si[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y]||y==f)continue; Grt(y,s,x);si[x]+=si[y]; if(si[y]&gt;Max)Max=si[y]; &#125; if(s-si[x]&gt;Max)Max=s-si[x]; if(Max&lt;Min)Min=Max,rt=x;&#125;void Gdis(ll x,ll f,ll d,ll p,ll ty)&#123; ace[x][dep[p]]=ty; dis[x][dep[p]]=d; S1[p][ty]+=E[x]; S2[p][ty]+=E[x]*d; for(ll i=LA[x];i;i=NE[i]) if(EN[i]!=f&amp;&amp;!mark[EN[i]])Gdis(EN[i],x,d+LE[i],p,ty);&#125;void DC(ll x)&#123; int i,y;mark[x]=1;V[x]=E[x]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y])continue; D[x]++;to[x][D[x]]=y; Min=1e9;Grt(y,si[y],0); Gdis(y,0,LE[i],x,D[x]); TO[x][D[x]]=rt; V[x]+=S1[x][D[x]]; S[x]+=S2[x][D[x]]; &#125; for(i=1;i&lt;=D[x];i++) &#123; y=TO[x][i]; dep[y]=dep[x]+1; fa[y]=x; DC(y); &#125;&#125;void CHA(ll x,ll d)&#123; ll i,j,k,y,p; E[x]+=d;V[x]+=d; p=fa[x]; while(p) &#123; k=ace[x][dep[p]]; V[p]+=d; S[p]+=d*dis[x][dep[p]]; S1[p][k]+=d; S2[p][k]+=d*dis[x][dep[p]]; p=fa[p]; &#125;&#125;ll Gans(ll x)&#123; ll i,y,p=fa[x],s=S[x]; while(p) &#123; s+=E[p]*dis[x][dep[p]]; for(i=1;i&lt;=D[p];i++) &#123; if(i==ace[x][dep[p]])continue; s+=S2[p][i]+S1[p][i]*dis[x][dep[p]]; &#125; p=fa[p]; &#125; return s;&#125;ll Find(ll x)&#123; ll i,y,p=x,las,Las=Gans(p),t; while(p) &#123; las=p; for(i=1;i&lt;=D[p];i++) &#123; y=to[p][i];t=Gans(y); if(t&lt;Las)&#123;p=TO[p][i];Las=Gans(p);break;&#125; &#125; if(las==p)break; &#125; return Las;&#125;int main_main()&#123; ll i,j,k,x,y,z; scanf("%lld%lld",&amp;n,&amp;q); for(i=1;i&lt;n;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; Min=1e9;Grt(1,n,0);Top=rt;DC(rt); while(q--) &#123; scanf("%lld%lld",&amp;x,&amp;k); CHA(x,k);Tot+=k; y=Find(Top); printf("%lld\n",y); &#125;&#125;const int main_stack=16;char my_stack[128&lt;&lt;20];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2841 （SDOI 2014）数表（莫比乌斯反演+树状数组+线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2841-%EF%BC%88SDOI-2014%EF%BC%89%E6%95%B0%E8%A1%A8%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2841【SDOI2014 R1D1】数表问题描述 有一张n*m的数表，其第i行第j列(1&lt;=i&lt;=n,1&lt;=j&lt;=m)的数值为能同时整除i和j的所有自然数之和。给定a，计算数表中不大于a的数之和。 输入格式 输入包含多组数据。输入的第一行一个整数Q表示测试点内的数据组数，接下来Q行，每行三个整数n,m,a描述一组数据。 输出格式 对每组数据，输出一行一个整数，表示答案模2^31的值。 样例输入 24 4 310 10 5 样例输出 20148 提示 对于30%的数据，1&lt;=n,m&lt;=400,1&lt;=Q&lt;=200对于另外30%的数据，1&lt;=n,m&lt;=10^5,1&lt;=Q&lt;=10对于100%的数据，1&lt;=n,m&lt;=10^5,1&lt;=Q&lt;=20000,0&lt;=a&lt;=10^9 容易得到对于单次询问$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j)),[\sigma(gcd(i,j))&lt;=a]$$那么，推导一番$$Ans=\sum_{d=1}^{N}\sigma(d)\sum_{i=1}^{n}\sum_{j=1}^{m}1[gcd(i,j)=d],N=min(n,m)$$然后，反演一下$$Ans=\sum_{d=1}^{N}\sigma(d)\sum_{d|K}^{N}\mu(\frac{K}{d})\lfloor{\frac{n}{K}}\rfloor\lfloor{\frac{m}{K}}\rfloor=\sum_{K=1}^{N}\lfloor{\frac{n}{K}}\rfloor\lfloor{\frac{m}{K}}\rfloor\sum_{d|K}\sigma(d)\mu(\frac{K}{d}),\sigma(d)&lt;=a$$注意到$\sum_{d|K}\sigma(d)\mu(\frac{K}{d})$是个积性函数，用线性筛预处理，但是只有$\sigma(d)&lt;=a$的项才对答案有贡献，因此离线处理，对询问按照a排序，然后每次将小于等于a的那些项暴力枚举一下倍数，更新到树状数组里面，查询的时候直接用。复杂度为$O(n\ ln\ n+m\sqrt{n}log_2n)$左右 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 100005using namespace std;const ll mod=(1ll&lt;&lt;31);struct node&#123;ll n,m,a,id;&#125;K[N],g[N];bool cmp(node aa,node bb)&#123;return aa.a&lt;bb.a;&#125;ll T,P[N],tot,mu[N],pc[N],pd[N],G[N],Ans[N];void EU()&#123; ll i,j;mu[1]=1;g[1].a=1; for(i=1;i&lt;N;i++)g[i].n=i; for(i=2;i&lt;N;i++) &#123; if(!g[i].a)P[++tot]=i,mu[i]=-1,g[i].a=i+1,pc[i]=i+1,pd[i]=tot; for(j=1;j&lt;=tot&amp;&amp;P[j]*i&lt;N;j++) if(i%P[j]) &#123; pc[i*P[j]]=P[j]+1; pd[i*P[j]]=j; mu[i*P[j]]=-mu[i]; g[i*P[j]].a=g[i].a*pc[i*P[j]]%mod; &#125; else &#123; pc[i*P[j]]=pd[i]==j?pc[i]*P[j]+1:P[j]+1; pd[i*P[j]]=j; g[i*P[j]].a=pd[i]==j?g[i].a/pc[i]*pc[i*P[j]]:g[i].a*pc[i*P[j]]; pc[i*P[j]]%=mod; g[i*P[j]].a%=mod; &#125; &#125; sort(g+1,g+N,cmp);&#125;void MD(ll x,ll d)&#123;for(ll i=x;i&lt;N;i+=(i&amp;-i))G[i]+=d,G[i]%=mod;&#125;ll GS(ll x)&#123; ll i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=G[i],sum%=mod; return sum;&#125;int main()&#123; ll i,j,p,k=1,ans;EU(); scanf("%lld",&amp;T); for(i=1;i&lt;=T;i++)scanf("%lld%lld%lld",&amp;K[i].n,&amp;K[i].m,&amp;K[i].a),K[i].id=i; sort(K+1,K+T+1,cmp); for(i=1;i&lt;=T;i++) &#123; while(g[k].a&lt;=K[i].a) &#123; for(j=g[k].n;j&lt;N;j+=g[k].n)MD(j,g[k].a*mu[j/g[k].n]%mod); k++; &#125; ans=0; for(j=1;j&lt;=K[i].n&amp;&amp;j&lt;=K[i].m;j=p+1) &#123; p=min(K[i].n/(K[i].n/j),K[i].m/(K[i].m/j)); ans+=(K[i].n/j)*(K[i].m/j)%mod*(GS(p)-GS(j-1))%mod;ans%=mod; &#125; Ans[K[i].id]=(ans+mod)%mod; &#125; for(i=1;i&lt;=T;i++)printf("%lld\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>数学</category>
        <category>树状数组</category>
        <category>莫比乌斯反演</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>莫比乌斯反演</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2751 蒲公英（分块）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2751-%E8%92%B2%E5%85%AC%E8%8B%B1%EF%BC%88%E5%88%86%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2751【Violet VI】蒲公英问题描述 在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。为了简化起见，我们把所有的蒲公英看成一个长度为n的序列(a1,a2,a3,a4,…an),其中ai为一个正整数，表示第i棵蒲公英的种类编号。而每次询问一个区间[l,r],你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同,则输出种类编号最小的那个。注意，你的算法必须是在线的。 输入格式 第一行两个整数n,m，表示有n株蒲公英，m次询问。接下来一行 n 个空格分隔的整数ai，表示蒲公英的种类再接下来m行每行两个整数l0,r0,我们令上次询问的结果为x（如果这是第一次询问，则x=0)。令l=(l0+x-1)mod n +1,r=(r0+x-1)mod n +1,如果l&gt;r，则交换l,r。最终的询问区间为[l,r]。 输出格式 输出m行。每行一个整数，表示每次询问的结果。 样例输入 6 31 2 3 2 1 21 53 61 5 样例输出 121 提示 对于 20% 的数据，保证1&lt;=n,m&lt;=3000。对于 100% 的数据，保证1&lt;=n&lt;=40000，1&lt;=m&lt;=50000，1&lt;=ai&lt;=10^9 区间众数问题，分块的经典解法，两种处理方法 做法一：分成$n^{\frac {1}{3}}$块，预处理$B[i][j]$表示第$i$块到第$j$块的信息，维护每个数出现的次数，并记录区间众数。查询的时候，先找到覆盖的最大整块区间$[L,R]$将$B[L][R]$复制出来，然后将两边剩下的数暴力插入。复杂度$O(n^{\frac{5}{3}})$ 做法二：分成$\sqrt{n}$块，预处理$A[i][j]$表示第$i$块到第$j$块中的众数，并记录众数的出现次数查询的时候，同样找到区间$[L,R]$，答案只可能是$A[L][R]$或两侧剩下的数，枚举两侧剩下的数，然后查询一下他在区间中出现的次数，更新答案即可。关于查询一个数在区间中的出现次数，可以用vector记下每个数出现位置然后二分查找，复杂度$O(n\sqrt{n}log_2{n})$或者预处理$S[i][j][k]$，表示第$i$块中，前$j$个位置，数字$k$出现次数，$SS[i][k]$，表示前$i$块中，数字$k$出现的次数，然后查询的时候就可以直接用了（$S$可以不用处理，每次暴力跑一边两边剩下的数就行了），由于每块最多$\sqrt{n}$个数，因此预处理的时空复杂度都是$O(n\sqrt{n})$，总时间复杂度也是$O(n\sqrt{n})$ 做法一代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 50005using namespace std;struct node&#123; int a,b,c[N]; void Ins(int x) &#123; c[x]++; if(c[x]&gt;b||(c[x]==b&amp;&amp;x&lt;a))a=x,b=c[x]; &#125; void Del(int x)&#123;c[x]--;&#125;&#125;C[40][40],tmp;int n,m,A[N],B[N],id[N],lp[N],rp[N],S,Cnt;int GS(int l,int r)&#123; int i,j,k,x,y,p,q; if(id[l]==id[r]) &#123; for(i=l;i&lt;=r;i++)tmp.Ins(A[i]); k=tmp.a;tmp.a=tmp.b=0; for(i=l;i&lt;=r;i++)tmp.Del(A[i]); return B[k]; &#125; x=id[l]+1;y=id[r]-1; p=C[x][y].a;q=C[x][y].b; for(i=l;i&lt;lp[x];i++)C[x][y].Ins(A[i]); for(i=rp[y]+1;i&lt;=r;i++)C[x][y].Ins(A[i]); k=C[x][y].a;C[x][y].a=p;C[x][y].b=q; for(i=l;i&lt;lp[x];i++)C[x][y].Del(A[i]); for(i=rp[y]+1;i&lt;=r;i++)C[x][y].Del(A[i]); return B[k];&#125;int main()&#123; int i,j,k,x,y,ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),B[i]=A[i]; sort(B+1,B+n+1); for(i=1;i&lt;=n;i++)A[i]=lower_bound(B+1,B+n+1,A[i])-B; S=pow(n,2.0/3);j=1; for(i=1;i&lt;=n;i++) &#123; id[i]=i%S?j:j++; if(!lp[id[i]])lp[id[i]]=i; rp[id[i]]=max(rp[id[i]],i); Cnt=max(Cnt,id[i]); &#125; for(i=1;i&lt;=Cnt;i++) for(j=i;j&lt;=Cnt;j++) for(k=lp[i];k&lt;=rp[j];k++)C[i][j].Ins(A[k]); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); x=(x+ans-1)%n+1; y=(y+ans-1)%n+1; if(x&gt;y)swap(x,y); ans=GS(x,y); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2703 （WC 2014）紫荆花之恋 （点分治+平衡树+替罪羊）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2703-%EF%BC%88WC-2014%EF%BC%89%E7%B4%AB%E8%8D%86%E8%8A%B1%E4%B9%8B%E6%81%8B-%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB-%E5%B9%B3%E8%A1%A1%E6%A0%91-%E6%9B%BF%E7%BD%AA%E7%BE%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2703【WC2014】紫荆花之恋（强数据版）问题描述 强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花废物的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。仔细看看的话，这棵大树实际上是一个带权树。每个时刻他会长出一个新的叶子节点。每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵i都有一个感受能力ri，小精灵i,j成为朋友当且仅当在树上i和j的距离dist(i,j)&lt;=ri+rj，其中dist(i,j)表示在这棵树上i和j的唯一路径上所有边的边权和。强强和萌萌很好奇每次新长出了一个叶子节点之后这棵树上总共有几对朋友。我们假定这棵树一开始为空，节点按照加入的顺序从1开始编号。由于强强非常好奇，你必须在每次出现新的节点后马上给出总共的朋友对数不能拖延哦。 输入格式 输入文件共有n+2行。第一行包含一个正整数T，表示测试点编号。第二行包含一个正整数n，表示总共要加入的节点数。我们令加入前的总工朋友对数是last_ans，在一开始时last_ans=0。接下来n行中第i行有三个数ai,ci,ri，表示节点i的父亲节点的编号为(ai xor ( last_ans mod 109))，与父亲节点之间的边权为ci，节点i上小精灵的感受能力为ri。注意a1=c1=0，表示1号点事根节点。对于i&gt;=2，父亲节点的编号至少是1，至多是i-1。 输出格式 输出文件包含n行，每行输出1个整数，表示加入第i个点之后，树上共有几对朋友。 样例输入 050 0 61 2 40 9 40 5 50 2 4 样例输出 01247 考虑点分治，一个点对合法仅当他们不在同一颗子树上且$dep[i]+dep[j]&lt;=r[i]+r[j]，dep表示点到根的距离$移项得到$dep[i]-r[i]&lt;=r[j]-dep[j]$，那么只需要维护$dep[i]-r[i]$的信息即可。需要支持添加，查找比某个数小的数的个数，那么用平衡树。 查询点分治树上两点距离的时候在原树上暴力LCA查找即可。 关于加点，直接在点分治树上添加即可，然后进行链查询，链修改，但是这样可能使得点分治树非常的不平衡采用替罪羊树的思想解决，设定常数$ki$，当过于不平衡时重构即可，这里$ki$大概取$0.8?$复杂度$O(nlog^3n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#define ll long long#define N 300005#define M 12345678using namespace std;const int mod=1e9;const double ki=0.8;typedef pair&lt;int,int&gt; par;int n,R[N];ll Ans;int fa[N][20],dis[N][20],dep[N],S=18;int TOT,LA[N],NE[N],EN[N],LE[N];int Art[N],Ort[N],tot,ls[M],rs[M],v[M],w[M],si[M];int rt,Min,SS[N],Fa[N],Si[N];vector&lt;int&gt;to[N];bool mark[N];queue&lt;int&gt;bin;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y],s=0; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)s+=dis[x][i],x=fa[x][i]; if(x==y)return s; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) &#123; s+=dis[x][i]+dis[y][i]; x=fa[x][i];y=fa[y][i]; &#125; return s+dis[x][0]+dis[y][0];&#125;void MT(int x)&#123;si[x]=si[ls[x]]+si[rs[x]]+1;&#125;int Merge(int x,int y)&#123; if(!x||!y)return x|y; if(w[x]&lt;w[y]) &#123; rs[x]=Merge(rs[x],y); MT(x);return x; &#125; else &#123; ls[y]=Merge(x,ls[y]); MT(y);return y; &#125;&#125;par Split(int x,int k)&#123; if(k==0)return par(0,x); int l=ls[x],r=rs[x]; if(k==si[l])return ls[x]=0,MT(x),par(l,x); if(k==si[l]+1)return rs[x]=0,MT(x),par(x,r); if(k&lt;si[l]) &#123; par tmp=Split(l,k); ls[x]=tmp.second;MT(x); return par(tmp.first,x); &#125; else &#123; par tmp=Split(r,k-si[l]-1); rs[x]=tmp.first;MT(x); return par(x,tmp.second); &#125;&#125;int Rank(int x,int p)&#123; if(p==0)return 0; if(v[p]&lt;=x)return si[ls[p]]+1+Rank(x,rs[p]); return Rank(x,ls[p]);&#125;int Ins(int x,int &amp;p)&#123; int t,k=Rank(x,p); par tmp=Split(p,k); if(bin.size())t=bin.front(),bin.pop(); else t=++tot; ls[t]=rs[t]=0; v[t]=x;w[t]=rand();si[t]=1; p=Merge(tmp.first,t); p=Merge(p,tmp.second);&#125;void Gmark(int x)&#123; mark[x]=0; for(int i=0;i&lt;to[x].size();i++)Gmark(to[x][i]);&#125;void Grt(int x,int s,int f)&#123; int i,y,Max=0;SS[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y==f||mark[y])continue; Grt(y,s,x);SS[x]+=SS[y]; if(SS[y]&gt;Max)Max=SS[y]; &#125; if(s-Max&gt;Max)Max=s-Max; if(Max&lt;Min)Min=Max,rt=x;&#125;void Gdis(int x,int d,int f,int &amp;k1,int &amp;k2)&#123; Ins(d-R[x],k1);Ins(d-R[x],k2); for(int i=LA[x];i;i=NE[i]) if(!mark[EN[i]]&amp;&amp;EN[i]!=f)Gdis(EN[i],d+LE[i],x,k1,k2);&#125;void Del(int x)&#123; if(!x)return; bin.push(x); Del(ls[x]); Del(rs[x]); ls[x]=rs[x]=0;&#125;void ReDC(int x)&#123; int i,y;mark[x]=1;Si[x]=1; to[x].clear(); Del(Art[x]);Art[x]=0; Ins(-R[x],Art[x]); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y])continue; Min=1e9;Grt(y,SS[y],x); to[x].push_back(rt); Fa[rt]=x;Del(Ort[rt]);Ort[rt]=0; Gdis(y,LE[i],0,Art[x],Ort[rt]); &#125; for(i=0;i&lt;to[x].size();i++)ReDC(to[x][i]),Si[x]+=Si[to[x][i]];&#125;void Rebuild(int x)&#123; int i,p=Fa[x];Gmark(x); Min=1e9;Grt(x,Si[x],p); if(p) &#123; for(i=0;i&lt;to[p].size();i++) if(to[p][i]==x)&#123;to[p][i]=rt;break;&#125; &#125; Ort[rt]=Ort[x]; if(x!=rt)Ort[x]=0;//！！！！！！ Fa[rt]=Fa[x];ReDC(rt);&#125;void Solve(int x,int f,int le)&#123; int i,j,k=f,d,p=Fa[f],las=x;mark[x]=1; Si[x]=1;Fa[x]=f;Si[f]++; Ins(-R[x],Art[x]); to[f].push_back(x); Ins(le-R[x],Ort[x]); Ans+=Rank(R[x]-le,Art[f]); Ins(le-R[x],Art[f]); while(p) &#123; d=LCA(x,p); Ans+=Rank(R[x]-d,Art[p]); Ans-=Rank(R[x]-d,Ort[k]); Ins(d-R[x],Art[p]); Ins(d-R[x],Ort[k]); Si[p]++;k=p;p=Fa[p]; &#125; for(p=x;Fa[p];p=Fa[p]) if(1.0*Si[p]&gt;=1.0*Si[Fa[p]]*ki)las=Fa[p]; if(las!=x)Rebuild(las);&#125;int main_main()&#123; srand(time(NULL)); int i,j,k,x,y,z; scanf("%d%d",&amp;x,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(i==1) &#123; printf("0\n"); R[i]=z;Si[i]=1; Ins(-R[i],Art[i]); mark[i]=1;continue; &#125; fa[i][0]=x^(Ans%mod); dep[i]=dep[fa[i][0]]+1; dis[i][0]=y;R[i]=z; ADD(fa[i][0],i,y); ADD(i,fa[i][0],y); for(j=1;j&lt;=S;j++)fa[i][j]=fa[fa[i][j-1]][j-1],dis[i][j]=dis[fa[i][j-1]][j-1]+dis[i][j-1]; Solve(i,fa[i][0],y); printf("%lld\n",Ans); &#125;&#125;const int main_stack=16;char my_stack[128&lt;&lt;21];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>分治法</category>
        <category>平衡树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2654 （SDOI 2011）消耗战 （虚树+树形DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2654-%EF%BC%88SDOI-2011%EF%BC%89%E6%B6%88%E8%80%97%E6%88%98-%EF%BC%88%E8%99%9A%E6%A0%91-%E6%A0%91%E5%BD%A2DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2654【SDOI2011第2轮DAY2】消耗战问题描述 在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。 侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。 输入格式 第一行一个整数n，代表岛屿数量。接下来n-1行，每行三个整数u,v,w，代表u号岛屿和v号岛屿由一条代价为c的桥梁直接相连，保证1&lt;=u,v&lt;=n且1&lt;=c&lt;=100000。第n+1行，一个整数m，代表敌方机器能使用的次数。 输出格式 输出有m行，分别代表每次任务的最小代价。 样例输入 101 5 131 9 62 1 192 4 82 3 915 6 87 5 47 8 3110 7 932 10 64 5 7 8 33 9 4 6 样例输出 123222 提示 对于10%的数据，2&lt;=n&lt;=10,1&lt;=m&lt;=5,1&lt;=ki&lt;=n-1对于20%的数据，2&lt;=n&lt;=100,1&lt;=m&lt;=100,1&lt;=ki&lt;=min(10,n-1)对于40%的数据，2&lt;=n&lt;=1000,m&gt;=1,sigma(ki)&lt;=500000,1&lt;=ki&lt;=min(15,n-1)对于100%的数据，2&lt;=n&lt;=250000,m&gt;=1,sigma(ki)&lt;=500000,1&lt;=ki&lt;=n-1 此题是虚树的模板题，令$F[x]$表示将$x$和其子树中的能源点切断的最小代价，转移方程就是$$F[x]=\sum dis(x,y),y有能源+\sum min(dis(x,y),F[y]),y没有能源$$关键在于不能进行m次DP，注意到题目的特殊条件，构造虚树在虚树上DP即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 500005#define ll long longusing namespace std;int n,m,S=19,fa[N][20],dis[N][20];int dfn[N],VT,dep[N],P[N],cnt,Q[N],top;ll F[N];int TOT,LA[N],NE[N],EN[N],LE[N];int tot,la[N],ne[N],en[N],le[N];bool mark[N];bool cmp(int x,int y)&#123;return dfn[x]&lt;dfn[y];&#125;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void add(int x,int y,int z)&#123; tot++; en[tot]=y; le[tot]=z; ne[tot]=la[x]; la[x]=tot;&#125;void DFS(int x,int f)&#123; int i,y; dfn[x]=++VT; fa[x][0]=f; dep[x]=dep[f]+1; for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1],dis[x][i]=min(dis[x][i-1],dis[fa[x][i-1]][i-1]); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)dis[y][0]=LE[i],DFS(y,x); &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)x=fa[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int Gdis(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y],ans=1e9; for(i=0;i&lt;=S;i++) if(t&gt;&gt;i&amp;1)ans=min(ans,dis[x][i]),x=fa[x][i]; return ans;&#125;void BT()&#123; int i,j,k,lca; top=0;Q[++top]=1; for(i=1;i&lt;=cnt;i++) &#123; lca=LCA(P[i],Q[top]); if(dep[lca]==dep[Q[top]])&#123;Q[++top]=P[i];continue;&#125; while(dep[lca]&lt;dep[Q[top-1]]) &#123; add(Q[top-1],Q[top],Gdis(Q[top],Q[top-1])); top--; &#125; add(lca,Q[top],Gdis(lca,Q[top]));top--; if(Q[top]!=lca)Q[++top]=lca; Q[++top]=P[i]; &#125; while(--top)add(Q[top],Q[top+1],Gdis(Q[top],Q[top+1]));&#125;void DP(int x)&#123; F[x]=0;int i,y; for(i=la[x];i;i=ne[i]) &#123; y=en[i];DP(y); if(mark[y])F[x]+=le[i]; else F[x]+=min(1ll*le[i],F[y]); mark[y]=0; &#125; la[x]=0;&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; DFS(1,0); scanf("%d",&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;cnt); for(j=1;j&lt;=cnt;j++)scanf("%d",&amp;P[j]),mark[P[j]]=1; sort(P+1,P+cnt+1,cmp);tot=0; BT();DP(1); printf("%lld\n",F[1]); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>虚树</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4343 最小流：有源汇上下界 （上下界网络流）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4343-%E6%9C%80%E5%B0%8F%E6%B5%81%EF%BC%9A%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C-%EF%BC%88%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4343最小流:有源汇上下界问题描述 n 个点，m 条边，每条边 e有一个流量下界 lower(e) 和流量上界 upper(e)，给定源点 s 与汇点 t，求源点到汇点的最小流。 输入格式 第一行两个正整数 n、m、s、t。之后的 m行，每行四个整数 s、t、lower、upper 。 输出格式 如果无解，输出一行 please go home to sleep。否则输出最小流。 样例输入 7 12 6 76 1 0 21474836471 7 0 21474836476 2 0 21474836472 7 0 21474836476 3 0 21474836473 7 0 21474836476 4 0 21474836474 7 0 21474836476 5 0 21474836475 7 0 21474836475 1 1 21474836473 4 1 2147483647 样例输出 2 提示 1≤n≤50003,1≤m≤125003 上下界网络流模板题，然而此题有一组菊花图的数据，需要在SAP时避免重复讨论边，具体实现参见代码。处理菊花图非常的优秀 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 150000#define M 500000using namespace std;int TT,n,m,S,T,ans,lim,D[N],Lim,dis[N],cnt[N];int TOT=1,LA[N],NE[M],EN[M],G[M],ty[M],H[M];void ADD(int x,int y,int z,int c)&#123; TOT++; EN[TOT]=y; H[x]=TOT; G[TOT]=z; ty[TOT]=c; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int SAP(int x,int f)&#123; int i,y,d=0,tmp; if(x==T)return f; for(i=LA[x];i;LA[x]=i=NE[i])//!!!! &#123; y=EN[i]; if(!G[i]||ty[i]&gt;Lim||dis[x]!=dis[y]+1)continue; tmp=SAP(y,min(f-d,G[i])); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(d==f||dis[S]&gt;T)return d; &#125; LA[x]=H[x];//!!!! if(!--cnt[dis[x]])dis[S]=T+1; cnt[++dis[x]]++; return d;&#125;int main()&#123; int i,j,x,y,u,d,s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;d,&amp;u); ADD(x,y,u-d,1);ADD(y,x,0,1); D[x]-=d;D[y]+=d; &#125; S=n+1;T=S+1; for(i=1;i&lt;=n;i++) if(D[i]&gt;0)ADD(S,i,D[i],1),ADD(i,S,0,1),lim+=D[i]; else if(D[i]&lt;0)ADD(i,T,-D[i],1),ADD(T,i,0,1); ADD(t,s,1e9,2);ADD(s,t,0,2); Lim=1;while(dis[S]&lt;=T)ans+=SAP(S,1e9); memset(dis,0,sizeof(dis)); memset(cnt,0,sizeof(cnt)); Lim=2; while(dis[S]&lt;=T)ans+=SAP(S,1e9); if(ans==lim)printf("%d",G[TOT]); else printf("please go home to sleep");&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2284 （BZOJ 4213）贪吃蛇 （上下界网络流）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2284-%EF%BC%88BZOJ-4213%EF%BC%89%E8%B4%AA%E5%90%83%E8%9B%87-%EF%BC%88%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2284【L1 SOLO 第九场 HN11 day1】贪吃蛇问题描述 一些蛇覆盖了一个网格。每个格子要么是一个障碍物，要么是蛇的一部分。每条蛇占据了一条折线（拐角处只能水平和竖直连接），且至少占据两个格子。蛇与蛇之间不重叠，蛇也不会与自己重叠。每条蛇还必须满足以下两个条件中的一个： 两个端点所在的格子在网格的边界。 蛇构成一个环，即两个端点相邻（垂直或水平，不能斜着），至少要占据4个格子（否则没法形成环）。给定一个网格，用r * c的字符矩阵描述：’#’代表障碍物，’.’代表空地。在满足前面所述的条件下覆盖所有空地，并使得端点在网格边界（即不构成环）的蛇尽量少。例如，以下网格：…….#.##..#….….#..##.#.……可以由下面三种方案覆盖。还有其它的方案，但是没有仅用一条不构成环的蛇就覆盖整个网格的方案。给定一个网格的描述，输出最少需要多少条不构成环的蛇来覆盖这个网格。如果不存在能够覆盖网格的方案，输出-1。 输入格式 的空白字符，每行之后都有换行符。 输出格式 输出满足题目要求的那个整数。 样例输入 …….#.##..#….….#..##.#.…… 样例输出 2 一道很玄的题目。 首先染色，染成黑白两色，然后从源点连到白色格子连一条上界为2，下界也为2的边然后从黑色格子连到汇点连一条上界为2，下界也为2的边然后从白色格子往相邻的格子连一条容量为1的边然后从源点连到边界上的黑色格子，连一条容量为1，费用为1的边然后从边界上的白色格子连到汇点，连一条容量为1，费用为1的边求上图的最小费用最大流即可。答案就是费用/2 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 300#define M 5000using namespace std;int n,m,S,T,P,s,t,id[N][N],D[N],lim;char map[N][N];int TOT=1,LA[N],NE[M],EN[M],G[M],LE[M];int slk[N],dis[N],maxflow,mincost;bool mark[N];int dx[4]=&#123;0,0,1,-1&#125;,dy[4]=&#123;1,-1,0,0&#125;;void ADD(int x,int y,int z,int c)&#123; TOT++; EN[TOT]=y; G[TOT]=z; LE[TOT]=c; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int FP(int x,int f)&#123; int i,y,tmp,t,d=0; if(x==T)return maxflow+=f,mincost+=f*dis[S],f; mark[x]=1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(!G[i]||mark[y])continue; t=dis[y]+LE[i]-dis[x]; if(!t) &#123; tmp=FP(y,min(f-d,G[i])); d+=tmp;G[i]-=tmp;G[i^1]+=tmp; if(f==d)return f; &#125; else slk[y]=min(slk[y],t); &#125; return d;&#125;bool AF()&#123; int i,d=1e9; for(i=1;i&lt;=T;i++)if(!mark[i])d=min(d,slk[i]),slk[i]=1e9; if(d==1e9)return 0; for(i=1;i&lt;=T;i++)if(mark[i])dis[i]+=d; return 1;&#125;int main()&#123; int i,j,k,x,y,u,d; while(scanf("%s",&amp;map[++n][1])!=EOF)map[n][0]='%'; n--;m=strlen(map[n])-1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)if(map[i][j]=='.')id[i][j]=++P; s=P+1;t=s+1;S=t+1;T=S+1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) if((i+j&amp;1)&amp;&amp;id[i][j]) &#123; D[s]-=2;D[id[i][j]]+=2; if(i==1||i==n||j==1||j==m)ADD(id[i][j],t,1,1),ADD(t,id[i][j],0,-1); &#125; else if((!(i+j&amp;1))&amp;&amp;id[i][j]) &#123; D[id[i][j]]-=2,D[t]+=2; if(i==1||i==n||j==1||j==m)ADD(s,id[i][j],1,1),ADD(id[i][j],s,0,-1); &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(k=0;(i+j&amp;1)&amp;&amp;id[i][j]&amp;&amp;k&lt;4;k++) &#123; x=i+dx[k];y=j+dy[k]; if(id[x][y])ADD(id[i][j],id[x][y],1,0),ADD(id[x][y],id[i][j],0,0); &#125; for(i=1;i&lt;=t;i++) if(D[i]&gt;0)ADD(S,i,D[i],0),ADD(i,S,0,0),lim+=D[i]; else if(D[i]&lt;0)ADD(i,T,-D[i],0),ADD(T,i,0,0); ADD(t,s,1e9,0);ADD(s,t,0,0); memset(slk,60,sizeof(slk)); do&#123; do&#123; memset(mark,0,sizeof(mark)); &#125;while(FP(S,1e9)); &#125;while(AF()); if(maxflow&lt;lim)puts("-1"); else printf("%d",mincost/2);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2041 （CQOI 2011）动态逆序对 （CDQ分治+树状数组/树套树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2041-%EF%BC%88CQOI-2011%EF%BC%89%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9-%EF%BC%88CDQ%E5%88%86%E6%B2%BB-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E6%A0%91%E5%A5%97%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2041【CQOI2011】动态逆序对问题描述 对于序列A，它的逆序对数定义为满足i &lt; j，且Ai &gt; Aj的数对(i,j)的个数。给1到n的一个排列，按照某种顺序依次删除m个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。 输入格式 输入第一行包含两个整数n和m，即初始元素的个数和删除的元素个数。以下n行每行包含一个1到n之间的正整数，即初始排列。以下m行每行一个正整数，依次为每次删除的元素。 输出格式 输出包含m行，依次为删除每个元素之前，逆序对的个数。 样例输入 5 4153425142 样例输出 5221 数据范围 n &lt;=100000m &lt;=50000 按照逆序对的定义，只需要支持查找前面比他大的和后面比他小的。 树套树的做法就不说了，我用的树状数组套主席树。 显然最优秀的做法是CDQ分治，离线倒序添加，将没删掉的点视为最先添加的，对添加时间分治，对x坐标排序，用树状数组维护y坐标即可。统计答案的时候求一下前缀和。 分治代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005using namespace std;struct node&#123;int x,y,id;&#125;K[N],T[N];int n,m,A[N],B[N],C[N];bool mark[N];long long Ans[N];void MD(int x,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))C[i]+=d;&#125;int GS(int x)&#123; int sum=0,i; for(i=x;i;i-=(i&amp;-i))sum+=C[i]; return sum;&#125;void CDQ(int l,int r)&#123; if(l==r)return; int i,j,k,sum=0,mid=l+r&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r); i=l;j=mid+1;k=0; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(K[i].x&lt;=K[j].x)T[++k]=K[i++]; else T[++k]=K[j++]; &#125; while(i&lt;=mid)T[++k]=K[i++]; while(j&lt;=r)T[++k]=K[j++]; for(i=1;i&lt;=k;i++)K[l+i-1]=T[i]; for(i=l;i&lt;=r;i++) &#123; if(K[i].id&lt;=mid)MD(K[i].y,1),sum++; else Ans[K[i].id]+=sum-GS(K[i].y); &#125; for(i=l;i&lt;=r;i++)if(K[i].id&lt;=mid)MD(K[i].y,-1); for(i=r;i&gt;=l;i--) &#123; if(K[i].id&lt;=mid)MD(K[i].y,1); else Ans[K[i].id]+=GS(K[i].y); &#125; for(i=l;i&lt;=r;i++)if(K[i].id&lt;=mid)MD(K[i].y,-1);&#125;int main()&#123; int i,j,k,x; scanf("%d%d",&amp;n,&amp;m);k=n; for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),B[A[i]]=i; for(i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;x);mark[B[x]]=1; K[k].x=B[x];K[k].y=x;K[k].id=k;k--; &#125; for(i=1;i&lt;=n;i++)if(!mark[i])K[k].x=i,K[k].y=A[i],K[k].id=k,k--; CDQ(1,n); for(i=1;i&lt;=n;i++)Ans[i]+=Ans[i-1]; for(i=n;i&gt;n-m;i--)printf("%lld\n",Ans[i]);&#125; 树套树代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define M 20000005using namespace std;int n,m,A[2][N],cnt[2],C[N],B[N],H[N];int tot,rt[N],ls[M],rs[M],v[M];long long ans;int ADD(int p,int l,int r,int k,int d)&#123; if(!p)p=++tot;v[p]+=d; if(l==r)return p; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[p]=ADD(ls[p],l,mid,k,d); else rs[p]=ADD(rs[p],mid+1,r,k,d); return p;&#125;void MD(int x,int y,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))rt[i]=ADD(rt[i],1,n,y,d);&#125;void GS(int x,int d)&#123;for(int i=x;i;i-=(i&amp;-i))A[d][++cnt[d]]=rt[i];&#125;void md(int x,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))C[i]+=d;&#125;int gs(int x)&#123; int i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=C[i]; return sum;&#125;void Gmax(int l,int r,int k)&#123; if(l==r) &#123; if(l&lt;k)return; for(int i=1;i&lt;=cnt[0];i++)ans-=v[A[0][i]]; return; &#125; int i,mid=l+r&gt;&gt;1; if(k&lt;=mid) &#123; for(i=1;i&lt;=cnt[0];i++)ans-=v[rs[A[0][i]]],A[0][i]=ls[A[0][i]]; Gmax(l,mid,k); &#125; else &#123; for(i=1;i&lt;=cnt[0];i++)A[0][i]=rs[A[0][i]]; Gmax(mid+1,r,k); &#125;&#125;void Gmin(int l,int r,int k)&#123; if(l==r) &#123; if(l&gt;k)return; for(int i=1;i&lt;=cnt[0];i++)ans-=v[A[0][i]]; for(int i=1;i&lt;=cnt[1];i++)ans+=v[A[1][i]]; return; &#125; int i,mid=l+r&gt;&gt;1; if(k&gt;mid) &#123; for(i=1;i&lt;=cnt[0];i++)ans-=v[ls[A[0][i]]],A[0][i]=rs[A[0][i]]; for(i=1;i&lt;=cnt[1];i++)ans+=v[ls[A[1][i]]],A[1][i]=rs[A[1][i]]; Gmin(mid+1,r,k); &#125; else &#123; for(i=1;i&lt;=cnt[0];i++)A[0][i]=ls[A[0][i]]; for(i=1;i&lt;=cnt[1];i++)A[1][i]=ls[A[1][i]]; Gmin(l,mid,k); &#125;&#125;void Work(int x)&#123; printf("%lld\n",ans); int y=H[x];MD(y,x,-1); cnt[0]=cnt[1]=0;GS(y,0); Gmax(1,n,x); cnt[0]=cnt[1]=0; GS(n,0);GS(y,1); Gmin(1,n,x);&#125;int main()&#123; int i,x; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;B[i]),H[B[i]]=i; for(i=1;i&lt;=n;i++) &#123; ans+=i-1-gs(B[i]); md(B[i],1); MD(i,B[i],1); &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;x); Work(x); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>分治法</category>
        <category>主席树</category>
        <category>CDQ分治</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2266 （HNOI 2013）游走（高斯消元+数学期望）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2266-%EF%BC%88HNOI-2013%EF%BC%89%E6%B8%B8%E8%B5%B0%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83-%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2266【HNOI2013 DAY2】游走问题描述 一个无向连通图，顶点从1 编号到N，边从1 编号到M。小Z 在该图上进行随机游走，初始时小Z 在1 号顶点，每一步小Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z到达N 号顶点时游走结束，总分为所有获得的分数之和。现在，请你对这M 条边进行编号，使得小Z 获得的总分的期望值最小。 输入格式 第一行是正整数N和M，分别表示该图的顶点数和边数，接下来M行每行是整数u，v(1≤u,v≤N)，表示顶点u与顶点v之间存在一条边。 输入保证30%的数据满足N≤10， 100%的数据满足2≤N≤500, 1&lt;=M&lt;=150000且是一个无向简单连通图。 输出格式 仅包含一个实数，表示最小的期望值，保留3 位小数。 样例输入 1 3 32 31 21 3 样例输出 1 3.333 样例输入 2 5 101 21 31 41 52 32 42 53 43 54 5 样例输出 2 17.800 显然的需要求出每条边的期望经过次数，假设这条边两端是$x,y$，那么有$E[i]=\frac{E[x]}{D[x]}+\frac{E[y]}{D[y]}$，其中$i$表示一条边，$E$表示经过次数的期望，$D$表示节点的度。证明是显然的。 那么只需要求出每个点经过次数的期望，那么显然将$E[x]$当作未知数来寻找关系。对于起点一号点，有$E[1]=1+\sum{\frac{E[t]}{D[t]}},t是与1相连的点，且不是终点$，对于其他点，只需要不加1即可。然后高斯消元。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 555#define M 200005using namespace std;struct node&#123;int a,b;double c;&#125;e[M];bool cmp(node a,node b)&#123;return a.c&gt;b.c;&#125;int n,m,D[N];bool G[N][N];double A[N][N],X[N];void Gauss(int row,int col)&#123; int i,j,x,y,MR;double t; for(x=1,y=1,MR=1;x&lt;=row&amp;&amp;y&lt;col;x++,y++,MR=x) &#123; for(i=x+1;i&lt;=row;i++)if(abs(A[i][y])&gt;abs(A[MR][y]))MR=i; if(MR!=x)for(i=1;i&lt;=col;i++)swap(A[x][i],A[MR][i]); if(!A[x][y])&#123;x--;continue;&#125; for(i=x+1;i&lt;=row;i++) if(A[i][y]) &#123; t=A[i][y]/A[x][y]; for(j=y;j&lt;=col;j++)A[i][j]-=A[x][j]*t; &#125; &#125; for(i=row;i&gt;=1;i--) &#123; X[i]=A[i][col]; for(j=i+1;j&lt;col;j++)X[i]-=X[j]*A[i][j]; X[i]/=A[i][i]; &#125;&#125;int main()&#123; int i,j,x,y;double ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); G[x][y]=G[y][x]=1; e[i].a=x;e[i].b=y; D[x]++;D[y]++; &#125; for(i=1;i&lt;n;i++)A[i][i]=1.0; for(i=1;i&lt;n;i++) for(j=1;j&lt;n;j++) if(i!=j&amp;&amp;G[i][j])A[i][j]=-1.0/D[j]; A[1][n]=1;Gauss(n-1,n); for(i=1;i&lt;=m;i++) &#123; x=e[i].a;y=e[i].b; if(x!=n)e[i].c+=1.0*X[x]/(1.0*D[x]); if(y!=n)e[i].c+=1.0*X[y]/(1.0*D[y]); &#125; sort(e+1,e+m+1,cmp); for(i=1;i&lt;=m;i++)ans+=1.0*i*e[i].c; printf("%.3lf",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
        <category>概率与期望</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2895 万径人踪灭（Manacher+FFT）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2895-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD%EF%BC%88Manacher-FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2895 万径人踪灭题目描述 如果机房马上要关门了，或者你急着要和MM 约会，请直接跳到第六个自然段。VFleaKing注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每10cm分为一小段，则对于每一小段，用a 表示能欣赏到美景，用b表示不能欣赏到美景，就能得到一个只含a,b的字符串s。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。设上山字符串长度为n，每个字符依次为s1,s2,…,sn。在上山和下山的路上，VFleaKing会选择某些小段查看旁边的景色，其他时间低头走路。即VFleaKing会选择k个小段x1,x2,…,xk且k&gt;=1,1&lt;=x1 &lt; x2&lt; …&lt; xk&lt;=n，VFleaKing上山和下山的过程中会在这些地方查看景色。VFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是：sx1,sx2,…,sxk，记为字符序列T1，下山时是否看到了美景的情况是：sxk,sxk-1,…,sx1，记为字符序列T2。VFleaKing希望T1=T2。VFleaKing还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：x2-x1,x3-x2,…,xk-xk-1，记为数列P1。下山时查看景色的间隔为：xk-xk-1,xk-1-xk-2,…,x2-xk-1，记为数列P2。VFleaKing希望P1=P2。VFleaKing觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有1&lt;=i&lt;=k 都有xi=x1+i-1，VFleaKing就会摔倒，VFleaKing 不希望发生这样的情况。就是要在一个只含a,b的字符串中选取一个子序列，使得： 位置和字符都关于某条对称轴对称。 不能是连续的一段。以s=“abaaaaabbabbabaa”为例。如果我们用符号[a1,a2,…,ak]表示一个序列，那么[1,4]就是一个合法的序列x，[5,8,10,12,15]也是，[4,5,8,9,10,11,12,15,16]也是。但是[1,2]不满足VFleaKing第一个希望和第三个希望，所以不是。[1,2,4]不满足第二个希望，所以不是。[9,10,11]不满足第三个希望，所以不是。给你字符串s，现在VFleaKing 想知道，有多少个合法的x。答案可能很大，VFleaKing想知道结果对1000000007取模的值。 输入格式 一行，一个只包含a,b两种字符的字符串。 输出格式 一行，一个非负整数表示问题的答案。 样例输入1： abaabaa 样例输入2： aaabbbaaa 样例输入3： aaaaaaaa 样例输出1： 14 样例输出2： 44 样例输出3： 53 样例解释： 第一组：14 个方案分别是：[1,3],[1,4],[2,5],[1,6],[3,6],[4,6],[1,7],[3,7],[4,7],[1,4,7],[3,5,7],[1,3,4,6],[1,2,5,6],[3,4,6,7].第二组：不解释第三组：不解释 数据范围： 对于10%的数据，字符串仅包含字母a或仅包含字母b。另有20%的数据，n&lt;=1000。另有20%的数据，要么a的个数不超过10，要么b的个数不超过10。另有10%的数据，n&lt;=10000。对于100%的数据，n&lt;=100000。 这道题真是劲啊！显然的可以想到如果选出的串是连续的，那么答案是容易统计的，但是问题是处理不连续的。首先在相邻两个字符之间添加一个字符，这样奇数和偶数的问题就解决了。 然后考虑以某个位置为对称中心，能够选出多少种方案，为了统计这个方案，显然我们需要知道有多少对字符串以该点为对称中心。那么先假设总共有$X$对字符以该点为中心对称（它本身也算）。再考虑到题目提出的必须要休息一次的要求，即必须是至少不相连的两段，容易想到统计出以该点为中心，向两边的连续的相同字符有$Y$对。那么以该点为对称中心的方案数$S=2^X-Y-1$，意思是每一对字符都可以选择取或不取，然后减掉只有一段的情况和空串的情况。 那么现在如何统计出$X$和$Y$呢。$Y$显然用$Manacher$直接得到。考虑$X$。 观察之后容易发现，只存在了两种字符，那么将$a$出现的位置记录到一个序列$A[i]$中，$A[i]=1当且仅当s[i]=a$,同理将$B[i]$也统计出来，至于新加的字符并不影响答案，不考虑。 那么很容易发现对于一个位置$K$，$X_K=\sum{(A[i]\times A[2K-i]+B[i]\times B[2K-i])}$，那么显然用$FFT$处理即可。 最后枚举每个点求和即可。$Ans=\sum{(2^{X_i}-Y_i-1)}$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;complex&gt;#include&lt;cmath&gt;#define N 1000005#define ll long longusing namespace std;char s[N],ss[N];ll L,Max,rad[N],pos,T[N],P[N];const ll mod=1000000007;const double pi=4.0*atan(1.0);complex&lt;double&gt;A[N],B[N],wi[N];void Manacher()&#123; ll i,j,k; for(i=1;i&lt;=L;i++) &#123; if(i&gt;Max)rad[i]=1; else rad[i]=min(Max-i+1,rad[2*pos-i]); while(i-rad[i]&amp;&amp;i+rad[i]&lt;=L&amp;&amp;s[i-rad[i]]==s[i+rad[i]])rad[i]++; if(i+rad[i]-1&gt;Max)Max=i+rad[i]-1,pos=i; &#125;&#125;void FFT(complex&lt;double&gt;W[],ll n,ll ty)&#123; ll i,j,k,m; complex&lt;double&gt;t0,t1; for(i=0;i&lt;n;i++) &#123; for(j=0,k=i,m=1;m&lt;n;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1); if(i&lt;j)swap(W[i],W[j]); &#125; wi[0]=1; for(m=1;m&lt;n;m&lt;&lt;=1) &#123; t0=exp(complex&lt;double&gt;(0,ty*pi/m)); for(i=1;i&lt;m;i++)wi[i]=wi[i-1]*t0; for(k=0;k&lt;n;k+=m&lt;&lt;1) for(i=k;i&lt;m+k;i++) &#123; t0=W[i]; t1=W[i+m]*wi[i-k]; W[i]=t0+t1; W[i+m]=t0-t1; &#125; &#125; if(ty==1)return;t0=1.0/n; for(i=0;i&lt;n;i++)W[i]*=t0;&#125;int main()&#123; ll i,j,k,n=1,ans=0; scanf("%s",&amp;ss[1]);ss[0]=s[0]='%'; L=strlen(ss)-1; for(i=1;i&lt;=L;i++) &#123; s[i&lt;&lt;1]=ss[i]; s[i&lt;&lt;1|1]='$'; s[i*2-1]='$'; &#125; L=strlen(s)-1;Manacher(); while(n&lt;2*L)n&lt;&lt;=1; for(i=1;i&lt;=L;i++) &#123; if(s[i]=='a')A[i]+=1; if(s[i]=='b')B[i]+=1; &#125; FFT(A,n,1);FFT(B,n,1); for(i=0;i&lt;=n;i++)A[i]*=A[i],B[i]*=B[i]; FFT(A,n,-1);FFT(B,n,-1); for(i=1;i&lt;=L;i++) &#123; T[i]=floor(A[i&lt;&lt;1].real()+0.5)+floor(B[i&lt;&lt;1].real()+0.5); T[i]=T[i]+1&gt;&gt;1; &#125; P[0]=1;for(i=1;i&lt;=L;i++)P[i]=P[i-1]&lt;&lt;1,P[i]%=mod; for(i=1;i&lt;=L;i++)ans=(ans+P[T[i]]-rad[i]/2-1)%mod; printf("%lld",(ans+mod)%mod);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数学</category>
        <category>Manacher</category>
        <category>FFT</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4087 （SDOI 2017）硬币游戏（高斯消元）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4087-%EF%BC%88SDOI-2017%EF%BC%89%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4087【SDOI2017】硬币游戏问题描述 输入格式 输出格式 样例输入 3 3THTTTHHTT 样例输出 0.33333333330.25000000000.4166666667 提示 这题显然的想到高斯消元，关键是如何建立方程。不妨设每个人赢的概率分别为$P_1,P_2…P_n$,那么显然我们需要寻找他们之间的关系。此题的关键在于假设一个状态$N$，他表示所有的没有人获胜的状态。 举个例子来说明，就以样例为例。这三个人分别猜的是$THT,TTH,HTT$考虑第一个人胜利的概率，那么如果在$N$后面接上一个$THT$，显然第一个人就胜利了。那么$P_1=\frac {1}{8}P_N$。这表示$N$后面三次扔硬币恰好是$THT$的概率。 但是显然这样不对，因为如果$N$的结尾是在T，那么扔出$TH$时，第二个人就已经赢了，也有可能结尾是$TH$,那么在扔出$T$时，第一个人已经赢了。需要把这些情况发生的概率减掉。 那么应该有$P_1=\frac {1}{8}P_N-\frac{1}{4}P_1-\frac{1}{2}P_2-\frac{1}{4}P_3$对应的系数就是对应串出现的概率。实际上，当某个串的一个后缀等于当前串的一个前缀时，就会对当前串的概率造成影响。 由于此题数据较弱，可以暴力匹配。当然也可以用KMP。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int n,m;char S[N][N];double A[N][N],B[N],X[N];void Gauss(int row,int col)&#123; int i,j,x,y,MR;double t,tmp; for(x=1,y=1,MR=1;x&lt;=row&amp;&amp;y&lt;col;x++,y++,MR=x) &#123; for(i=x+1;i&lt;=row;i++)if(abs(A[i][y])&gt;abs(A[MR][y]))MR=i; if(i!=x)for(i=1;i&lt;=col;i++)swap(A[x][i],A[MR][i]); if(!A[x][y])&#123;x--;continue;&#125; for(i=x+1;i&lt;=row;i++) if(A[i][y]) &#123; t=A[i][y]/A[x][y]; for(j=y;j&lt;=col;j++)A[i][j]-=A[x][j]*t; &#125; &#125; for(i=row;i&gt;=1;i--) &#123; tmp=A[i][col]; for(j=i+1;j&lt;col;j++)tmp-=X[j]*A[i][j]; X[i]=tmp/A[i][i]; &#125; for(i=1;i&lt;=n;i++)printf("%.10lf\n",X[i]);&#125;int main()&#123; int i,j,k,p,t; scanf("%d%d",&amp;n,&amp;m);B[0]=1.0; for(i=1;i&lt;=n;i++)scanf("%s",S[i]),A[i][i]=1.0; for(i=1;i&lt;=m;i++)B[i]=B[i-1]/2; for(i=1;i&lt;=n;i++) &#123; A[i][n+1]=-1.0; for(j=1;j&lt;=n;j++) for(k=1,t=0;k&lt;m;k++,t=0) &#123; while(k+t&lt;m&amp;&amp;S[j][k+t]==S[i][t])t++; if(k+t==m)A[i][j]+=B[k]; &#125; &#125; for(i=1;i&lt;=n;i++)A[n+1][i]=1.0;A[n+1][n+2]=1.0; Gauss(n+1,n+2);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4350 （SDOI 2016）生成魔咒（后缀自动机）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4350-%EF%BC%88SDOI-2016%EF%BC%89%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4350生成魔咒问题描述 魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 1、2 拼凑起来形成一个魔咒串 [1,2]。 一个魔咒串 S 的非空字串被称为魔咒串 S 的生成魔咒。 例如 S=[1,2,1] 时，它的生成魔咒有 [1]、[2]、[1,2]、[2,1]、[1,2,1] 五种。S=[1,1,1] 时，它的生成魔咒有 [1]、[1,1]、[1,1,1] 三种。 最初 S 为空串。共进行 n 次操作，每次操作是在 S 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 S 共有多少种生成魔咒。 输入格式 第一行一个整数 n。 第二行 n 个数，第 i 个数表示第 i 次操作加入的魔咒字符。 1≤n≤100000。用来表示魔咒字符的数字 x 满足 1≤x≤10^9 输出格式 输出 n 行，每行一个数。第 i 行的数表示第 i 次操作后 S 的生成魔咒数量 样例输入 71 2 3 3 3 1 2 样例输出 1369121722 此题的关键在于动态维护不同子串个数，考虑后缀自动机。 事实上，考虑一下可以发现后缀自动机在增量法构造过程中，每加入一个字符会增加一些新的子串，而增加的子串个数恰好就是$Max[np]-Max[par[np]]$，证明是显然的，因为新增加的子串必然是以当前字符为结尾的整个串后缀，那么新增的子串就是原来没有的后缀。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define int long long#define N 200005using namespace std;map&lt;int,int&gt;son[N];int n,tot=1,rt=1,las=1,Max[N],pra[N],Ans;int NP(int x)&#123; Max[++tot]=x; return tot;&#125;void Ins(int t)&#123; int p=las,q,np,nq; np=NP(Max[p]+1); while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p]; if(!p)pra[np]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np]=q; else &#123; nq=NP(Max[p]+1); son[nq]=son[q]; pra[nq]=pra[q]; pra[q]=pra[np]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p]; &#125; &#125; Ans+=Max[np]-Max[pra[np]]; las=np;&#125;main()&#123; int x; scanf("%lld",&amp;n); while(n--) &#123; scanf("%lld",&amp;x); Ins(x);printf("%lld\n",Ans); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2663 （ZJOI 2009）对称的正方形（Manacher）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2663-%EF%BC%88ZJOI-2009%EF%BC%89%E5%AF%B9%E7%A7%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88Manacher%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2663【ZJOI 2009 Day2】对称的正方形问题描述 Orez很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez又得到了一些数据，并已经把它们排成了一个n行m列的矩阵。通过观察，Orez发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。 Orez自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。 输入格式 第一行为两个整数n和m。接下来n行每行包含m个正整数，表示Orez得到的矩阵。 输出格式 仅包含一个整数answer，表示矩阵中有answer个上下左右对称的正方形子矩阵。 样例输入 5 54 2 4 4 43 1 4 4 33 5 3 3 33 1 5 3 34 2 1 2 4 样例输出 27 提示 对于30%的数据 n，m≤100对于100%的数据 n，m≤1000 ，矩阵中的数的大小≤10^9 数据范围很小，考虑暴力做法。直接将每一行每一列跑一次Manacher，记录下对应的最长回文子串长度，对于奇偶的处理同样是在相邻两个树之间添加字符。然后枚举一个点作为正方形的中心点，向四个方向同时拓展即可。貌似可以利用单调性优化一部分，但暴力还是跑得很快的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 2222using namespace std;int n,m,G[N][N],HR[N][N],LR[N][N],Max,pos,Ans;void Manacher(int k)&#123; Max=0;pos=0; for(int i=1;i&lt;=m;i++) &#123; if(i&gt;Max)HR[k][i]=1; else HR[k][i]=min(Max-i+1,HR[k][2*pos-i]); while(i-HR[k][i]&gt;0&amp;&amp;i+HR[k][i]&lt;=m&amp;&amp;G[k][i-HR[k][i]]==G[k][i+HR[k][i]])HR[k][i]++; if(i+HR[k][i]-1&gt;Max)Max=i+HR[k][i]-1,pos=i; &#125;&#125;void manacher(int k)&#123; Max=0;pos=0; for(int i=1;i&lt;=n;i++) &#123; if(i&gt;Max)LR[k][i]=1; else LR[k][i]=min(Max-i+1,LR[k][2*pos-i]); while(i-LR[k][i]&gt;0&amp;&amp;i+LR[k][i]&lt;=n&amp;&amp;G[i-LR[k][i]][k]==G[i+LR[k][i]][k])LR[k][i]++; if(i+LR[k][i]-1&gt;Max)Max=i+LR[k][i]-1,pos=i; &#125;&#125;int main()&#123; int i,j,k,u,d,l,r,Min; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)scanf("%d",&amp;G[i&lt;&lt;1][j&lt;&lt;1]); n=n&lt;&lt;1|1;m=m&lt;&lt;1|1; for(i=1;i&lt;=n;i++)if(i-1&amp;1)Manacher(i); for(i=1;i&lt;=m;i++)if(i-1&amp;1)manacher(i); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) if(i+j-1&amp;1) &#123; u=d=i;l=r=j;k=2; u--;d++;l--;r++; if(HR[i][j])Min=min(HR[i][j],LR[j][i]); else Min=n; while((Min&gt;=k&amp;&amp;HR[u][j]&gt;=k&amp;&amp;HR[d][j]&gt;=k&amp;&amp;LR[l][i]&gt;=k&amp;&amp;LR[r][i]&gt;=k)||(k+i-1&amp;1)) &#123; if(HR[u][j])Min=min(HR[u][j],Min); if(HR[d][j])Min=min(HR[d][j],Min); if(LR[l][i])Min=min(LR[l][i],Min); if(LR[r][i])Min=min(LR[r][i],Min); u--;d++;l--;r++;k++; &#125; if(j&amp;1)Ans+=k-2&gt;&gt;1; else Ans+=k-1&gt;&gt;1; &#125; printf("%d",Ans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>Manacher</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4000 （AHOI 2013）差异（后缀自动机/后缀数组+线段树/单调队列）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4000-%EF%BC%88AHOI-2013%EF%BC%89%E5%B7%AE%E5%BC%82%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4000 [Ahoi2013]差异问题描述 输入格式 一行，一个字符串S 输出格式 一行，一个整数，表示所求值 样例输入 cacao 样例输出 54 提示 2&lt;=N&lt;=500000,S由小写英文字母组成 还是先说优美的自动机做法，将字符串反过来建立后缀自动机，那么后缀的前缀变成前缀的后缀，那么变成在后缀自动机parent树上求LCA 考虑到所有的LCP要求和，那么考虑每一个节点会多少次被当做LCA，显然如果统计出每颗子树Right集合的大小，即子树表示了多少个前缀，那么两两子树的前缀数相乘求和就是当前点被当做LCA的次数。因为不同子树中的点的LCA一定是当前节点。 然后还要考虑选择了子树中的一个点和当前点的情况，此时需要注意到统计Right集合时，复制出来的点并不代表一次新的出现位置，因此只有当当前点不是复制的点时，才加上每个子树的前缀数。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;char s[N];long long Ans;int n,m,tot=1,las=1,rt=1,Max[N],pra[N],son[N][27],v[N];int TOT,LA[N],NE[N],EN[N];int NP(int x)&#123; Max[++tot]=x; return tot;&#125;void Ins(int t)&#123; int p=las,q,np,nq; np=NP(Max[p]+1);v[np]=1; while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p]; if(!p)pra[np]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); pra[nq]=pra[q]; pra[q]=pra[np]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p]; &#125; &#125; las=np;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x)&#123; int i,y;long long tmp=0,tt=v[x]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];DFS(y); v[x]+=v[y]; tmp+=1ll*v[y]*tt; tt+=v[y]; &#125; Ans+=1ll*tmp*Max[x];&#125;int main()&#123; int i,j; scanf("%s",s); n=strlen(s); for(i=0;i&lt;n;i++)Ins(s[i]-'a'); for(i=1;i&lt;=tot;i++)ADD(pra[i],i); DFS(rt);printf("%lld",1ll*n*(n+1)/2*(n-1)-Ans*2);&#125; 然后是略微麻烦的后缀数组做法。优秀的思路是考虑每一个Height有多少次被作为LCP加入答案，那么显然需要找到左右第一个小于他的位置。用单调队列/栈即可。但是需要注意由于Height相同而产生的重复计算。 一个更粗暴的想法是直接用线段树维护当前的已经求出的LCP值，每次讨论一个新的Height时，把大于他的LCP值变成当前的Height，然后新加入一个Height，然后对整颗线段树求和累加到答案上即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 555555using namespace std;char s[N];int n,SA[N],H[N],Rank[N];int wa[N],wb[N],T[N];int tot,ls[N*4],rs[N*4],lazy[N*4],cnt[N*4];ll sum[N*4];bool cmp(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void GSA(char *r,int *sa,int a,int b)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;a;i++)T[x[i]=r[i]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[i]]]=i; for(p=1,j=1;p&lt;a;j&lt;&lt;=1,b=p) &#123; for(p=0,i=a-j;i&lt;a;i++)y[p++]=i; for(i=0;i&lt;a;i++)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[y[i]]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[y[i]]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;a;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125;&#125;void GH(char *r,int *sa,int a)&#123; int i,j,k=0; for(i=1;i&lt;=a;i++)Rank[sa[i]]=i; for(i=0;i&lt;a;H[Rank[i++]]=k) for(k?k--:0,j=sa[Rank[i]-1];r[i+k]==r[j+k];k++);&#125;void PD(int p)&#123; lazy[ls[p]]=lazy[rs[p]]=1;lazy[p]=0; sum[ls[p]]=sum[rs[p]]=cnt[ls[p]]=cnt[rs[p]]=0;&#125;int BT(int x,int y)&#123; int p=++tot; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; return p;&#125;void ADD(int p,int l,int r,int k,int d)&#123; if(lazy[p])PD(p); if(l==r)&#123;cnt[p]+=d;sum[p]=1ll*cnt[p]*l;return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ADD(ls[p],l,mid,k,d); else ADD(rs[p],mid+1,r,k,d); cnt[p]=cnt[ls[p]]+cnt[rs[p]]; sum[p]=sum[ls[p]]+sum[rs[p]];&#125;int GC(int p,int l,int r,int x,int y)&#123; if(lazy[p])return 0; if(x&lt;=l&amp;&amp;y&gt;=r) &#123; int k=cnt[p]; cnt[p]=sum[p]=0; lazy[p]=1; return k; &#125; int mid=l+r&gt;&gt;1,cs=0; if(x&lt;=mid&amp;&amp;y&gt;=l)cs+=GC(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)cs+=GC(rs[p],mid+1,r,x,y); cnt[p]=cnt[ls[p]]+cnt[rs[p]]; sum[p]=sum[ls[p]]+sum[rs[p]]; return cs;&#125;void GA()&#123; int i,k;ll ans=0; BT(1,n);H[n+1]=H[n]+1; for(i=n-1;i&gt;0;i--) &#123; if(H[i+1]&lt;H[i+2])k=GC(1,1,n,H[i+1]+1,H[i+2]); else k=0; if(H[i+1])ADD(1,1,n,H[i+1],k+1); ans+=sum[1]; &#125; printf("%lld",1ll*n*(1ll*n+1ll)/2ll*(1ll*n-1ll)-ans*2);&#125;int main()&#123; scanf("%s",s); n=strlen(s);s[n]='a'-1; GSA(s,SA,n+1,300); GH(s,SA,n);GA();&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>后缀自动机</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4090 找相同子串（后缀自动机/后缀数组+线段树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4090-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%90%E4%B8%B2%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4090[HAOI2016]找相同子串问题描述 给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 输入格式 两行，两个字符串s1，s2，长度分别为n1，n2。1 &lt;=n1, n2&lt;= 200000，字符串中只有小写字母 输出格式 输出一个整数表示答案 样例输入 aabbbbaa 样例输出 10 首先看看简洁优美的自动机做法。 将两个串中间加个字符，连起来建机子。 其实只需要在求Right集合大小的时候把他拆成两部分，一部分是第一个子串的Right，另一部分是第二个的。然后每个点求和，即$Ans=\sum v_1[x] \times v_2[x] \times (Max[x]-Max[pra[x]])$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005using namespace std;char s1[N],s2[N];long long Ans;int n,m,tot=1,las=1,rt=1,Max[N],pra[N],son[N][27],v[N][2];int TOT,LA[N],NE[N],EN[N];int NP(int x)&#123; Max[++tot]=x; return tot;&#125;void Ins(int t,int d)&#123; int p=las,q,np,nq; np=NP(Max[p]+1);v[np][d]=1; while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p]; if(!p)pra[np]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); pra[nq]=pra[q]; pra[q]=pra[np]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p]; &#125; &#125; las=np;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x)&#123; int i,y; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];DFS(y); v[x][0]+=v[y][0]; v[x][1]+=v[y][1]; &#125; Ans+=1ll*v[x][0]*v[x][1]*(Max[x]-Max[pra[x]]);&#125;int main()&#123; scanf("%s%s",s1,s2); n=strlen(s1); m=strlen(s2); for(int i=0;i&lt;n;i++)Ins(s1[i]-'a',0);Ins(26,0); for(int i=0;i&lt;m;i++)Ins(s2[i]-'a',1); for(int i=1;i&lt;=tot;i++)ADD(pra[i],i); DFS(rt);printf("%lld",Ans);&#125; 然后再来看看卡到GG的后缀数组搞法。利用单调性可以搞成线性的，然而为了方便当然是线段树。 两个串连起来建好机子，倒起讨论，用线段树维护一下当前Height值的数量即可。注意到相同子串个数恰是LCP之和。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 555555using namespace std;char s[N],A[N],B[N];int n,m,SA[N],H[N],Rank[N];int wa[N],wb[N],T[N];int tot,ls[N*4],rs[N*4],lazy[N*4][2],cnt[N*4][2];ll sum[N*4][2];bool cmp(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void GSA(char *r,int *sa,int a,int b)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;a;i++)T[x[i]=r[i]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[i]]]=i; for(p=1,j=1;p&lt;a;j&lt;&lt;=1,b=p) &#123; for(p=0,i=a-j;i&lt;a;i++)y[p++]=i; for(i=0;i&lt;a;i++)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[y[i]]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[y[i]]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;a;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; &#125;&#125;void GH(char *r,int *sa,int a)&#123; int i,j,k=0; for(i=1;i&lt;=a;i++)Rank[sa[i]]=i; for(i=0;i&lt;a;H[Rank[i++]]=k) for(k?k--:0,j=sa[Rank[i]-1];r[i+k]==r[j+k];k++);&#125;void PD(int p,int t)&#123; lazy[ls[p]][t]=lazy[rs[p]][t]=1;lazy[p][t]=0; sum[ls[p]][t]=sum[rs[p]][t]=cnt[ls[p]][t]=cnt[rs[p]][t]=0;&#125;int BT(int x,int y)&#123; int p=++tot; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; return p;&#125;void ADD(int p,int l,int r,int k,int d,int t)&#123; if(lazy[p][t])PD(p,t); if(l==r)&#123;cnt[p][t]+=d;sum[p][t]=1ll*cnt[p][t]*l;return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ADD(ls[p],l,mid,k,d,t); else ADD(rs[p],mid+1,r,k,d,t); cnt[p][t]=cnt[ls[p]][t]+cnt[rs[p]][t]; sum[p][t]=sum[ls[p]][t]+sum[rs[p]][t];&#125;int GC(int p,int l,int r,int x,int y,int t)&#123; if(lazy[p][t])return 0; if(x&lt;=l&amp;&amp;y&gt;=r) &#123; int k=cnt[p][t]; cnt[p][t]=sum[p][t]=0; lazy[p][t]=1; return k; &#125; int mid=l+r&gt;&gt;1,cs=0; if(x&lt;=mid&amp;&amp;y&gt;=l)cs+=GC(ls[p],l,mid,x,y,t); if(x&lt;=r&amp;&amp;y&gt;mid)cs+=GC(rs[p],mid+1,r,x,y,t); cnt[p][t]=cnt[ls[p]][t]+cnt[rs[p]][t]; sum[p][t]=sum[ls[p]][t]+sum[rs[p]][t]; return cs;&#125;void GA()&#123; int i,k;ll ans=0;int t=n+m+1; BT(1,t);H[t+1]=H[t]+1; for(i=t-1;i&gt;0;i--) &#123; if(H[i+1]&lt;H[i+2])k=GC(1,1,t,H[i+1]+1,H[i+2],1); else k=0; if(H[i+1]) &#123; if(SA[i+1]&gt;n)ADD(1,1,t,H[i+1],k+1,1); else if(k)ADD(1,1,t,H[i+1],k,1); &#125; if(SA[i]&lt;n)ans+=sum[1][1]; if(H[i+1]&lt;H[i+2])k=GC(1,1,t,H[i+1]+1,H[i+2],0); else k=0; if(H[i+1]) &#123; if(SA[i+1]&lt;n)ADD(1,1,t,H[i+1],k+1,0); else if(k)ADD(1,1,t,H[i+1],k,0); &#125; if(SA[i]&gt;n)ans+=sum[1][0]; &#125; printf("%lld",ans);&#125;int main()&#123; scanf("%s%s",s,B); n=strlen(s); m=strlen(B); for(int i=n+1;i&lt;=n+m;i++)s[i]=B[i-n-1]; s[n]='z'+1;s[n+m+1]='a'-1; GSA(s,SA,n+m+2,300); GH(s,SA,n+m+1);GA();&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
        <category>线段树</category>
        <category>后缀自动机</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2564 （SCOI 2012）喵星球上的点名（后缀数组+树状数组）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2564-%EF%BC%88SCOI-2012%EF%BC%89%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2564【SCOI2012】喵星球上的点名问题描述 a180285幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。 假设课堂上有N个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择M个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 然而，由于喵星人的字码过于古怪，以至于不能用ASCII码来表示。为了方便描述，a180285决定用数串来表示喵星人的名字。 现在你能帮助a180285统计每次点名的时候有多少喵星人答到，以及M次点名结束后每个喵星人答到多少次吗？ 输入格式 现在定义喵星球上的字符串给定方法：先给出一个正整数L，表示字符串的长度，接下来L个整数表示字符串的每个字符。输入的第一行是两个整数N和M。接下来有N行，每行包含第i 个喵星人的姓和名两个串。姓和名都是标准的喵星球上的字符串。接下来有M行，每行包含一个喵星球上的字符串，表示老师点名的串。 输出格式 对于每个老师点名的串输出有多少个喵星人应该答到。然后在最后一行输出每个喵星人被点到多少次。 样例输入 2 36 8 25 0 24 14 8 6 18 0 10 20 24 07 14 17 8 7 0 17 0 5 8 25 0 24 04 8 25 0 244 7 0 17 04 17 0 8 25 样例输出 2101 2 数据范围 对于30%的数据，保证：1&lt;=N,M&lt;=1000，喵星人的名字总长不超过4000，点名串的总长不超过2000。对于100%的数据，保证：1&lt;=N&lt;=20000，1&lt;=M&lt;=50000，喵星人的名字总长和点名串的总长分别不超过100000，保证喵星人的字符串中作为字符存在的数不超过10000。 分开考虑两种询问，考虑第一问，先对所有的名和姓连起来，中间插入字符构建后缀数组，记录每一个位置属于那个人。 那么对于一次询问，由于SA数组有序，可以直接二分查找找到询问串在SA数组中的位置，显然如果该询问是一些人的子串，那么在SA数组中这些对应后缀必然是一个连续的区间，那么问题变成询问一个区间中有多少种不同的值，离线后缀数组处理即可。处理时将询问按照对应区间左右端点排序，记录下SA数组中每一个值下一个相同值出现的位置，然后将每个值的第一次出现的位置加到树状数组中，每次删除一个值后，将对应的下一个值加进来即可。每个询问对应的答案就是将小于左端点的位置处理完了后，右端点的前缀和。 考虑询问二，每个人答到多少次，问题等价于求每种值被多少个区间覆盖，那么同样将询问排序，每次将左端点小于当前讨论到的位置的区间左端点加一，右端点减一。那么当前点的前缀和就是这个点被覆盖次数。但是这样显然要算重，那么需要减去讨论到上一个相同值的点时，这个点的前缀和。记录一下就好。 具体可以参见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005using namespace std;struct node&#123;int L,R,id,ans;&#125;Q[N];int n,m,A[N],B[N],SA[N],C[N],Rank[N],H[N],L;int wa[N],wb[N],T[N];int LA[N],NE[N],cnt[N],G[N];bool cmp(int a,int b)&#123; int i; for(i=0;A[a+i]==C[b+i];i++); return A[a+i]&lt;C[b+i];&#125;bool ccmp(node a,node b)&#123; if(a.L==b.L)return a.R&lt;b.R; return a.L&lt;b.L;&#125;bool cccmp(node a,node b)&#123;return a.id&lt;b.id;&#125;bool equ(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void GSA(int *r,int *sa,int a,int b)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[i]=r[i]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[i]]]=i; for(p=1,j=1;p&lt;a;j&lt;&lt;=1,b=p) &#123; for(p=0,i=a-j;i&lt;a;i++)y[p++]=i; for(i=0;i&lt;a;i++)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[y[i]]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[y[i]]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;a;i++) x[sa[i]]=equ(y,sa[i-1],sa[i],j)?p-1:p++; &#125;&#125;void GH(int *r,int *sa,int a)&#123; int i,j,k=0; for(i=1;i&lt;=a;i++)Rank[sa[i]]=i; for(i=0;i&lt;a;H[Rank[i++]]=k) for(k?k--:0,j=sa[Rank[i]-1];r[i+k]==r[j+k];k++);&#125;void MD(int x,int d)&#123;for(int i=x;i&lt;=L;i+=(i&amp;-i))G[i]+=d;&#125;int GS(int x)&#123; int i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=G[i]; return sum;&#125;int main()&#123; int i,j,k,x,y,p; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;k);for(j=1;j&lt;=k;j++)scanf("%d",&amp;A[L]),A[L]++,B[L++]=i;A[L++]=10000+i; scanf("%d",&amp;k);for(j=1;j&lt;=k;j++)scanf("%d",&amp;A[L]),A[L]++,B[L++]=i;A[L++]=10000+i; &#125; A[L]=0;GSA(A,SA,L+1,100005);GH(A,SA,L); for(i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;k);Q[i].id=i; for(j=0;j&lt;k;j++)scanf("%d",&amp;C[j]),C[j]++; C[k]=-1;Q[i].L=lower_bound(SA+1,SA+L+1,0,cmp)-SA; C[k]=100005;Q[i].R=lower_bound(SA+1,SA+L+1,0,cmp)-SA; &#125; for(i=1;i&lt;=L;i++)C[i]=B[SA[i]]; for(i=L;i&gt;=1;i--) &#123; NE[i]=LA[C[i]]?LA[C[i]]:L+1; LA[C[i]]=i; &#125; sort(Q+1,Q+m+1,ccmp);j=1; for(i=1;i&lt;=n;i++)MD(LA[i],1); for(i=1;i&lt;=m;i++) &#123; while(Q[i].L&gt;j) &#123; if(C[j]==0)&#123;j++;continue;&#125; MD(j,-1);MD(NE[j],1);j++; &#125; Q[i].ans=GS(Q[i].R-1); &#125; memset(LA,0,sizeof(LA)); memset(G,0,sizeof(G));j=1; for(i=1;i&lt;=L;i++) &#123; if(C[i]==0)continue; while(j&lt;=m&amp;&amp;Q[j].L&lt;=i)MD(Q[j].L,1),MD(Q[j].R,-1),j++; cnt[C[i]]+=GS(i)-LA[C[i]]; LA[C[i]]=GS(NE[i]); &#125; sort(Q+1,Q+m+1,cccmp); for(i=1;i&lt;=m;i++)printf("%d\n",Q[i].ans); for(i=1;i&lt;=n;i++)printf("%d ",cnt[i]);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2844 （APIO 2014）回文串（Manacher+后缀自动机+倍增/回文树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2844-%EF%BC%88APIO-2014%EF%BC%89%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88Manacher-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%80%8D%E5%A2%9E-%E5%9B%9E%E6%96%87%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2844【APIO2014】回文串问题描述 考虑一个只包含小写英文字母的字符串s。我们定义s的一个字串t的“出现价值”为t在s中出现的次数乘以t的长度。请求出s的所有回文子串中的最大“出现价值”。 输入格式 输入只有一行，为一个只包含小写字母的非空字符串s。 输出格式 输出一个整数，为最大的回文子串价值。 样例输入1： abacaba 样例输入2： www 样例输出1： 7 样例输出2： 4 首先，此题是回文树模板题。 然后当然可以用朴素做法解决。 由于要查找回文串，考虑Manacher，然后需要查找回文串的出现次数，考虑后缀自动机。 显然的做法是在Manacher过程中，每找到一个回文串，就在自动机上从根开始跑，查找他的出现次数。 注意到事实上同样的回文串不需要多次运算，那么在Manacher过程中只需要在每次超出Max进行拓展时在自动机上查找即可。由于最多拓展n次，那么最多只需要查找n次。 但这样显然要超时，考虑优化查找速度，注意到每个串在自动机上都对应到了一个节点上，而parent树上该串必然是子节点串的后缀，那么考虑在parent树上倍增查找。 只需要在构建自动机的时候记录下每个字符为结尾，对应的节点编号，然后建完后每次从该结尾处倍增往上跳即可。查找复杂度$log_2{n}$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 666666using namespace std;char s[N],A[N];int n,rad[N],pos,MAX;int tot=1,rt=1,las=1,R[N],Max[N],pra[N][22],son[N][26],v[N],S=19;int TOT,LA[N],NE[N],EN[N];long long Ans;int NP(int x)&#123; Max[++tot]=x; return tot;&#125;void Ins(int t)&#123; int p=las,q,np,nq; np=NP(Max[p]+1);v[np]=1; while(p&amp;&amp;!son[p][t])son[p][t]=np,p=pra[p][0]; if(!p)pra[np][0]=rt; else &#123; q=son[p][t]; if(Max[q]==Max[p]+1)pra[np][0]=q; else &#123; nq=NP(Max[p]+1); memcpy(son[nq],son[q],sizeof(son[q])); pra[nq][0]=pra[q][0]; pra[q][0]=pra[np][0]=nq; while(son[p][t]==q)son[p][t]=nq,p=pra[p][0]; &#125; &#125; las=np;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x)&#123; int i,y; for(i=1;i&lt;=S;i++)pra[x][i]=pra[pra[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i];DFS(y); v[x]+=v[y]; &#125;&#125;int Find(int k,int t)&#123; int i,p=R[k]; for(i=S;i&gt;=0;i--)if(Max[pra[p][i]]&gt;=t)p=pra[p][i]; return p;&#125;void Manacher()&#123; int i,j,k,p; MAX=0;Ans=0;pos=0; for(i=1;i&lt;=n;i++) &#123; if(i&gt;MAX)rad[i]=1; else rad[i]=min(MAX-i+1,rad[pos*2-i]); while(i-rad[i]&gt;0&amp;&amp;i+rad[i]&lt;=n&amp;&amp;A[i-rad[i]]==A[i+rad[i]]) &#123; rad[i]++; k=i+rad[i]-2; if(A[k]!='%') &#123; p=Find(k,rad[i]-1); Ans=max(Ans,1ll*v[p]*(1ll*rad[i]-1ll)); &#125; &#125; if(i+rad[i]-1&gt;MAX)MAX=i+rad[i]-1,pos=i; &#125; printf("%lld\n",Ans);&#125;int main_main()&#123; int i; scanf("%s",s); n=strlen(s); for(i=0;i&lt;n;i++) &#123; A[i+1&lt;&lt;1]=s[i]; A[(i+1&lt;&lt;1)-1]=A[(i+1&lt;&lt;1)+1]='%'; Ins(s[i]-'a');R[i+1&lt;&lt;1]=las; &#125; for(i=1;i&lt;=tot;i++)ADD(pra[i][0],i); n=n&lt;&lt;1|1;DFS(rt);Manacher();&#125;const int main_stack=16;char my_stack[128&lt;&lt;20];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>分治法</category>
        <category>后缀自动机</category>
        <category>Manacher</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>Manacher</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4151 （TJOI 2016&HEOI 2016）字符串（后缀数组+倍增+主席树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4151-%EF%BC%88TJOI-2016-HEOI-2016%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E5%80%8D%E5%A2%9E-%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【Tjoi2016&amp;Heoi2016】字符串问题描述 佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为n的字符串s，和m个问题。佳媛姐姐必须正确回答这m个问题，才能打开箱子拿到礼物，升职加薪，出任CEO，嫁给高富帅，走上人生巅峰。每个问题均有a,b,c,d四个参数，问你子串s[a..b]的所有子串和s[c..d]的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？ 输入格式 输入的第一行有两个正整数n,m，分别表示字符串的长度和询问的个数。接下来一行是一个长为n的字符串。接下来m行，每行有4个数a,b,c,d，表示询问s[a..b]的所有子串和s[c..d]的最长公共前缀的最大值。 输出格式 对于每一次询问，输出答案。 样例输入 5 5aaaaa1 1 1 51 5 1 12 3 2 32 4 2 32 3 2 4 样例输出 11222 提示 1&lt;=n,m&lt;=100,000,字符串中仅有小写英文字母，a&lt;=b,c&lt;=d,1&lt;=a,b,c,d&lt;=n 此题思路比较直接，考虑到直接搞的麻烦，考虑二分答案，那么问题可以转化成求$[a,b-mid+1]$中是否存在一个位置开始的后缀与以$c$为开头的后缀的最长公共前缀大于$mid$ 考虑如何判断，考虑SA数组，显然与c开头的后缀最长公共前缀大于$mid$的后缀在SA数组中是连续的一个区间，那么问题即是求是否存在以$[a,b-mid+1]$开头的后缀在SA数组中的位置恰好在上述区间中，那么用主席树维护每个位置对应$SA$数组中出现位置的情况，直接查找即可。 关于找出区间，RMQ处理Height数组，然后倍增查找即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005#define M 10000005using namespace std;char s[N];int n,m,SA[N],Rank[N],H[N],F[N][20],S=18;int wa[N],wb[N],T[N];int tot,ls[M],rs[M],v[M],rt[N];bool equ(int *r,int a,int b,int l)&#123;return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;void GSA(char *r,int *sa,int a,int b)&#123; int i,j,p,*x=wa,*y=wb,*t; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[i]=r[i]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[i]]]=i; for(p=1,j=1;p&lt;a;j&lt;&lt;=1,b=p) &#123; for(p=0,i=a-j;i&lt;a;i++)y[p++]=i; for(i=0;i&lt;a;i++)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;b;i++)T[i]=0; for(i=0;i&lt;a;i++)T[x[y[i]]]++; for(i=1;i&lt;b;i++)T[i]+=T[i-1]; for(i=a-1;i&gt;=0;i--)sa[--T[x[y[i]]]]=y[i]; for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;a;i++) x[sa[i]]=equ(y,sa[i-1],sa[i],j)?p-1:p++; &#125;&#125;void GH(char *r,int *sa,int a)&#123; int i,j,k=0; for(i=1;i&lt;=a;i++)Rank[sa[i]]=i; for(i=0;i&lt;a;H[Rank[i++]]=k) for(k?k--:0,j=sa[Rank[i]-1];r[i+k]==r[j+k];k++);&#125;void RMQ()&#123; int i,j; for(i=1;i&lt;=n;i++)F[i][0]=H[i]; for(i=n;i&gt;=1;i--) for(j=1;i+(1&lt;&lt;j-1)&lt;=n;j++) F[i][j]=min(F[i][j-1],F[i+(1&lt;&lt;j-1)][j-1]);&#125;int CP(int x)&#123; int p=++tot; ls[p]=ls[x]; rs[p]=rs[x]; v[p]=v[x]; return p;&#125;int ADD(int p,int l,int r,int k)&#123; int o=CP(p); if(l==r)&#123;v[o]++;return o;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k); else rs[o]=ADD(rs[o],mid+1,r,k); v[o]=v[ls[o]]+v[rs[o]]; return o;&#125;int GS(int lp,int rp,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)return v[rp]-v[lp]; int mid=l+r&gt;&gt;1,cs=0; if(x&lt;=mid&amp;&amp;y&gt;=l)cs+=GS(ls[lp],ls[rp],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)cs+=GS(rs[lp],rs[rp],mid+1,r,x,y); return cs;&#125;bool ok(int t,int a,int b,int c)&#123; int l=Rank[c],r=Rank[c]; for(int i=S;i&gt;=0;i--) &#123; if(l-(1&lt;&lt;i)&gt;=0&amp;&amp;F[l-(1&lt;&lt;i)+1][i]&gt;=t)l=l-(1&lt;&lt;i); if(r+(1&lt;&lt;i)&lt;=n&amp;&amp;F[r+1][i]&gt;=t)r=r+(1&lt;&lt;i); &#125; return GS(rt[a-1],rt[b],1,n,l,r);&#125;void EF(int l,int r,int a,int b,int c)&#123; int mid; while(l&lt;=r) &#123; mid=l+r&gt;&gt;1; if(ok(mid,a,b-mid+1,c))l=mid+1; else r=mid-1; &#125; printf("%d\n",r);&#125;int main()&#123; int a,b,c,d; scanf("%d%d%s",&amp;n,&amp;m,s);s[n]='a'-1; GSA(s,SA,n+1,200);GH(s,SA,n);RMQ(); rt[0]=ADD(rt[0],1,n,Rank[0]); for(int i=1;i&lt;n;i++)rt[i]=ADD(rt[i-1],1,n,Rank[i]); while(m--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); a--;b--;c--;d--; EF(1,min(b-a+1,d-c+1),a,b,c); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
        <category>分治法</category>
        <category>主席树</category>
        <category>后缀数组</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>倍增</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4340 （SCOI 2014）方伯伯的OJ （Splay+map+set）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4340-%EF%BC%88SCOI-2014%EF%BC%89%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84OJ-%EF%BC%88Splay-map-set%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4340【SCOI2014】方伯伯的Oj问题描述 输入格式 输入的第1行包含2个用空格分隔的整数n和m，表示初始用户数和操作数。此后有m行，每行是一个询问，询问格式如上所示。 输出格式 输出包含m行。每行包含一个整数，其中第i行的整数表示第i个操作的输出。 样例输入 10 101 2 113 132 53 72 82 102 113 142 184 9 样例输出 22243557811 提示 对于 100% 的数据，1 ≤ n ≤ 10^8，1 ≤ m ≤ 10^5 输入保证对于所有的操作 1，2，3，x 必然已经出现在队列中，同时对于所有操作 1，1 ≤ y ≤ 2 × 10^8，并且 y 没有出现在队列中。 对于所有操作 4，保证 1 ≤ k ≤ n。 此题强制在线，观察发现$n$很大，那么显然此题应该根据$m$入手，考虑将Splay中的点维护一个区间，然后查询到了再拆开成3个点。 需要维护两个值，编号和排名，按照排名建立Splay，用map记录编号区间为$[a,b]$的点，还需要记录当前已经被拆过的点即查找过的位置，这样就可以通过编号找到在Splay中对应的位置，然后还需要开一个map记录表示一个点的点。 然后每种操作找到对应的Splay的位置，拆点后直接处理即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;set&gt;#define N 1000005using namespace std;struct node&#123; int l,r; bool operator&lt;(const node &amp;b)const &#123; if(l==b.l)return r&lt;b.r; return l&lt;b.l; &#125;&#125;;set&lt;int&gt;A;map&lt;int,int&gt;C;map&lt;node,int&gt;B;set&lt;int&gt;::iterator Ai;map&lt;node,int&gt;::iterator Bi;int n,m;int rt,ls[N],rs[N],fa[N],id[N],lid[N],rid[N],v[N],si[N],tot;void MT(int x)&#123;si[x]=si[ls[x]]+si[rs[x]]+v[x];&#125;void Zig(int x)&#123; int y=fa[x],z=fa[y]; if(z)y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Zag(int x)&#123; int y=fa[x],z=fa[y]; if(z)y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Splay(int x)&#123; int y,z; while(fa[x]) &#123; y=fa[x],z=fa[y]; if(z) &#123; if(y==ls[z])x==ls[y]?(Zig(y),Zig(x)):(Zag(x),Zig(x)); else x==rs[y]?(Zag(y),Zag(x)):(Zig(x),Zag(x)); &#125; else x==ls[y]?Zig(x):Zag(x); &#125; rt=x;&#125;int Gmax(int p)&#123; while(rs[p])p=rs[p]; return p;&#125;int Gmin(int p)&#123; while(ls[p])p=ls[p]; return p;&#125;int Find(int x)&#123; node tmp; if(C.count(x))return C[x]; Ai=A.lower_bound(x); tmp.r=*Ai-1;Ai--; tmp.l=*Ai+1; Bi=B.lower_bound(tmp); return Bi-&gt;second;&#125;int Div(int p,int x)&#123; int l,r;node tmp; Splay(p); A.insert(x); l=ls[p];r=rs[p]; fa[l]=fa[r]=ls[p]=rs[p]=0; if(lid[p]&lt;x-1) &#123; tot++; lid[tot]=lid[p]; rid[tot]=x-1; v[tot]=x-lid[p]; fa[l]=tot;ls[tot]=l; MT(tot);l=tot; tmp.l=lid[l]; tmp.r=rid[l]; B[tmp]=l; &#125; else if(lid[p]==x-1) &#123; tot++; id[tot]=lid[p]; v[tot]=1; fa[l]=tot; ls[tot]=l; MT(tot);l=tot; C[lid[p]]=tot; &#125; if(x+1&lt;rid[p]) &#123; tot++; lid[tot]=x+1; rid[tot]=rid[p]; v[tot]=rid[p]-x; fa[r]=tot;rs[tot]=r; MT(tot);r=tot; tmp.l=lid[r]; tmp.r=rid[r]; B[tmp]=r; &#125; else if(x+1==rid[p]) &#123; tot++; id[tot]=x+1; v[tot]=1; fa[r]=tot;rs[tot]=r; MT(tot);r=tot; C[x+1]=tot; &#125; fa[l]=fa[r]=++tot; ls[tot]=l;rs[tot]=r; id[tot]=x;v[tot]=1; C[x]=tot;MT(tot); return rt=tot;&#125;void Del(int p)&#123; int l=ls[p],r=rs[p]; fa[l]=fa[r]=ls[p]=rs[p]=0; if(!l)rt=r; else &#123; l=Gmax(l); Splay(l); fa[r]=l;rs[l]=r; rt=l;MT(l); &#125;&#125;int Gkth(int k)&#123; int p=rt; while(p) &#123; if(si[ls[p]]&lt;k&amp;&amp;si[ls[p]]+v[p]&gt;=k)return p; if(si[ls[p]]&gt;=k)p=ls[p]; else k-=si[ls[p]]+v[p],p=rs[p]; &#125; return p;&#125;int main()&#123; int i,j,k,x,y,z,p,l,r,t;node tmp; scanf("%d%d",&amp;n,&amp;m);int ans=0; rt=++tot;lid[rt]=1;rid[rt]=n;v[rt]=si[rt]=n; A.insert(0);A.insert(n+1); tmp.l=1;tmp.r=n;B[tmp]=rt; while(m--) &#123; scanf("%d",&amp;k); if(k==1) &#123; scanf("%d%d",&amp;x,&amp;y); x-=ans;y-=ans;p=Find(x); if(v[p]==1) &#123; id[p]=y;C[y]=p;Splay(p); ans=si[ls[p]]+1; printf("%d\n",ans); &#125; else &#123; p=Div(p,x);id[p]=y;C[y]=p; ans=si[ls[p]]+1; printf("%d\n",ans); &#125; &#125; if(k==2) &#123; scanf("%d",&amp;x); x-=ans;p=Find(x); if(v[p]==1) &#123; Splay(p); ans=si[ls[p]]+1; printf("%d\n",ans); Del(p);rs[p]=rt;fa[rt]=p;rt=p; &#125; else &#123; p=Div(p,x); ans=si[ls[p]]+1; printf("%d\n",ans); Del(p);rs[p]=rt;fa[rt]=p;rt=p; &#125; &#125; if(k==3) &#123; scanf("%d",&amp;x); x-=ans;p=Find(x); if(v[p]==1) &#123; Splay(p); ans=si[ls[p]]+1; printf("%d\n",ans); Del(p);ls[p]=rt;fa[rt]=p;rt=p; &#125; else &#123; p=Div(p,x); ans=si[ls[p]]+1; printf("%d\n",ans); Del(p);ls[p]=rt;fa[rt]=p;rt=p; &#125; &#125; if(k==4) &#123; scanf("%d",&amp;x); x-=ans;p=Gkth(x);Splay(p); if(v[p]==1)ans=id[p],printf("%d\n",ans); else &#123; t=x-si[ls[p]]; x=lid[p]+t-1; p=Div(p,x); ans=id[p]; printf("%d\n",ans); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4345 （Ipsc2015）Generating Synergy （DFS序+kd树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4345-%EF%BC%88Ipsc2015%EF%BC%89Generating-Synergy-%EF%BC%88DFS%E5%BA%8F-kd%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4345[Ipsc2015]Generating Synergy问题描述 给定一棵以1为根的有根树,初始所有节点颜色为1,每次将距离节点a不超过l的a的子节点染成c,或询问点a的颜色 输入格式 第一行一个数T,表示数据组数 接下来每组数据的第一行三个数n,c,q表示结点个数,颜色数和操作数 接下来一行n-1个数描述2..n的父节点 接下来q行每行三个数a,l,c 若c为0,表示询问a的颜色 否则将距离a不超过l的a的子节点染成c 输出格式 设当前是第i个操作,y_i为本次询问的答案(若本次操作是一个修改则y_i为0),令z_i=i*y_i,请输出z_1+z_2+…+z_q模10^9+7 样例输入 14 3 71 2 23 0 02 1 33 0 01 0 22 0 04 1 14 0 0 样例输出 32 提示 第1,3,5,7的询问的答案分别为1,3,3,1,所以答案为 11+20+33+40+53+60+7*1=32. 数据范围: 对于100%的数据T&lt;=6,n,m,c&lt;=10^5, 1&lt;=a&lt;=n,0&lt;=l&lt;=n,0&lt;=c&lt;=c 首先求出这棵树的DFS序和每个节点的深度，那么将DFS序的$In$作为$x$坐标，将深度作为$y$坐标，建立kd树，那么每次询问直接找对应点，修改就变成将以$(In[a],dep[a])$，$(Out[a],dep[a]+l)$为左上和右下顶点的矩形区域整体修改，kd树+lazy即可解决。 另外，也可以用树套树维护，但显然不如kd树好写。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 222222#define ll long longusing namespace std;int rt,D,T,n,c,q,x1,x2,y1,y2;int L[N],R[N],dep[N],VT,mod=1e9+7;int LA[N],NE[N],EN[N],TOT;struct node&#123; int d[2],x[2],y[2],son[2],v,lazy; bool operator&lt;(const node &amp;b)const &#123;return d[D]&lt;b.d[D];&#125;&#125;kdt[N];void PD(int p)&#123; int ls=kdt[p].son[0],rs=kdt[p].son[1]; kdt[ls].v=kdt[rs].v=kdt[p].lazy; kdt[ls].lazy=kdt[rs].lazy=kdt[p].lazy; kdt[p].lazy=0;&#125;void MT(int p,int s)&#123; kdt[p].x[0]=min(kdt[p].x[0],kdt[s].x[0]); kdt[p].x[1]=max(kdt[p].x[1],kdt[s].x[1]); kdt[p].y[0]=min(kdt[p].y[0],kdt[s].y[0]); kdt[p].y[1]=max(kdt[p].y[1],kdt[s].y[1]);&#125;int BT(int l,int r,int d)&#123; D=d;int o=l+r&gt;&gt;1; kdt[o].v=1; kdt[o].x[0]=kdt[o].x[1]=kdt[o].d[0]; kdt[o].y[0]=kdt[o].y[1]=kdt[o].d[1]; if(l&lt;o)kdt[o].son[0]=BT(l,o-1,d^1),MT(o,kdt[o].son[0]); if(o&lt;r)kdt[o].son[1]=BT(o+1,r,d^1),MT(o,kdt[o].son[1]); return o;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int f)&#123; L[x]=++VT;dep[x]=dep[f]+1; for(int i=LA[x];i;i=NE[i])DFS(EN[i],x); R[x]=VT;&#125;int GA(int p)&#123; if(kdt[p].lazy)PD(p); if(kdt[p].d[0]==x1&amp;&amp;kdt[p].d[1]==y1)return kdt[p].v; int s=0,ls=kdt[p].son[0],rs=kdt[p].son[1]; if(kdt[ls].x[0]&lt;=x1&amp;&amp;kdt[ls].x[1]&gt;=x1&amp;&amp;kdt[ls].y[0]&lt;=y1&amp;&amp;kdt[ls].y[1]&gt;=y1)s+=GA(ls); if(kdt[rs].x[0]&lt;=x1&amp;&amp;kdt[rs].x[1]&gt;=x1&amp;&amp;kdt[rs].y[0]&lt;=y1&amp;&amp;kdt[rs].y[1]&gt;=y1)s+=GA(rs); return s;&#125;void CHA(int p,int k)&#123; if(kdt[p].lazy)PD(p); if(kdt[p].d[0]&lt;=x2&amp;kdt[p].d[0]&gt;=x1&amp;&amp;kdt[p].d[1]&lt;=y2&amp;&amp;kdt[p].d[0]&gt;=y1)kdt[p].v=k; if(kdt[p].x[0]&gt;x2||kdt[p].x[1]&lt;x1||kdt[p].y[0]&gt;y2||kdt[p].y[1]&lt;y1)return; if(kdt[p].x[1]&lt;=x2&amp;&amp;kdt[p].x[0]&gt;=x1&amp;&amp;kdt[p].y[1]&lt;=y2&amp;&amp;kdt[p].y[0]&gt;=y1)&#123;kdt[p].v=kdt[p].lazy=k;return;&#125; CHA(kdt[p].son[0],k);CHA(kdt[p].son[1],k);&#125;int main()&#123; int i,k,x,y;ll ans; scanf("%d",&amp;T); while(T--) &#123; TOT=VT=ans=0; memset(kdt,0,sizeof(kdt)); memset(LA,0,sizeof(LA)); scanf("%d%d%d",&amp;n,&amp;c,&amp;q); for(i=2;i&lt;=n;i++)scanf("%d",&amp;x),ADD(x,i); DFS(1,0); for(i=1;i&lt;=n;i++)kdt[i].d[0]=L[i],kdt[i].d[1]=dep[i]; rt=BT(1,n,0); for(i=1;i&lt;=q;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); if(k==0) &#123; x1=L[x];y1=dep[x]; ans=(ans+1ll*GA(rt)*i)%mod; &#125; else &#123; x1=L[x];x2=R[x]; y1=dep[x];y2=dep[x]+y; CHA(rt,k); &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>杂学</category>
        <category>DFS序</category>
        <category>kd树</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>kd树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3884 （NOI 2005） 维修数列（Splay）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3884-%EF%BC%88NOI-2005%EF%BC%89-%E7%BB%B4%E4%BF%AE%E6%95%B0%E5%88%97%EF%BC%88Splay%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3884 NOI2005维修数列问题描述 输入格式 第1行包含两个数N和M，N表示初始时数列中数的个数，M表示要进行的操作数目。第2行包含N个数字，描述初始时的数列。以下M行，每行一条命令，格式参见问题描述中的表格。 输出格式 对于输入数据中的GET-SUM和MAX-SUM操作，向输出文件依次打印结果，每个答案（数字）占一行。 样例输入 9 82 -6 3 5 1 -5 -3 6 3GET-SUM 5 4MAX-SUMINSERT 8 3 -5 7 2DELETE 12 1MAKE-SAME 3 3 2REVERSE 3 6GET-SUM 5 4MAX-SUM 样例输出 -110110 提示 你可以认为在任何时刻，数列中至少有 1 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 50%的数据中，任何时刻数列中最多含有 30 000 个数； 100%的数据中，任何时刻数列中最多含有 500 000 个数。 100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。 100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件 大小不超过 20MBytes。 Splay模板题，修改和翻转用lazy，维护区间和，考虑如何维护最大区间和，用类似线段树的方法解决即可。注意当儿子为0时要特别小心。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 8000005#define max(a,b) ((a&gt;b)?(a):(b))using namespace std;const int Inf=99999999;int n,m,A[N],L,R;int tot,rt,ls[N],rs[N],fa[N],si[N],v[N],lazy1[N],lazy2[N],lmax[N],rmax[N],Max[N],sum[N];int GM(int x,int y,int z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;void MT(int p)&#123; lmax[p]=GM(lmax[ls[p]],sum[ls[p]]+v[p],sum[ls[p]]+v[p]+lmax[rs[p]]); rmax[p]=GM(rmax[rs[p]],sum[rs[p]]+v[p],sum[rs[p]]+v[p]+rmax[ls[p]]); Max[p]=GM(Max[ls[p]],Max[rs[p]],max(0,lmax[rs[p]])+max(0,rmax[ls[p]])+v[p]); sum[p]=sum[ls[p]]+sum[rs[p]]+v[p]; si[p]=si[ls[p]]+si[rs[p]]+1;&#125;void PD(int p)&#123; if(lazy1[p]) &#123; swap(ls[ls[p]],rs[ls[p]]); swap(lmax[ls[p]],rmax[ls[p]]); swap(ls[rs[p]],rs[rs[p]]); swap(lmax[rs[p]],rmax[rs[p]]); lazy1[ls[p]]^=1; lazy1[rs[p]]^=1; &#125; if(lazy2[p]!=Inf) &#123; v[ls[p]]=v[rs[p]]=lazy2[p]; sum[ls[p]]=lazy2[p]*si[ls[p]]; sum[rs[p]]=lazy2[p]*si[rs[p]]; lmax[ls[p]]=rmax[ls[p]]=Max[ls[p]]=lazy2[p]&gt;0?lazy2[p]*si[ls[p]]:lazy2[p]; lmax[rs[p]]=rmax[rs[p]]=Max[rs[p]]=lazy2[p]&gt;0?lazy2[p]*si[rs[p]]:lazy2[p]; lazy2[ls[p]]=lazy2[rs[p]]=lazy2[p]; &#125; lazy1[p]=0;lazy2[p]=Inf;&#125;void Zig(int x)&#123; int y=fa[x],z=fa[y]; if(y==ls[z])ls[z]=x;else rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Zag(int x)&#123; int y=fa[x],z=fa[y]; if(y==ls[z])ls[z]=x;else rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Splay(int x,int t)&#123; int y,z; while(fa[x]!=t) &#123; y=fa[x];z=fa[y]; if(z)PD(z); if(y)PD(y); if(x)PD(x); if(z!=t) &#123; if(y==ls[z]) &#123; if(x==ls[y])Zig(y),Zig(x); else Zag(x),Zig(x); &#125; else &#123; if(x==rs[y])Zag(y),Zag(x); else Zig(x),Zag(x); &#125; &#125; else if(x==ls[y])Zig(x);else Zag(x); &#125; if(!t)rt=x;&#125;int BT(int x,int y)&#123; if(x&gt;y)return 0; int p=++tot; lazy2[p]=Inf; if(x==y&amp;&amp;x==0)L=p; if(x==y&amp;&amp;x==n+1)R=p; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; if(mid==0)L=p; if(mid==n+1)R=p; v[p]=A[mid]; ls[p]=BT(x,mid-1); rs[p]=BT(mid+1,y); fa[ls[p]]=p; fa[rs[p]]=p; MT(p); &#125; else v[p]=sum[p]=lmax[p]=rmax[p]=Max[p]=A[x],si[p]=1; return p;&#125;int Find(int k)&#123; int p=rt; while(p) &#123; PD(p); if(si[ls[p]]+1==k)return p; if(si[ls[p]]&gt;=k)p=ls[p]; else k-=si[ls[p]]+1,p=rs[p]; &#125; return p;&#125;void INS()&#123; int i,x,y,a,b; scanf("%d%d",&amp;x,&amp;y); for(i=1;i&lt;=y;i++)scanf("%d",&amp;A[i]); a=Find(x+1);b=Find(x+2); Splay(a,0);Splay(b,rt); tot++; v[tot]=sum[tot]=lmax[tot]=rmax[tot]=Max[tot]=A[1]; lazy2[tot]=Inf;si[tot]=1; for(i=2;i&lt;=y;i++) &#123; tot++; v[tot]=A[i]; lazy2[tot]=Inf; ls[tot]=tot-1; fa[tot-1]=tot; MT(tot); &#125; fa[tot]=b;ls[b]=tot;MT(b);MT(a);&#125;void DEL()&#123; int x,y,a,b; scanf("%d%d",&amp;x,&amp;y); a=Find(x);b=Find(x+y+1); Splay(a,0);Splay(b,rt); fa[ls[rs[rt]]]=0; ls[rs[rt]]=0; MT(rs[rt]); MT(rt);&#125;void CHA()&#123; int x,y,z,a,b,p; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); a=Find(x);b=Find(x+y+1); Splay(a,0);Splay(b,rt); p=ls[rs[rt]]; lazy2[p]=z; v[p]=z;sum[p]=z*si[p]; lmax[p]=rmax[p]=Max[p]=z&gt;0?z*si[p]:z; MT(rs[rt]); MT(rt);&#125;void REV()&#123; int x,y,a,b,p; scanf("%d%d",&amp;x,&amp;y); a=Find(x);b=Find(x+y+1); Splay(a,0);Splay(b,rt); p=ls[rs[rt]]; lazy1[p]^=1; swap(ls[p],rs[p]); swap(lmax[p],rmax[p]); MT(rs[rt]); MT(rt);&#125;void SUM()&#123; int x,y,a,b; scanf("%d%d",&amp;x,&amp;y); a=Find(x);b=Find(x+y+1); Splay(a,0);Splay(b,rt); printf("%d\n",sum[ls[rs[rt]]]);&#125;void MAX()&#123; Splay(L,0);Splay(R,rt); printf("%d\n",Max[ls[rs[rt]]]);&#125;int main()&#123; int i,x,y,z;char s[15]; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); rt=BT(0,n+1); while(m--) &#123; scanf("%s",s); if(s[2]=='S')INS(); if(s[2]=='L')DEL(); if(s[2]=='K')CHA(); if(s[2]=='V')REV(); if(s[2]=='T')SUM(); if(s[2]=='X')MAX(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3937 为何奶牛要穿过马路1 （树状数组）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3937-%E4%B8%BA%E4%BD%95%E5%A5%B6%E7%89%9B%E8%A6%81%E7%A9%BF%E8%BF%87%E9%A9%AC%E8%B7%AF1-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3937为何奶牛要穿过马路1问题描述 有一条笔直道路穿过约翰的农场。道路的一侧有N个牛棚，编号1到N的N头奶牛分布在这N个牛棚里，每个牛棚只有一头牛。道路的另一侧也有N个牛棚，编号1到N的N头奶牛分布在这N个牛棚里，每个牛棚只有一头牛。相同编号的奶牛经常穿过马路互相拜访，由于奶牛们穿非常频发地穿马路，导致奶牛们经常相撞(线路交叉导致)。约翰想重新布置一下牛棚，减少碰撞事故。约翰打算采取“循环移位”的方式布置牛棚。所谓循环移位是指，比如道路一侧有7个牛棚，里面居住的奶牛编号分别是3、7、1、2、5、4、6,如果约翰打算将牛棚往右移动2个位置，那么移位后，新的顺序是4、6、3、7、1、2、5。只能移动其中一侧的牛棚。。请你帮约翰计算一下，怎样移动才能使得奶牛将相互访问的交叉线路最少，输出这个最少交叉数。 输入格式 第一行，一个整数N（1≤N≤100,000）接下来N行，每行一个整数，按从左往右的顺序给出了道路一侧奶牛的分布情况。接下来N行，每行一个整数，按从左往右的顺序给出了道路另一侧奶牛的分布情况。 输出格式 一个整数，表示所求最少交叉线路数。 样例输入 1 55413213254 样例输出 1 0 样例输入 2 713572461234567 样例输出 2 6 只能转一边，那么显然分开讨论。假设转上面的序列。令上面的序列为$A$，下面的为$B$，那么令$C[i]$表示$A[i]$在$B$中出现的位置，那么显然交叉数就是$C$序列的逆序对数，那么用树状数组算出来。然后考虑转动$C$，那么显然把$C$序列的最后一个数拿出来会减少的逆序对数是已知的，然后将他加到序列的开头会增加的逆序对数也是已知的，那么转动一次后的逆序对数可以$O(1)$算出来，那么直接枚举转动即可。 转动下面的序列同样处理，取最小值即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;cstring&gt;#define ll long long#define min(a,b) (a&lt;b?a:b)#define N 200005using namespace std;ll n,A[N],B[N],C[N],D[N],E[N];ll MD(ll x,ll d)&#123;for(ll i=x;i&lt;=n;i+=(i&amp;-i))D[i]+=d;&#125;ll GS(ll x)&#123; ll i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=D[i]; return sum;&#125;int main()&#123; ll i,j,k,ans=0,tmp; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]),E[A[i]]=i; for(i=1;i&lt;=n;i++)scanf("%lld",&amp;B[i]),C[B[i]]=i; for(i=1;i&lt;=n;i++)A[i]=C[A[i]]; for(i=1;i&lt;=n;i++)B[i]=E[B[i]]; for(i=1;i&lt;=n;i++) &#123; ans+=i-1-GS(A[i]); MD(A[i],1); &#125; tmp=ans; for(i=1;i&lt;=n;i++) &#123; tmp+=n-2*A[i]+1; ans=min(ans,tmp); &#125; memset(D,0,sizeof(D));tmp=0; for(i=1;i&lt;=n;i++) &#123; tmp+=i-1-GS(B[i]); MD(B[i],1); &#125; ans=min(ans,tmp); for(i=1;i&lt;=n;i++) &#123; tmp+=n-2*B[i]+1; ans=min(ans,tmp); &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2991 （NOI 2014） 魔法森林 （动态树+最小生成树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2991-%EF%BC%88NOI-2014%EF%BC%89-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2991【NOI2014 Day1】魔法森林问题描述 输入格式 输出格式 样例输入1 4 51 2 19 12 3 8 122 4 12 151 3 17 83 4 1 17 样例输入2 3 11 2 1 1 样例输出1 32 样例输出2 -1 数据范围 注意到这道题每条边有两个权值，所求为经过路径上每种权值的最大值之和的最小值。 考虑只有一种权值，那么显然最小生成树。考虑有两种权值，那么将边按一种权值排序，从小到大讨论，维护另一种权值的最小生成树，而当前的答案 就是当前边的第一种权值，加上另一种权值的最小生成树上从1到N的最大权值。 正确性是显然的，讨论完所有边取所有答案的最小值即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 500005using namespace std;struct node&#123;int x,y,a,b,id;&#125;edge[N];int n,m,S[N],top,Hash[N],F[N],ans;int ls[N],rs[N],fa[N],v[N],Max[N],id[N],rev[N];int GF(int x)&#123; if(F[x]!=x)F[x]=GF(F[x]); return F[x];&#125;bool cmp(node aa,node bb)&#123;return aa.a&lt;bb.a;&#125;int GM(int x,int y,int z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;bool Isroot(int x)&#123;return ls[fa[x]]!=x&amp;&amp;rs[fa[x]]!=x;&#125;void MT(int x)&#123; Max[x]=GM(v[x],Max[ls[x]],Max[rs[x]]); if(Max[x]==v[x])id[x]=x; else if(Max[x]==Max[ls[x]])id[x]=id[ls[x]]; else id[x]=id[rs[x]];&#125;void PD(int x)&#123; if(rev[x]) &#123; swap(ls[x],rs[x]); rev[ls[x]]^=1; rev[rs[x]]^=1; rev[x]^=1; &#125;&#125;void Zig(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Zag(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Splay(int x)&#123; int i,y,z; S[++top]=x; for(i=x;!Isroot(i);i=fa[i])S[++top]=fa[i]; while(top)PD(S[top--]); while(!Isroot(x)) &#123; y=fa[x];z=fa[y]; if(!Isroot(y)) &#123; if(y==ls[z])x==ls[y]?(Zig(y),Zig(x)):(Zag(x),Zig(x)); else x==rs[y]?(Zag(y),Zag(x)):(Zig(x),Zag(x)); &#125; else x==ls[y]?Zig(x):Zag(x); &#125;&#125;void Access(int x)&#123; for(int t=0;x;x=fa[x]) &#123; Splay(x); rs[x]=t; MT(x);t=x; &#125;&#125;void Makeroot(int x)&#123; Access(x); Splay(x); rev[x]^=1;&#125;int Findroot(int x)&#123; Access(x); Splay(x); while(ls[x])x=ls[x]; return x;&#125;void Link(int x,int y)&#123; Makeroot(x); fa[x]=y;&#125;void Cut(int x,int y)&#123; Makeroot(x); Access(y); Splay(y); ls[y]=fa[x]=0;&#125;bool Kruscal()&#123; int i,j,k,x,y,cnt;bool f=0; for(i=1;i&lt;=n;i++)F[i]=i; i=1;cnt=0;ans=1e9; while(i&lt;=m) &#123; x=GF(edge[i].x); y=GF(edge[i].y); if(x!=y) &#123; F[x]=y;cnt++; Link(edge[i].x,edge[i].id); Link(edge[i].y,edge[i].id); &#125; else &#123; Makeroot(edge[i].x); Access(edge[i].y); Splay(edge[i].y); if(Max[edge[i].y]&gt;edge[i].b) &#123; k=Hash[id[edge[i].y]]; Cut(edge[k].x,edge[k].id); Cut(edge[k].y,edge[k].id); Link(edge[i].x,edge[i].id); Link(edge[i].y,edge[i].id); &#125; &#125; if(f||Findroot(1)==Findroot(n)) &#123; Makeroot(1); Access(n); Splay(n); ans=min(ans,edge[i].a+Max[n]); f=1; &#125; i++; &#125; if(f)return 1; return 0;&#125;int main()&#123; int i,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)scanf("%d%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].a,&amp;edge[i].b),edge[i].id=n+i; sort(edge+1,edge+m+1,cmp); for(i=1;i&lt;=m;i++)Hash[edge[i].id]=i,v[edge[i].id]=edge[i].b; if(Kruscal())printf("%d",ans); else printf("-1");&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>最小生成树</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2698 Nicole的博客 （动态树+最小生成树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2698-Nicole%E7%9A%84%E5%8D%9A%E5%AE%A2-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2698【动态树】Nicole的博客问题描述 给你一个由N个节点M条带权边构成的无向简单图，然后进行Q次操作：·1 x y ：询问一条连接x,y的路径，使路径上权值最大的边权值最小；·2 x y ：删除原本连接x,y的边，保证这条边存在。对每次询问，输出路径上权值最大的边的权值。 输入格式 第一行三个数N,M,Q接下来M行每行三个数x,y,z，表示有一条连接x,y的边，权值为z接下来Q行，每行k,x,y，表示一次操作 输出格式 对每次询问输出一行 样例输入 4 4 31 2 22 3 33 4 21 4 21 1 42 1 41 1 4 样例输出 23 提示 1&lt;=N&lt;=1000001&lt;=M&lt;=10000001&lt;=Q&lt;=1000001&lt;=x,y&lt;=N1&lt;=z&lt;=109保证任意时刻整个图连通 由询问可知，显然维护一颗最小生成树，然后考虑操作二，删边，不好操作。考虑离线，显然倒序讨论，那么删边变成加边，用LCT维护这颗最小生成树，直接搞就好。关于处理边权，将边变成点，然后往两个端点连边即可转化成点权。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2000005using namespace std;struct node&#123;int x,y,z,id;bool f;&#125;edge[N];bool cmp1(node a,node b)&#123;return a.z&lt;b.z;&#125;bool cmp2(node a,node b)&#123; if(a.x==b.x)return a.y&lt;b.y; return a.x&lt;b.x;&#125;int n,m,q,top,S[N],F[N],Hash[N];int ty[N],A[N],B[N],Ans[N];int ls[N],rs[N],fa[N],Max[N],id[N],v[N],rev[N];int GM(int x,int y,int z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;bool Isroot(int x)&#123;return ls[fa[x]]!=x&amp;&amp;rs[fa[x]]!=x;&#125;void MT(int p)&#123; Max[p]=GM(v[p],Max[ls[p]],Max[rs[p]]); if(Max[p]==v[p])id[p]=p; else if(Max[p]==Max[ls[p]])id[p]=id[ls[p]]; else id[p]=id[rs[p]];&#125;void PD(int p)&#123; if(rev[p]) &#123; swap(ls[p],rs[p]); rev[ls[p]]^=1; rev[rs[p]]^=1; rev[p]^=1; &#125;&#125;void Zig(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; ls[y]=rs[x];fa[rs[x]]=y; rs[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Zag(int x)&#123; int y=fa[x],z=fa[y]; if(!Isroot(y))y==ls[z]?ls[z]=x:rs[z]=x;fa[x]=z; rs[y]=ls[x];fa[ls[x]]=y; ls[x]=y;fa[y]=x; MT(y);MT(x);&#125;void Splay(int x)&#123; int i,y,z; S[++top]=x; for(i=x;!Isroot(i);i=fa[i])S[++top]=fa[i]; while(top)PD(S[top--]); while(!Isroot(x)) &#123; y=fa[x];z=fa[y]; if(!Isroot(y)) &#123; if(y==ls[z])x==ls[y]?(Zig(y),Zig(x)):(Zag(x),Zig(x)); else x==rs[y]?(Zag(y),Zag(x)):(Zig(x),Zag(x)); &#125; else x==ls[y]?Zig(x):Zag(x); &#125;&#125;void Access(int x)&#123; for(int t=0;x;x=fa[x]) &#123; Splay(x); rs[x]=t; MT(x);t=x; &#125;&#125;void Makeroot(int x)&#123; Access(x); Splay(x); rev[x]^=1;&#125;void Link(int x,int y)&#123; Makeroot(x); fa[x]=y;&#125;void Cut(int x,int y)&#123; Makeroot(x); Access(y); Splay(y); ls[y]=fa[x]=0;&#125;int GF(int x)&#123; if(F[x]!=x)F[x]=GF(F[x]); return F[x];&#125;void Kruscal()&#123; int i=1,cnt=0,x,y,fx,fy; while(cnt&lt;n-1) &#123; if(edge[i].f)&#123;i++;continue;&#125; x=GF(edge[i].x); y=GF(edge[i].y); if(x!=y) &#123; F[x]=y; cnt++; Link(edge[i].id,edge[i].x); Link(edge[i].id,edge[i].y); &#125; i++; &#125;&#125;int main()&#123; int i,j,k,x,y,z;node tmp; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].z); if(edge[i].y&lt;edge[i].x)swap(edge[i].x,edge[i].y); edge[i].id=n+i;v[n+i]=edge[i].z; &#125; sort(edge+1,edge+m+1,cmp2); for(i=1;i&lt;=q;i++) &#123; scanf("%d%d%d",&amp;ty[i],&amp;A[i],&amp;B[i]); if(ty[i]==1)continue; if(A[i]&gt;B[i])swap(A[i],B[i]); tmp.x=A[i];tmp.y=B[i]; j=lower_bound(edge+1,edge+m+1,tmp,cmp2)-edge; edge[j].f=1; &#125; for(i=1;i&lt;=m;i++)Hash[edge[i].id]=i; for(i=1;i&lt;=n;i++)F[i]=i; sort(edge+1,edge+m+1,cmp1); Kruscal(); sort(edge+1,edge+m+1,cmp2); for(i=q;i&gt;=1;i--) &#123; if(ty[i]==1) &#123; Makeroot(A[i]); Access(B[i]); Splay(B[i]); Ans[i]=Max[B[i]]; &#125; else &#123; tmp.x=A[i];tmp.y=B[i]; j=lower_bound(edge+1,edge+m+1,tmp,cmp2)-edge; Makeroot(A[i]); Access(B[i]); Splay(B[i]); if(edge[j].z&lt;Max[B[i]]) &#123; k=Hash[id[B[i]]]; Cut(edge[k].x,edge[k].id); Cut(edge[k].y,edge[k].id); Link(edge[j].x,edge[j].id); Link(edge[j].y,edge[j].id); &#125; &#125; &#125; for(i=1;i&lt;=q;i++)if(ty[i]==1)printf("%d\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>最小生成树</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2638 （SDOI 2013） 森林 （启发式LCA+主席树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2638-%EF%BC%88SDOI-2013%EF%BC%89-%E6%A3%AE%E6%9E%97-%EF%BC%88%E5%90%AF%E5%8F%91%E5%BC%8FLCA-%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2638【SDOI2013 R1 Day1】森林问题描述 输入格式 第一行包含一个正整数testcase，表示当前测试数据的测试点编号。保证1≤testcase≤20。第二行包含三个整数N，M，T，分别表示节点数、初始边数、操作数。第三行包含N个非负整数表示 N个节点上的权值。接下来 M行，每行包含两个整数x和 y，表示初始的时候，点x和点y 之间有一条无向边,接下来 T行，每行描述一个操作，格式为“Q x y k”或者“L x y ”，其含义见题目描述部分。 输出格式 对于每一个第一类操作，输出一个非负整数表示答案。 样例输入 18 4 81 1 2 2 3 3 4 44 71 82 42 1Q 8 7 3Q 3 5 1Q 10 0 0L 5 4L 3 2L 0 7Q 9 2 5Q 6 1 6 样例输出 22142 注意观察，此题只有连接操作，而没有权值修改和删除操作，因此我们先考虑如果是一棵树的情况，那么显然用主席树维护，考虑主席树求第K小的时候，是两颗树相减，那么在树上只需要将每个节点都搞一棵主席树，等于他父亲那颗树加上他的权，那么就是x对应的树+y对应的树-LCA对应的树，然后加上LCA的单独点权即可。 那么考虑森林，因为只有连接操作，那么考虑暴力维护LCA，发现每次连接两颗树的时候，需要选一棵树来重新构建LCA，显然选点更少的一棵。可以证明，重构的复杂度不超过$O(n\log_2^2n)$，于是启发式合并暴力重构即可。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define M 20000005using namespace std;int n,m,t,A[N],B[N],F[N],si[N];int fa[N][20],dep[N],S=19;int TOT,LA[N],NE[N],EN[N];int tot,rt[N],ls[M],rs[M],v[M];bool mark[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int GF(int x)&#123; if(F[x]!=x)F[x]=GF(F[x]); return F[x];&#125;int CO(int p)&#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; v[o]=v[p]; return o;&#125;int MD(int p,int l,int r,int k)&#123; int o=CO(p);v[o]++; if(l==r)return o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=MD(ls[p],l,mid,k); else rs[o]=MD(rs[p],mid+1,r,k); return o;&#125;void DFS(int x,int f)&#123; int i,y; dep[x]=dep[f]+1; fa[x][0]=f; rt[x]=MD(rt[f],1,n,A[x]); for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)DFS(y,x); &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); int i,t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++)if(t&gt;&gt;i&amp;1)x=fa[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int Gans(int p1,int p2,int p3,int l,int r,int k,int x)&#123; if(l==r)return l; int mid=l+r&gt;&gt;1; int sum=v[ls[p1]]+v[ls[p2]]-2*v[ls[p3]]+(x&gt;=l&amp;&amp;x&lt;=mid); if(k&lt;=sum)return Gans(ls[p1],ls[p2],ls[p3],l,mid,k,x); return Gans(rs[p1],rs[p2],rs[p3],mid+1,r,k-sum,x);&#125;int main_main()&#123; int i,j,k,x,y,z,fx,fy,ans=0;char s[2]; scanf("%d",&amp;k); scanf("%d%d%d",&amp;n,&amp;m,&amp;t); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),B[i]=A[i]; sort(B+1,B+n+1); for(i=1;i&lt;=n;i++)A[i]=lower_bound(B+1,B+n+1,A[i])-B; for(i=1;i&lt;=n;i++)F[i]=i,si[i]=1; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); x=GF(x);y=GF(y); F[x]=y;si[y]+=si[x]; &#125; for(i=1;i&lt;=n;i++) &#123; x=GF(i); if(!mark[x])DFS(x,0); mark[x]=1; &#125; while(t--) &#123; scanf("%s",s); if(s[0]=='Q') &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); x^=ans;y^=ans;k^=ans; z=LCA(x,y); ans=B[Gans(rt[x],rt[y],rt[z],1,n,k,A[z])]; printf("%d\n",ans); &#125; else &#123; scanf("%d%d",&amp;x,&amp;y); x^=ans;y^=ans; fx=GF(x);fy=GF(y); if(si[fx]&gt;si[fy])swap(x,y); F[fx]=fy;si[fy]+=si[fx]; ADD(x,y);ADD(y,x); fa[x][0]=y;DFS(x,y); &#125; &#125;&#125;const int main_stack=16;char my_stack[128&lt;&lt;21];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>主席树</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2409 田忌赛马 （DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2409-%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC-%EF%BC%88DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2409【9月月赛T2】田忌赛马问题描述 中国古代的历史故事“田忌赛马”是为大家所熟知的。话说齐王和田忌又要赛马了，他们各派出N匹马，每场比赛，输的一方将要给赢的一方200两黄金，如果是平局的话，双方都不必拿出钱。现在每匹马的速度值是固定而且已知的，而齐王出马也不管田忌的出马顺序。请问田忌该如何安排自己的马去对抗齐王的马，才能赢取最多的钱？ 输入格式 第1行为一个正整数n，表示双方马的数量。第2行有N个整数表示田忌的马的速度。第3行的N个整数为齐王的马的速度。 输出格式 仅有1行，田忌赛马可能赢得的最多的钱，结果有可能为负。 样例输入 392 83 7195 87 74 样例输出 200 提示 0&lt;=n&lt;=2000 马的速度&lt;=10000 此题可以借鉴田忌赛马的方式，将田忌和齐王的马从大到小排序，然后我们依次讨论用那匹马去对齐王的队首马，显然要么用队首的马，要么用队尾的马，因此可以令$F[i][j]$表示用第i匹马到第j匹马去对齐王剩下的$j-i+1$匹马的最大收益，然后转移即可。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b;&#125;int n,A[2005],B[2005],F[2005][2005];int G(int a,int b)&#123; if(A[a]&gt;B[b])return 200; if(A[a]==B[b])return 0; if(A[a]&lt;B[b])return -200;&#125;int dp(int x,int y)&#123; if(x==y)return F[x][y]=G(x,n); if(F[x][y]!=F[0][0])return F[x][y]; return F[x][y]=max(dp(x+1,y)+G(x,n+x-y),dp(x,y-1)+G(y,n+x-y));&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;B[i]); sort(A+1,A+n+1,cmp); sort(B+1,B+n+1,cmp); memset(F,-10,sizeof(F)); printf("%d\n",dp(1,n));&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2106 机密谍报 （并查集）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2106-%E6%9C%BA%E5%AF%86%E8%B0%8D%E6%8A%A5-%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2106 机密谍报问题描述 HY 非常喜欢和 GJQ 闲聊，而其他人等都还奋斗在 OI 的道路上，为了不打扰同学，他们交流统一用密文，交流信息的明文是由0和1组成的非空序列，而密文是由0、1和若干个密码字母组成，每个 密码字母代表不同的01串，例如，密文 011a0bf00a01。密码破译的关键是确定每个密码的含义。经过长期统计分析，现在知道了每个密码的固定长度，如今，蛋疼的同学们又截获了它们俩的两段 密文S1 和S2 ，并且知道S1 =S2 ，即两段密文代表相同的明文。你的任务是帮助同学们对给定的两段密文进行分析，看一看有多少种可能的明文。 输入格式 第 1 行：S1 (第 1 段密文)第 2 行：S2 (第 2 段密文)第 3 行：N(密码总数，N ≤ 26)第 4−N+3 行：字母 i长度i (密码用小写英文字母表示，密码长度 ≤ 100) 输出格式 M（表示有 M种可能的明文） 样例输入 100ad1cc14a 2d 3c 4b 50 样例输出 2 提示 明文的长度 ≤ 10000，保证不用高精度 此题其实很水，用并查集将相同的位置合并起来，然后再把值为0的位置合并到一个集合里，值为1的位置合并到一个集合里，然后既不在0集合里也不在1集合里的集合数就是不能确定的位置数，答案就是$2^n$ 但是注意判无解，如果最后0集合和1集合在一个集合里，即表示某位置既是0又是1，则无解。或者两个串长度不相同，也无解。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;assert.h&gt;#define N 1000005using namespace std;const int mod=998244353;int add(int a,int b)&#123;a+=b;return a&gt;=mod?a-mod:a;&#125;int sub(int a,int b)&#123;a-=b;return a&lt;0?a+mod:a;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int ksm(int a,int b)&#123;int o;for(o=1;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)o=mul(o,a);return o;&#125;int n,l1,l2,len[26],fa[N],sum1,sum2,S,T,ans;bool mark[N];char s1[N],s2[N];vector&lt;int&gt;pos[26];int gf(int x)&#123;return fa[x]==x?x:fa[x]=gf(fa[x]);&#125;void Merge(int x,int y)&#123; x=gf(x);y=gf(y); if(x!=y)fa[x]=y;&#125;int main()&#123; freopen("B.in","r",stdin); freopen("B.out","w",stdout); int i,j,k,x,y;char c; scanf("%s",s1+1);l1=strlen(s1+1); scanf("%s",s2+1);l2=strlen(s2+1); assert(l1&lt;=1000000); assert(l2&lt;=1000000); scanf("%d",&amp;n); S=1000001;T=S+1; for(i=1;i&lt;=T;i++)fa[i]=i; for(i=1;i&lt;=n;i++)scanf("\n%c%d",&amp;c,&amp;k),len[c-'a']=k; for(i=1;i&lt;=l1;i++) &#123; if(s1[i]=='0')sum1++,Merge(sum1,S); else if(s1[i]=='1')sum1++,Merge(sum1,T); else pos[s1[i]-'a'].push_back(sum1),sum1+=len[s1[i]-'a']; &#125; for(i=1;i&lt;=l2;i++) &#123; if(s2[i]=='0')sum2++,Merge(sum2,S); else if(s2[i]=='1')sum2++,Merge(sum2,T); else pos[s2[i]-'a'].push_back(sum2),sum2+=len[s2[i]-'a']; &#125; for(i=0;i&lt;26;i++) for(j=1;j&lt;=len[i];j++) for(k=1;k&lt;pos[i].size();k++)Merge(pos[i][k-1]+j,pos[i][k]+j); int fx=gf(S),fy=gf(T); if(fx==fy||sum1!=sum2)return puts("0"),0; for(i=1;i&lt;=sum1;i++) &#123; x=gf(i);if(x==fx||x==fy)continue; if(!mark[x])mark[x]=1,ans++; &#125; printf("%d\n",ksm(2,ans));&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3743 奶牛求幂 （启发式搜索）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3743-%E5%A5%B6%E7%89%9B%E6%B1%82%E5%B9%82-%EF%BC%88%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3743奶牛求幂问题描述 约翰的奶牛想要快速计算出整数的P(1&lt;=P&lt;=20000)次幂。计算过程中它们只能使用两个存储器，每个存储器可以记录某个结果的值。它们的第一个工作是初始化存储器的值：一个存底数x,另一个初值为1。奶牛可以相乘或相除两个存储器中的值，并把结果存在其中某个存储器内，但存储器存的数字必须是整数。比如两个存储器存的数字分别是A和B，你可以做这些运算 AB，AA，B*B，A/B，B/A，A/A，B/B例如，如果它们想要计算x^31,一种计算方法是： 因此，x^31可以通过6次计算得出。给出要计算的幂次，请你帮奶牛求出最少需要几次计算 输入格式 一个整数P 输出格式 一个整数，表示最少计算次数 样例输入 1 31 样例输出 1 6 样例输入 2 1023 样例输出 2 11 其他都好说，用log2来估价，最重要的是要用gcd剪枝，如果当前搜索到(u,v)这个数对，那么如果n不能被gcd(u,v)整除，那么显然可以return了。证明是显然的。 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;int n,k;int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;bool DFS(int x,int u,int v)&#123; if(x&gt;k)return 0; if(u&gt;v)u^=v^=u^=v; if((v&lt;&lt;(k-x))&lt;n)return 0; if(n%gcd(u,v))return 0; if(u==v)return 0; if(v==n)return 1; int a=u+v,b=v-u,c=u+u,d=v+v; if(DFS(x+1,a,v))return 1; if(DFS(x+1,d,v))return 1; if(DFS(x+1,c,v))return 1; if(DFS(x+1,b,v))return 1; if(DFS(x+1,u,a))return 1; if(DFS(x+1,u,b))return 1; if(DFS(x+1,u,c))return 1; if(DFS(x+1,u,d))return 1; return 0;&#125;int main()&#123; scanf("%d",&amp;n); while(!DFS(0,0,1))k++; printf("%d",k);&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3423 (NOI 2015) 软件包管理器 （树链剖分+线段树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3423-NOI-2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3423【NOI2015 Day1】软件包管理器问题描述 Linux用户和OS X用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其他软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的是yum，以及OS X下可用的homebrew都是优秀的软件包管理器。 你决定设计你自己的软件包管理器。不可避免的，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包B以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m&gt;=2)个软件包A1,A2,A2依赖A3,…,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，Am-1依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。 输入格式 /从manager.in中读入数据。/ 输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。 随后一行包含n-1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,…,n-2,n-1号软件包依赖的软件包编号。 接下来一行包含1个整数q，表示询问的总数。 之后的q行，每行1个询问。询问分为两种： ●install x：表示安装软件包x ●uninstall x：表示卸载软件包x 你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态，对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式 /输出到文件manager.out中。/ 输出文件包括q行。 输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。 样例输入1： 70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0 样例输入2： 100 1 2 1 3 0 0 3 210install 0install 3uninstall 2install 7install 5install 9uninstall 9install 4install 1install 9样例输出 样例输出1： 31323 样例输出2： 1321311101 此题显然树链剖分，安装操作容易处理，卸载操作其实也很简单，因为剖分出来的ID在一棵子树上肯定是连续的一段，那么直接记下这棵子树的左右界就行了，然后就是线段树区间修改。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100005using namespace std;int n,dep[N],fa[N],son[N],top[N],id[N],Mid[N],VT;int TOT,LA[N],NE[N],EN[N];int ls[N*5],rs[N*5],v[N*5],w[N*5],lazy[N*5],tot;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int FHE(int x,int f)&#123; int i,y,t=0,s=1,tmp; fa[x]=f; dep[x]=dep[f]+1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f) &#123; tmp=FHE(y,x);s+=tmp; if(tmp&gt;t)t=tmp,son[x]=y; &#125; &#125; return s;&#125;void CHE(int x,int f)&#123; int i,y; id[x]=++VT; top[x]=f; if(son[x])CHE(son[x],f); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=fa[x]&amp;&amp;y!=son[x])CHE(y,y); &#125; Mid[x]=VT;&#125;int BT(int x,int y)&#123; int p=++tot; w[p]=y-x+1; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; return p;&#125;void PD(int p)&#123; if(lazy[p]==1) &#123; v[ls[p]]=w[ls[p]]; v[rs[p]]=w[rs[p]]; lazy[ls[p]]=1; lazy[rs[p]]=1; &#125; else &#123; v[ls[p]]=0; v[rs[p]]=0; lazy[ls[p]]=-1; lazy[rs[p]]=-1; &#125; lazy[p]=0;&#125;void MD(int p,int l,int r,int x,int y,int d)&#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;v[p]=w[p]*d;lazy[p]=d==1?1:-1;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)MD(ls[p],l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)MD(rs[p],mid+1,r,x,y,d); v[p]=v[ls[p]]+v[rs[p]];&#125;int GS(int p,int l,int r,int x,int y)&#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)return v[p]; int mid=l+r&gt;&gt;1,s=0; if(x&lt;=mid&amp;&amp;y&gt;=l)s+=GS(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)s+=GS(rs[p],mid+1,r,x,y); return s;&#125;void Ins(int x)&#123; int ans=dep[x],k=x; while(top[k]!=top[0]) &#123; ans-=GS(1,1,n,id[top[k]],id[k]); MD(1,1,n,id[top[k]],id[k],1); k=fa[top[k]]; &#125; ans-=GS(1,1,n,id[top[k]],id[k]); MD(1,1,n,id[top[k]],id[k],1); printf("%d\n",ans);&#125;int Uns(int x)&#123; int ans=GS(1,1,n,id[x],Mid[x]); printf("%d\n",ans); MD(1,1,n,id[x],Mid[x],0);&#125;int main_main()&#123; int i,x;char s[20]; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d",&amp;x); ADD(x,i); &#125; FHE(0,0);CHE(0,0);BT(1,n); scanf("%d",&amp;i); while(i--) &#123; scanf("%s%d",s,&amp;x); if(s[0]=='i')Ins(x); else Uns(x); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2251 网络管理（树链剖分+树套树（树状数组+主席树））]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2251-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%EF%BC%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E6%A0%91%E5%A5%97%E6%A0%91%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2251【动态树】网络管理问题描述 M公司是一个非常庞大的跨国公司，在许多国家都设有它的下属分支机构或部门。为了让分布在世界各地的N个部门之间协同工作，公司搭建了一个连接整个公司的通信网络。该网络的结构由N个路由器和N-1条高速光缆组成。每个部门都有一个专属的路由器，部门局域网内的所有机器都联向这个路由器，然后再通过这个通信子网与其他部门进行通信联络。该网络结构保证网络中的任意两个路由器之间都存在一条直接或间接路径以进行通信。 高速光缆的数据传输速度非常快，以至于利用光缆传输的延迟时间可以忽略。但是由于路由器老化，在这些路由器上进行数据交换会带来很大的延迟。而两个路由器之间的通信延迟时间则与这两个路由器通信路径上所有路由器中最大的交换延迟时间有关。 作为M公司网络部门的一名实习员工，现在要求你编写一个简单的程序来监视公司的网络状况。该程序能够随时更新网络状况的变化信息（路由器数据交换延迟时间的变化），并且根据询问给出两个路由器通信路径上延迟第k大的路由器的延迟时间。 【任务】 你的程序从输入文件中读入N个路由器和N-1条光缆的连接信息，每个路由器初始的数据交换延迟时间Ti，以及Q条询问（或状态改变）的信息。并依次处理这Q条询问信息，它们可能是： 1. 由于更新了设备，或者设备出现新的故障，使得某个路由器的数据交换延迟时间发生了变化。 2. 查询某两个路由器a和b之间的路径上延迟第k大的路由器的延迟时间。 输入格式 第一行为两个整数N和Q，分别表示路由器总数和询问的总数。第二行有N个整数，第i个数表示编号为i的路由器初始的数据延迟时间Ti。紧接着N-1行，每行包含两个整数x和y。表示有一条光缆连接路由器x和路由器y。紧接着是Q行，每行三个整数k、a、b。如果k=0，则表示路由器a的状态发生了变化，它的数据交换延迟时间由Ta变为b。如果k&gt;0，则表示询问a到b的路径上所经过的所有路由器（包括a和b）中延迟第k大的路由器的延迟时间。注意a可以等于b，此时路径上只有一个路由器。 输出格式 对于每一个第二种询问（k&gt;0），输出一行。包含一个整数为相应的延迟时间。如果路径上的路由器不足k个，则输出信息“invalid request!”（全部小写不包含引号，两个单词之间有一个空格）。 样例输入 5 55 1 2 3 43 12 14 35 32 4 50 1 22 2 32 1 43 3 5 样例输出 322invalid request! 提示 10% 测试数据满足N&lt;=8000,Q&lt;=300040% 测试数据满足所有询问中1&lt;=K&lt;=5 。即路由器的延迟时间不会发生变化。100% 测试数据满足N,Q&lt;=80000，任意一个路由器在任何时刻都满足延迟时间小于106。对于所有询问满足0&lt;=K&lt;=N 。 此题显然树链剖分，然后求区间第K大，用树套树维护，为了好写，当然选择树状数组+主席树，主要是处理不连续区间中的第K大的问题，考虑一下求动态区间第K大的做法，实际上可以将树状数组中会用到的值先提前存到数组中，然后直接采取与静态区间第K小一样的做法即可。具体不太好描述，可以参见代码领悟一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 200005#define M 20000005using namespace std;const int T=1e6;int n,q,Ti[N],Ai[N],VT,dep[N],son[N],fa[N],top[N],id[N];int tot,rt[N],ls[M],rs[M],v[M];int TOT,LA[N],NE[N],EN[N];int A[N],B[N],c1,c2;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int FHE(int x,int f)&#123; int i,y,t=0,s=1,tmp; fa[x]=f; dep[x]=dep[f]+1; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f) &#123; tmp=FHE(y,x);s+=tmp; if(s&gt;t)t=s,son[x]=y; &#125; &#125; return s;&#125;void CHE(int x,int f)&#123; int i,y; top[x]=f; id[x]=++VT; Ai[VT]=Ti[x]; if(son[x])CHE(son[x],f); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=fa[x]&amp;&amp;y!=son[x])CHE(y,y); &#125;&#125;int CO(int p)&#123; int o=++tot; ls[o]=ls[p]; rs[o]=rs[p]; v[o]=v[p]; return o;&#125;int ADD(int p,int l,int r,int k,int d)&#123; int o=CO(p);v[o]+=d; if(l==r)return o; int mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[p],l,mid,k,d); else rs[o]=ADD(rs[p],mid+1,r,k,d); return o;&#125;int GA(int p,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r)return v[p]; int mid=l+r&gt;&gt;1,s=0; if(x&lt;=mid&amp;&amp;y&gt;=l)s+=GA(ls[p],l,mid,x,y); if(x&lt;=r&amp;&amp;y&gt;mid)s+=GA(rs[p],mid+1,r,x,y); return s;&#125;void MD(int x,int k,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))rt[i]=ADD(rt[i],0,T,k,d);&#125;void GSA(int x)&#123;for(int i=x;i;i-=(i&amp;-i))A[++c1]=rt[i];&#125;void GSB(int x)&#123;for(int i=x;i;i-=(i&amp;-i))B[++c2]=rt[i];&#125;int Gcnt(int x,int y)&#123; int ans=0;c1=c2=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); ans+=dep[x]-dep[top[x]]+1; GSA(id[x]);GSB(id[top[x]]-1); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); ans+=dep[y]-dep[x]+1; GSA(id[y]);GSB(id[x]-1); return ans;&#125;int Work(int k,int l,int r)&#123; if(l==r)return l; int i,sum=0,mid=l+r&gt;&gt;1;//sum为右儿子代表的权值区间的cnt for(i=1;i&lt;=c1;i++)sum+=v[rs[A[i]]]; for(i=1;i&lt;=c2;i++)sum-=v[rs[B[i]]]; if(sum&gt;=k)//全部走到右儿子 &#123; for(i=1;i&lt;=c1;i++)A[i]=rs[A[i]]; for(i=1;i&lt;=c2;i++)B[i]=rs[B[i]]; return Work(k,mid+1,r); &#125; else//全部走到左儿子 &#123; for(i=1;i&lt;=c1;i++)A[i]=ls[A[i]]; for(i=1;i&lt;=c2;i++)B[i]=ls[B[i]]; return Work(k-sum,l,mid); &#125;&#125;void Solve(int k,int x,int y)&#123; if(Gcnt(x,y)&lt;k)&#123;printf("invalid request!\n");return;&#125; printf("%d\n",Work(k,0,T));&#125;int main_main()&#123; int i,x,y,k; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%d",&amp;Ti[i]); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; FHE(1,0);CHE(1,1); for(i=1;i&lt;=n;i++)MD(i,Ai[i],1); while(q--) &#123; scanf("%d%d%d",&amp;k,&amp;x,&amp;y); if(k==0) &#123; x=id[x]; MD(x,Ai[x],-1); Ai[x]=y; MD(x,Ai[x],1); &#125; else Solve(k,x,y); &#125;&#125;const int main_stack=16;char my_stack[256&lt;&lt;20];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>主席树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2017 游记]]></title>
    <url>%2F2018%2F03%2F15%2FNOIP-2017-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[D1 早上晕车，迷迷糊糊的。T1结论题，还好THH大佬曾经教我证明过，膜一发，直接输出a*b-a-b，一分钟完事。 T2恶心题，事后听说是普及组T4，真是恶心了两组人，直接用栈模拟，记录一下每个元素入栈的复杂度，注意判语法错误，空栈和栈不为空。晕乎乎的调了一个小时才完事。 T3水题，直接跑最短路+判零环+DP即可。搞个A*搜索对拍。结果没有拍无解情况，下来发现判无解的事后没有加K，GG D1过于简单预示着什么？ D2 一种不详的预感。T1显然的暴力，不说了。十分钟搞完。 T2本来想DP，但搞不来深度，直接上了爆搜+一个怎么看都是对的的剪枝，跑得飞快。对拍走起。结果10分钟后跑出错，怒调无果。GG。这题状压并不难搞，然而总是想着今年肯定要考爆搜，而且密码又是什么人工智能，觉得稳得不行。 T3动态开点线段树裸题，只需要记录每一行1-m-1位置是否可用，每次更改的人直接加在后面，用vector记编号，单独维护最后一列就完了。然而考场上一直在考虑区间修改上树套树并成功被空间卡死，没仔细想又去调T2了.结果暴力都没敲好. 什么规律都是不存在的，不能被往年规律套路 D1还行，迷迷糊糊还能打，D2掉入奇数年与偶数年巨坑中，失智。今年考题还是简单，我毕竟还是naive，总是想着爆搜，并膜拜出题人的爆搜。 今年NOIP的过于简单与数据的过于水，或将成为省选竞争最激烈的一年。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3847 马云 （贪心）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3847-%E9%A9%AC%E4%BA%91-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3847马云问题描述 Mr_he 因讨厌马云而彻底放弃网购，他的日常用品都要到商场去购买，而且必须付现金。但是现 金购买，经常会遇到找零的问题，那么现在请你帮助他解决这样一个问题： 现在 Mr_he 手上有 n 种不同面值的硬币，每种硬币有无限多个。为了方便购物，他希望带尽量 少的硬币，但是要能组合出 1 到 m 之间的任意值。 输入格式 第一行为两个整数：m 和 n，他们的意义如题目描述。接下来的 n 行，每行一个整数，第 i+1 行的整数表示第 i 种硬币的面值 输出格式 最少需要携带的硬币数量，如果无解则输出-1。 样例输入 20 412510 样例输出 5 数据范围 50%的数据：1&lt;=n&lt;=10， 1&lt;=m&lt;=10^3；100%的数据：1&lt;=n&lt;=100，1&lt;=m&lt;=10^9； 此题看上去像背包，然而范围太大，没有什么好方法可以处理。 没什么好方法的时候就应该考虑贪心。 考虑$1-i$已经构出，那么再加一枚什么面值的硬币最优，显然选一枚$&lt;=sum+1$且面值最大的即可。面值最大保证了硬币数最小。$sum$表示硬币面值和。 事实上，这个贪心可以从$F[i]=F[i-A[k]]+1$看出。$F[i]$必然是单调增的，因此贪心即可。$F[i]表示处理完1-i的最少硬币数$ 代码： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,m,A[105],sum,cnt;int main()&#123; int i,j,k; scanf("%d%d",&amp;m,&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); sort(A+1,A+n+1); if(A[1]!=1)&#123;printf("-1");return 0;&#125; sum=1; while(sum&lt;m) &#123; for(i=1;i&lt;=n;i++)if(A[i]&gt;sum+1)break; sum+=A[i-1];cnt++; &#125; printf("%d",cnt+1);&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3489 避难向导（LCA+倍增+DFS/DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3489-%E9%81%BF%E9%9A%BE%E5%90%91%E5%AF%BC%EF%BC%88LCA-%E5%80%8D%E5%A2%9E-DFS-DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3489【2015多校联训5】避难向导问题描述 “特大新闻，特大新闻！全国爆发了一种极其可怕的病毒，已经开始在各个城市中传播开来！全国陷入了巨大的危机！大量居民陷入恐慌，想要逃到其它城市以避难！经调查显示，该病毒来自于C 市的A 学校的一次非法的……”“哎。”你关上电视，叹了口气。作为A 学校的校长，你一天前为了保命，独自逃离了A 学校，抛弃了全校师生，包括那个曾经帮你计算并拆除道路的工程师。你良心受到了巨大的谴责，因此决定做出一些补救，回答一些逃难的人提出的询问。已知该国一共有n 个城市，并且1 号城市是首都。(n-1)条双向的公路连接这些城市，通过这些公路，任意两个城市之间存在且仅存在一条路径。每条公路有一个长度。如果一个城市只与一条公路相连，则称它为边境城市。该国政府有一个奇怪的规定：每个城市有一个封闭系数di，定义di 为离这个城市最远的边境城市到这个城市的距离。市民们认为，一个城市的安全系数Si 和它的封闭系数有很重要的联系。a，b，c 是该国的幸运数字，所以大家公认一个城市的安全系数Si = (di + a) * b mod c。市民们一共会提出m 次询问。每个询问包含三个信息，xi，yi 和qi。xi 是询问者所在的城市编号。你要为这个询问者在xi 到yi 的必经之路上找出一个离xi最近的避难城市，并且要求这个避难城市的安全系数大于等于qi。如果存在这样的城市（包含xi 和yi），则输出城市编号，否则输出一行包括一个数-1。 输入格式 第一行五个数：依次是n, m, a, b, c。接下来n-1 行描述公路的信息。每行三个数，前两个数代表这条公路连接的两个城市的编号，第三个数表示这条公路的长度。再接下来m 行，每行描述一个询问，包含三个数xi, yi 和qi。 输出格式 对于每个询问，输出一行包含一个整数，存在符合要求的城市则输出城市编号，不存在则输出-1。 样例输入 7 6 5 6 201 2 42 4 22 5 31 3 53 6 66 7 77 5 153 4 55 4 24 5 26 6 103 5 19 样例输出 63246-1 数据范围 对于100%数据, 0 &lt; xi, yi&lt;=n; a,b,c,qi&lt;=1,000,000;注意：计算安全系数的中间过程可能需要使用64 位整数。 首先求安全系数，那么显然是找一条直径，然后到直径的某一个端点一定是最远距离，然而我居然写了个恶心的树dp 然后询问一条路径上，离起点最近的且安全系数大于$qi$的点，那么暴力枚举，$n^2$，显然不行，需要优化。 考虑倍增，$Maxdis[i][k]$表示$i$号节点的父亲开始往上$2^k$个节点中，最大的安全系数，显然很好预处理。 查找时先找出$x$和$y$的$lca$，先考虑$x$到$lca$这一段路径上的点。 此时直接倍增处理，从大到小枚举$k$，由于找与$x$最接近的，那么如果$Maxdis[x][k]&lt;qi$，$x=father[x][k]$，否则缩小$k$，注意端点很容易找到答案。 然后考虑$x$到$lca$没找到时，查找$lca$到$y$，此时需要找与$y$最远的一个点，上面的方法就行不通了。 此时可以暴力一点，每次枚举到$k$时，如果$Maxdis[x][k]&gt;=qi$那么先递归查询$father[x][k-1]$到$father[x][k]$这一段区间，如果找到了就直接返回，否则再查找$x$到$father[x][k-1]$，如果$Maxdis[x][k]&lt;qi$，那么直接缩小$k$，时间复杂度比较玄学，出题人说是$O(nlogn)$的，那就这样吧。还有另外一种处理方法，只需要二分答案枚举一下答案点的位置，然后验证是否找得到就行了。复杂度$O(nlog^2n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 100005#define M 200005using namespace std;ll n,m,S=20,cnt;ll TOT,LA[N],NE[M],EN[M],LE[M];ll V[N],Fdis[N],Mdis[N],MSdis[N],dis[N][22],a,b,c;ll F[N][22],dep[N],MS[N];void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;ll DFS1(ll x,ll f)&#123; ll maxdis=0,id=0,i,y,tmp; F[x][0]=f; dep[x]=dep[f]+1; for(i=1;i&lt;=S;i++)F[x][i]=F[F[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f) &#123; tmp=DFS1(y,x)+LE[i]; if(tmp&gt;maxdis) &#123; Mdis[x]=max(Mdis[x],maxdis); maxdis=tmp;id=y; &#125; else Mdis[x]=max(Mdis[x],tmp); &#125; &#125; MSdis[x]=maxdis;MS[x]=id; return maxdis;&#125;void DFS2(ll x,ll f,ll d)&#123; ll i,y; Fdis[x]=max(Fdis[f]+d,Fdis[x]); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f) &#123; if(y!=MS[x])Fdis[y]=max(Fdis[y],MSdis[x]+LE[i]); else Fdis[y]=max(Fdis[y],Mdis[x]+LE[i]); &#125; &#125; for(i=LA[x];i;i=NE[i])if(EN[i]!=f)DFS2(EN[i],x,LE[i]); V[x]=max(Fdis[x],MSdis[x]);V[x]=(a+V[x])*b%c;&#125;void DFS3(ll x,ll f)&#123; ll i,y; dis[x][0]=V[f]; for(i=1;i&lt;=S;i++)dis[x][i]=max(dis[x][i-1],dis[F[x][i-1]][i-1]); for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)DFS3(y,x); &#125;&#125;ll LCA(ll x,ll y)&#123; ll i,t; if(dep[x]&lt;dep[y])x^=y^=x^=y; t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&amp;(1&lt;&lt;i))x=F[x][i]; if(x==y)return x; for(i=S;i&gt;=0;i--) if(F[x][i]!=F[y][i])x=F[x][i],y=F[y][i]; return F[x][0];&#125;ll Find1(ll x,ll y,ll p)&#123; if(V[x]&gt;=p)return x; for(ll i=S;i&gt;=0;i--) &#123; if(dis[x][i]&lt;p)x=F[x][i]; if(dep[x]&lt;dep[y])return -1; &#125; if(dep[F[x][0]]&lt;dep[y])return -1; if(V[F[x][0]]&gt;=p)return F[x][0]; return -1;&#125;ll Find2(ll x,ll y,ll t,ll p)&#123; if(x==y)return V[x]&gt;=p?x:-1; while(t&gt;=0&amp;&amp;dep[F[x][t]]&lt;=dep[y])t--; if(t&lt;0) &#123; ll k=F[x][0]; if(V[k]&gt;=p)return k; if(V[x]&gt;=p)return x; return -1; &#125; if(dis[F[x][t]][t]&gt;=p) &#123; ll k=Find2(F[x][t],y,t,p); if(k!=-1)return k; &#125; if(dis[x][t]&gt;=p)return Find2(x,F[x][t],t,p); if(V[x]&gt;=p)return x; return -1;&#125;int main_main()&#123; ll i,j,k,x,y,z,ans; scanf("%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(i=1;i&lt;n;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; DFS1(1,0);DFS2(1,0,0);DFS3(1,0); for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); k=LCA(x,y);cnt=0; if(k==y)ans=Find1(x,k,z); else if(k==x)ans=Find2(y,k,S,z); else &#123; ans=Find1(x,k,z); if(ans==-1)ans=Find2(y,k,S,z); &#125; printf("%lld\n",ans); &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>图论</category>
        <category>分治法</category>
        <category>LCA</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3500 独立集（dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3500-%E7%8B%AC%E7%AB%8B%E9%9B%86%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3500【2015多校联训6】独立集问题描述 输入格式 输入包含两行，第一行为 N，第二行为 1 到 N 的一个全排列 输出格式 输出包含两行，第一行输出最大独立集的大小，第二行从小到大输出一定在最大独立集 的点的编号。 样例输入 33 1 2 样例输出 22 3 提示 30%的数据满足 N&lt;=1660%的数据满足 N&lt;=1,000100%的数据满足 N&lt;=100,000 仔细观察，发现第一问就是最长上升子序列，因为逆序对才会连边，那么没有边相连的点一定是正序的，那么问题就是求最长正序，即最长上升子序列。 考虑第二问，优秀的做法做不来，搞个暴力。假设以$i$为结尾的最长上升子序列长度为$k$，那么将$A[i]$加到一个$set$，$P$中，将$i$加到另一个$set$,$Q$中，那么跑完最长上升子序列后，令第一问答案为$len$ 从$len$开始倒着讨论，用$P[k],Q[k]$中最大的元素去删除$P[k-1],Q[k-1]$中的元素，删除条件就是如果$P[k-1],Q[k-1]$中的一个元素不能转移到$P[k],Q[k]$中的任一元素，那么删除。 如果讨论时发现某$set$中仅有一个元素，那么这个元素一定要选。复杂度$nlogn$ 优秀做法参见THH 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#define N 100055using namespace std;set&lt;int&gt;Q[N],R[N];int n,A[N],F[N],B[N],id[N],ans;bool mark[N];int main()&#123; set&lt;int&gt;::iterator x,y,z; int i,j,k; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),id[A[i]]=i; memset(B,60,sizeof(B));B[0]=0;Q[0].insert(0); for(i=1;i&lt;=n;i++) &#123; F[i]=lower_bound(B+1,B+n+1,A[i])-B; B[F[i]]=A[i]; Q[F[i]].insert(A[i]); R[F[i]].insert(i); ans=max(ans,F[i]); &#125; for(i=ans;i&gt;=1;i--) &#123; if(Q[i].size()==1) &#123; x=Q[i].begin(); mark[*x]=1; &#125; x=Q[i].end();x--; y=Q[i-1].lower_bound(*x); for(z=y;z!=Q[i-1].end();z++)R[i-1].erase(R[i-1].find(id[*z])); Q[i-1].erase(y,Q[i-1].end()); x=R[i].end();x--; y=R[i-1].lower_bound(*x); for(z=y;z!=R[i-1].end();z++)Q[i-1].erase(Q[i-1].find(A[*z])); R[i-1].erase(y,R[i-1].end()); &#125; printf("%d\n",ans); for(i=1;i&lt;=n;i++)if(mark[i])printf("%d ",id[i]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI 2015 荷马史诗 （哈夫曼树）]]></title>
    <url>%2F2018%2F03%2F15%2FNOI-2015-%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97-%EF%BC%88%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【NOI2015 Day2】荷马史诗问题描述 追逐影子的人，自己就是影子。 ——荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 n 种不同的单词，从 1 到 n 进行编号。其中第 i 种单词出现的总次数为 wi。Allison 想要用 k 进制串 si 来替换第 i 种单词，使得其满足如下要求: 对于任意的 1≤i,j≤n，i≠j，都有：si 不是 sj 的前缀。 现在 Allison 想要知道，如何选择 si，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 si 的最短长度是多少？ 一个字符串被称为 k 进制字符串，当且仅当它的每个字符是 0 到 k−1 之间（包括 0 和 k−1）的整数。 字符串 Str1 被称为字符串 Str2 的前缀，当且仅当：存在 1≤t≤m，使得 Str1=Str2[1..t]。其中，m 是字符串 Str2 的长度，Str2[1..t] 表示 Str2 的前 t 个字符组成的字符串。 输入格式 输入文件的第 1 行包含 2 个正整数 n,k，中间用单个空格隔开，表示共有 n 种单词，需要使用 k 进制字符串进行替换。接下来 n 行，第 i+1 行包含 1 个非负整数 wi，表示第 i 种单词的出现次数。 输出格式 输出文件包括 2 行。第 1 行输出 1 个整数，为《荷马史诗》经过重新编码以后的最短长度。第 2 行输出 1 个整数，为保证最短总长度的情况下，最长字符串 si 的最短长度。 样例输入1： 4 21122 样例输入2： 6 3113399 样例输出1： 122 样例输出2： 363 此题的解是多叉哈夫曼树，哈夫曼树是用于解决最短编码的一种编码方法。 首先，将每种字符视为点，出现次数视为点权，那么每次选取权最小的k个点合成一个新点，新点点权等于各点点权和，如此最后只剩一个点时，就构好了k叉哈夫曼树，至于具体的编码，举个例子说明即可。如上图的二叉哈夫曼树，那么a的编码为00，b的编码为01，c的编码为1 至于最长编码的最短长度，实际上就是要求哈夫曼树的深度尽量小，那么只需要每次选权值最小且深度深度尽量小的子树合并即可。 具体实现时，可以将点分成已合并的点和未合并的点，维护两个队列的单调性，每次取队首即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 10000005#define int long longusing namespace std;struct node&#123;int v,sum,x,dep;&#125;A[N],B[N];bool operator&lt;(node a,node b)&#123; if(a.v==b.v)return a.dep&lt;b.dep; return a.v&lt;b.v;&#125;int n,k,l1=1,r1,l2=1,r2;main()&#123; int i,j;node tmp; scanf("%lld%lld",&amp;n,&amp;k); for(i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;A[++r1].v); A[r1].x=A[r1].v; &#125; if((n-1)%(k-1))r1+=k-1-(n-1)%(k-1); sort(A+l1,A+r1+1); while(r1-l1+r2-l2+2&gt;1) &#123; i=0;tmp.sum=tmp.v=tmp.x=tmp.dep=0; while(i&lt;k) &#123; if(l1&gt;r1) &#123; tmp.v+=B[l2].v; tmp.sum+=B[l2].sum+B[l2].x; tmp.x+=B[l2].x; tmp.dep=max(tmp.dep,B[l2].dep+1); l2++; &#125; else if(l2&gt;r2) &#123; tmp.v+=A[l1].v; tmp.sum+=A[l1].sum+A[l1].x; tmp.x+=A[l1].x; tmp.dep=max(tmp.dep,A[l1].dep+1); l1++; &#125; else if(A[l1]&lt;B[l2]) &#123; tmp.v+=A[l1].v; tmp.sum+=A[l1].sum+A[l1].x; tmp.x+=A[l1].x; tmp.dep=max(tmp.dep,A[l1].dep+1); l1++; &#125; else &#123; tmp.v+=B[l2].v; tmp.sum+=B[l2].sum+B[l2].x; tmp.x+=B[l2].x; tmp.dep=max(tmp.dep,B[l2].dep+1); l2++; &#125; i++; &#125; B[++r2]=tmp; &#125; printf("%lld\n%lld",B[l2].sum,B[l2].dep);&#125;]]></content>
      <categories>
        <category>杂学</category>
        <category>哈夫曼树</category>
      </categories>
      <tags>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 4.1.3 篱笆回路 （floyd找最小环）]]></title>
    <url>%2F2018%2F03%2F15%2FUSACO-4-1-3-%E7%AF%B1%E7%AC%86%E5%9B%9E%E8%B7%AF-%EF%BC%88floyd%E6%89%BE%E6%9C%80%E5%B0%8F%E7%8E%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【USACO4.1.3】Fence Loops篱笆回路问题描述 农夫布朗的牧场上的篱笆已经失去控制了。它们分成了1~200英尺长的线段。只有在线段的端点处才能连接两个线段，有时给定的一个端点上会有两个以上的篱笆。结果篱笆形成了一张网分割了布朗的牧场。布朗想将牧场恢复原样，出于这个考虑，他首先得知道牧场上哪一块区域的周长最小。布朗将他的每段篱笆从1到N进行了标号（N=线段的总数）。他知道每段篱笆有如下属性： 该段篱笆的长度该段篱笆的一端所连接的另一段篱笆的标号该段篱笆的另一端所连接的另一段篱笆的标号 幸运的是，没有篱笆连接它自身。对于一组有关篱笆如何分割牧场的数据，写一个程序来计算出所有分割出的区域中最小的周长。 例如，标号1~10的篱笆由下图的形式组成（下面的数字是篱笆的标号）： 上图中周长最小的区域是由2，7，8号篱笆形成的。 输入格式 第1行: N (1 &lt;= N &lt;= 100) 第2行到第3*N+1行: 每三行为一组，共N组信息: 每组信息的第1行有4个整数: s, 这段篱笆的标号(1 &lt;= s &lt;= N); Ls, 这段篱笆的长度 (1 &lt;= Ls &lt;= 255); N1s (1 &lt;= N1s &lt;= 8) 与本段篱笆的一端所相邻的篱笆的数量; N2s与本段篱笆的另一端所相邻的篱笆的数量。 (1 &lt;= N2s &lt;= 8). 每组信息的的第2行有 N1s个整数, 分别描述与本段篱笆的一端所相邻的篱笆的标号。 每组信息的的第3行有N2s个整数, 分别描述与本段篱笆的另一端所相邻的篱笆的标号。 输出格式 输出的内容为单独的一行，用一个整数来表示最小的周长。 样例输入 101 16 2 22 710 62 3 2 21 78 33 3 2 18 244 8 1 339 10 55 8 3 19 10 466 6 1 251 107 5 2 21 28 98 4 2 22 37 99 5 2 37 84 5 1010 10 2 31 64 9 5 样例输出 12 此题是floyd求最小环的裸题。考虑存在一个环$i-&gt;k-&gt;j-&gt;i$那么$j-&gt;i$的路径必须不经过k，而floyd正好可以保证，因为外层循环枚举k，那么当前算出的最短路一定只经过$[1,k-1]$，因此用$G[i][k]+G[k][j]+dis[i][j]$更新答案即可，$G$中存的原图，而$dis$是floyd算出的最短路。 由于最小环上的每一个点都会被枚举作为中转，那么一定能求出最小环。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define N 205using namespace std;int n,L[N],R[N],LE[N],G[N][N],dis[N][N],tot;struct node&#123; int a[105]; void CL()&#123;for(int i=1;i&lt;=n;i++)a[i]=0;&#125;&#125;;bool operator&lt;(node aa,node bb)&#123; int i; for(i=1;i&lt;=n;i++)if(aa.a[i]!=bb.a[i])break; return aa.a[i]&lt;bb.a[i];&#125;map&lt;node,int&gt;Q;int main()&#123; int i,j,k,s,x,y,z,ans=1e9; node tmp; scanf("%d",&amp;n); memset(G,10,sizeof(G)); memset(dis,10,sizeof(dis)); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d%d%d",&amp;s,&amp;z,&amp;x,&amp;y); tmp.CL();tmp.a[s]++; for(j=1;j&lt;=x;j++) &#123; scanf("%d",&amp;k); tmp.a[k]++; &#125; if(!Q.count(tmp))Q[tmp]=++tot,L[s]=tot; else L[s]=Q[tmp]; tmp.CL();tmp.a[s]++; for(j=1;j&lt;=y;j++) &#123; scanf("%d",&amp;k); tmp.a[k]++; &#125; if(!Q.count(tmp))Q[tmp]=++tot,R[s]=tot; else R[s]=Q[tmp]; G[L[s]][R[s]]=G[R[s]][L[s]]=z; dis[L[s]][R[s]]=dis[R[s]][L[s]]=z; &#125; for(k=1;k&lt;=tot;k++) &#123; for(i=1;i&lt;k;i++) for(j=i+1;j&lt;k;j++)ans=min(ans,dis[i][j]+G[i][k]+G[k][j]); for(i=1;i&lt;=tot;i++) for(j=1;j&lt;=tot;j++)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; printf("%d",ans);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最小环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过路费 （最短路）]]></title>
    <url>%2F2018%2F03%2F15%2F%E8%BF%87%E8%B7%AF%E8%B4%B9-%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[过路费问题描述 有一天你来到了一个奇怪的国家，它有 N 个城市，城市之间有若干条双向道路连接，每条道路都有一定的费用，经过城市也要一定的费用。从一个城市到达另一个城市的总花费为路径上费用最大的城市费用（包括起点和终点）加上路径上所有的道路的费用。给出 Q 次询问，分别回答每次询问中两城市间的最少花费。保证城市之间可以互达。 输入格式 第一行两个整数 N，M，表示有 N 个城市 M 条道路。接下来 N 行每行一个整数，表示城市的费用 ci。接下来 M 行每行三个整数，x，y，z，表示城市 x 和城市 y 间有一条费用为 z 的道路。接下来一行一个整数 Q，表示询问次数。接下来 Q 行每行两个整数 x，y（x 不等于 y），表示询问从城市 x 到城市 y 的最小花费。 输出格式 共 Q 行每行一个整数，第 i 行的整数表示第 i 次询问的答案。 样例输入 3 31321 2 12 3 11 3 321 31 3 样例输出 55 数据规模 对于 30%的数据，N&lt;=10，M&lt;=20，Q&lt;=5。对于 60%的数据，N&lt;=200，M&lt;=4000，Q&lt;=100。对于 100%的数据，N&lt;=300，M&lt;=40000，Q&lt;=100000，1&lt;=ci&lt;=100000，1&lt;=z&lt;=1000。 鉴于n这么小，当然要枚举最大点权。 做法一：改进floyd注意到floyd算法的三层循环，那么假设外层为$k$，内层为$i,j$，那么此时经过的点必定属于${1,2,3,…,k} \bigcup {i，j}$中，那么如果将点权排序，则当前算出的最短路中最大点权一定是$i,j,k$中的一个。 由此只需要在floyd中加入一个$ans[i][j]$表示所求答案，得到转移$ans[i][j]=min{ans[i][j],map[i][k]+map[k][j]+max(c[i],c[j],c[k])}$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 305using namespace std;struct node&#123;int x,y;&#125;B[N];bool cmp(node a,node b)&#123;return a.x&lt;b.x;&#125;int n,m,q,C[N],id[N],map[N][N],ans[N][N];int main()&#123; int i,j,k,x,y,z; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;C[i]); B[i].x=C[i]; B[i].y=i; &#125; sort(B+1,B+n+1,cmp); for(i=1;i&lt;=n;i++)id[B[i].y]=i; memset(ans,10,sizeof(ans)); memset(map,10,sizeof(map)); for(i=1;i&lt;=n;i++)map[i][i]=0; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); x=id[x];y=id[y]; map[x][y]=map[y][x]=min(z,map[x][y]); &#125; for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) &#123; map[i][j]=min(map[i][j],map[i][k]+map[k][j]); ans[i][j]=min(ans[i][j],map[i][j]+max(B[i].x,max(B[j].x,B[k].x))); &#125; scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x=id[x];y=id[y]; printf(&quot;%d\n&quot;,ans[x][y]); &#125;&#125; 做法二：一般最短路算法 既然要枚举最大点权，那么大于枚举的点权的点不走即可，那么从枚举的点出发跑单源最短路，然后同样用$ans[i][j]=min{ans[i][j],map[i][s]+map[s][j]+c[s]}$转移即可。 由于两点之间的最短路上每一个点都会被讨论到，所以正确性是显然的。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 305#define M 100005using namespace std;int n,m,C[N],ans[N][N];int TOT,LA[N],NE[M],EN[M],LE[M];int dis[N];bool mark[N];queue&lt;int&gt;Q;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void SPFA(int s)&#123; int i,j,x,y; memset(dis,60,sizeof(dis)); dis[s]=0;mark[s]=1;Q.push(s); while(Q.size()) &#123; x=Q.front(); Q.pop(); mark[x]=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(C[y]&gt;C[s])continue; if(dis[y]&gt;dis[x]+LE[i]) &#123; dis[y]=dis[x]+LE[i]; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)ans[i][j]=min(ans[i][j],dis[i]+dis[j]+C[s]);&#125;int main()&#123; int i,j,k,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;C[i]); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; memset(ans,60,sizeof(ans)); for(i=1;i&lt;=n;i++)SPFA(i); scanf("%d",&amp;k); while(k--) &#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",ans[x][y]); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1103 大都市（DFS序+树状数组+差分数组/树链剖分）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-1103-%E5%A4%A7%E9%83%BD%E5%B8%82%EF%BC%88DFS%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[大都市问题描述 在经济全球化浪潮的影响下,习惯于漫步在清晨的乡间小路的邮递员Blue Mary也开始骑着摩托车传递邮件了。 不过，她经常回忆起以前在乡间漫步的情景。昔日，乡下有依次编号为1..n的n个小村庄，某些村庄之间有一些双向的土路。从每个村庄都恰好有一条路径到达村庄1（即比特堡）。并且，对于每个村庄，它到比特堡的路径恰好只经过编号比它的编号小的村庄。 另外，对于所有道路而言，它们都不在除村庄以外的其他地点相遇。在这个未开化的地方，从来没有过高架桥和地下铁道。随着时间的推移，越来越多的土路被改造成了公路。至今，Blue Mary还清晰地记得最后一条土路被改造为公路的情景。现在，这里已经没有土路了——所有的路都成为了公路，而昔日的村庄已经变成了一个大都市。 Blue Mary想起了在改造期间她送信的经历。她从比特堡出发，需要去某个村庄，并且在两次送信经历的间隔期间,有某些土路被改造成了公路. 现在Blue Mary需要你的帮助：计算出每次送信她需要走过的土路数目。（对于公路，她可以骑摩托车；而对于土路，她就只好推车了。） 输入格式 第一行是一个数n(1 &lt; = n &lt; = 2 50000).以下n-1行，每行两个整数a，b（1 &lt; =a &lt; b&lt;=n) 以下一行包含一个整数m（1 &lt; = m &lt; = 2 50000），表示Blue Mary曾经在改造期间送过m次信。以下n+m-1行，每行有两种格式的若干信息，表示按时间先后发生过的n+m-1次事件:若这行为 A a b，表示道路a b被改成了公路。若这行为 W a, 则表示Blue Mary曾经从比特堡送信到村庄a。 输出格式 有m行，每行包含一个整数，表示对应的某次送信时经过的土路数目。 样例输入 51 21 31 44 54W 5A 1 4W 5A 4 5W 5W 2A 1 2A 1 3 样例输出 2101 此题用树链剖分就是模板题了，但是效率当然不如下面的做法高。 将每一条边记录到儿子上，土路的点权为0，公路为1，那么询问就是从根到某点经过的点权为0的点数，显然等于点数-点权为1的点数，即点数-点权和。 考虑dfs序，那么当一条路被改成公路时，他所有子节点的答案都减了1，那么由于dfs序是连续的区间，相当于这一段区间的点权都加了1，那么用差分数组维护即可，考虑到询问次数多，用树状数组维护差分数组。查询就是对应DFS序的进入时间在差分数组中的前缀和。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#define N 250005#define M 500005using namespace std;int n,m,C[N];int TOT,LA[N],NE[M],EN[M];int L[N],R[N],dep[N],VT;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int f)&#123; L[x]=++VT; dep[x]=dep[f]+1; for(int i=LA[x];i;i=NE[i]) if(EN[i]!=f)DFS(EN[i],x); R[x]=VT;&#125;void MD(int x,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))C[i]+=d;&#125;int GS(int x)&#123; int i,sum=0; for(i=x;i&gt;0;i-=(i&amp;-i))sum+=C[i]; return sum;&#125;int main_main()&#123; int i,j,x,y; char c; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; DFS(1,0); scanf("%d",&amp;m); for(i=1;i&lt;=n+m-1;i++) &#123; scanf("\n%c",&amp;c); if(c=='A') &#123; scanf("%d%d",&amp;x,&amp;y); if(dep[x]&lt;dep[y])x^=y^=x^=y; MD(L[x],1);MD(R[x]+1,-1); &#125; else &#123; scanf("%d",&amp;x); printf("%d\n",dep[x]-1-GS(L[x])); &#125; &#125;&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
        <category>杂学</category>
        <category>树链剖分</category>
        <category>差分数组</category>
        <category>DFS序</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>树状数组</tag>
        <tag>差分</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2144 跳跳棋（LCA+欧几里德+二分答案）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-2144-%E8%B7%B3%E8%B7%B3%E6%A3%8B%EF%BC%88LCA-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跳跳棋问题描述 跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋来做一个简单的游戏：棋盘上有3颗棋子，分别在a，b，c这三个位置。我们要通过最少的跳动把他们的位置移动成x，y，z。（棋子是没有区别的）跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过1颗棋子。写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。 输入格式 第一行包含三个整数，表示当前棋子的位置a b c。（互不相同）第二行包含三个整数，表示目标位置x y z。（互不相同） 输出格式 如果无解，输出一行NO。如果可以到达，第一行输出YES，第二行输出最少步数。 样例输入 1 2 30 3 5 样例输出 YES2 提示 20% 输入整数的绝对值均不超过1040% 输入整数的绝对值均不超过10000100% 绝对值不超过10^9 用一个三元数对$(a,b,c)$表示当前棋子的位置，并且规定$a&lt;b&lt;c$，观察棋子位置的改变， 如果$b-a&lt;c-b$，那么可以转移到 $(b,2b-a,c)$反之，可以转移到 $(a,2b-c,b)$此外，还可以转移到$(2a-b,a,c)$和$(a,c,2c-b)$ 看起来很乱，但是注意到，$b$向两边跳与两边向$b$跳是互逆过程，因此我们不妨只考虑一个过程，考虑两边向中间跳的过程，那么每一个状态可以转移到的状态是唯一的，画个图就是那么不难看出，从上往下走就是从中间往两边跳，从下往上走就是从两边往中间跳，于是，如果将每个状态看成一个节点，那么所有状态将会构成森林（注意不是树） 那么此题的解法也就比较明显了，即如果询问的两个节点不在一颗树中，那么无解，如果在一颗树中，最少跳动步数就是树上的距离。 那么接下来有两个问题，找根，和找lca 首先考虑找根，找根就是一个向上跳的过程，直到不能再向上跳，即$b-a=c-b$ 那么不妨考虑一个节点$(x,y,z)$，令$a=y-x,b=z-y$那么当$a&lt;b$时，每次$x$跳到$y$，$z$中间，直到$a&gt;b$，那么每次跳使$b$减少了$a$，不妨设跳了k次，那么有$k=(b-1)\div a$，注意不能是$b\div a$，因为$a=b$时不能跳，此时转移到了$(x+ka,y+ka,z)$因此只需要模拟欧几里德算法的过程，直到$a=b$即可。 然后考虑找lca，找lca也是向上跳的过程，直到两个节点跳到同一个位置，注意到找根时可以算出深度，因此先将两个节点调整到同一深度，然后再二分跳的步数，如果跳到了同一个点，那么步数减小，反之步数增大，即可找到lca至于向上跳，只需要在找根的向上跳的方法中加入一个步数限制即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;struct node&#123; ll x,y,z; void SO() &#123; if(x&gt;y)swap(x,y); if(x&gt;z)swap(x,z); if(y&gt;z)swap(y,z); &#125;&#125;;bool operator==(node a,node b)&#123;return a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.z==b.z;&#125;ll step,ans;node A,B,C,D;node GO(node p,ll cnt)&#123; ll k; for(step=0;cnt;step+=k) &#123; ll a=p.y-p.x,b=p.z-p.y; if(a==b)return p; if(a&lt;b) &#123; k=min((b-1)/a,cnt); p.x+=k*a;p.y+=k*a;cnt-=k; &#125; else &#123; k=min((a-1)/b,cnt); p.y-=k*b;p.z-=k*b;cnt-=k; &#125; &#125; return p;&#125;int main()&#123; ll i,j,k,a,b,L,R; scanf("%lld%lld%lld",&amp;A.x,&amp;A.y,&amp;A.z);A.SO(); scanf("%lld%lld%lld",&amp;B.x,&amp;B.y,&amp;B.z);B.SO(); C=GO(A,1e18);a=step; D=GO(B,1e18);b=step; L=1;R=min(a,b); if(C==D)puts("YES"); else &#123;puts("NO");return 0;&#125; if(a&lt;b)B=GO(B,b-a); else A=GO(A,a-b); ans=step; if(A==B)&#123;printf("%lld",ans);return 0;&#125; while(L&lt;=R) &#123; k=L+R&gt;&gt;1; C=GO(A,k);D=GO(B,k); if(C==D)R=k-1; else L=k+1; &#125; printf("%lld",ans+L*2);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>分治法</category>
        <category>二分答案</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI 2010 弹飞绵羊 （分块/LCT）]]></title>
    <url>%2F2018%2F03%2F15%2FHNOI-2010-%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%EF%BC%88%E5%88%86%E5%9D%97-LCT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HNOI2010】弹飞绵羊问题描述 某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 输入格式 第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。对于20%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000 输出格式 对于每个i=1的情况，你都要输出一个需要的步数，占一行。 样例输入 41 2 1 131 12 1 11 1 样例输出 23 如果学了LCT，那么此题就是模板题，因此主要说说分块的做法 一开始的想法肯定是每次直接暴力跳，然而这样的复杂度是$n^2$的，那么，有什么办法可以减少跳的次数呢，考虑分块，如果将整个区间分成$\sqrt{n}$块，并且每次跳一块，那么最多只跳$\sqrt{n}$次，理论可过。具体来讲，对于每一块中的每一个装置，记下他会跳到下一块中的那一个位置，并且记下跳跃次数，然后每次就可以跳一块了。 考虑修改，一个位置被修改，由于每次都只跳了一块，那么影响肯定只影响到一块，因此重新算修改位置所在块的值就好了。 总时间复杂度$n\sqrt{n}$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 400005using namespace std;int n,m,S,T,A[N],NE[N],C[N],ID[N];void MD(int x)&#123; int i,l=(ID[x]-1)*S; for(i=x;i&gt;l;i--) &#123; if(ID[i+A[i]]!=ID[i])NE[i]=i+A[i],C[i]=1; else NE[i]=NE[i+A[i]],C[i]=C[i+A[i]]+1; &#125;&#125;int GA(int x)&#123; int sum=0; while(x&lt;=n) &#123; sum+=C[x]; x=NE[x]; &#125; return sum;&#125;int main()&#123; int i,j,k,p; scanf("%d",&amp;n);S=sqrt(n); for(i=1;i&lt;=n;i++)ID[i]=(i-1)/S+1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); scanf("%d",&amp;m);T=ID[n]; for(i=1;i&lt;=T;i++) for(j=min(n,i*S);j&gt;(i-1)*S;j--) &#123; if(ID[j+A[j]]!=ID[j])NE[j]=j+A[j],C[j]=1; else NE[j]=NE[j+A[j]],C[j]=C[j+A[j]]+1; &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;j); if(j==1) &#123; scanf("%d",&amp;k);k++; printf("%d\n",GA(k)); &#125; else &#123; scanf("%d%d",&amp;k,&amp;p); k++;A[k]=p;MD(k); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>分治法</category>
        <category>分块</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHOI 2005 洗牌（扩展欧几里德）]]></title>
    <url>%2F2018%2F03%2F15%2FAHOI-2005-%E6%B4%97%E7%89%8C%EF%BC%88%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Ahoi2005 洗牌问题描述 为了表彰小联为Samuel星球的探险所做出的贡献，小联被邀请参加Samuel星球近距离载人探险活动。 由于Samuel星球相当遥远，科学家们要在飞船中度过相当长的一段时间，小联提议用扑克牌打发长途旅行中的无聊时间。玩了几局之后，大家觉得单纯玩扑克牌对于像他们这样的高智商人才来说太简单了。有人提出了扑克牌的一种新的玩法。 对于扑克牌的一次洗牌是这样定义的，将一叠N（N为偶数）张扑克牌平均分成上下两叠，取下面一叠的第一张作为新的一叠的第一张，然后取上面一叠的第一张作为新的一叠的第二张，再取下面一叠的第二张作为新的一叠的第三张……如此交替直到所有的牌取完。 如果对一叠6张的扑克牌1 2 3 4 5 6，进行一次洗牌的过程如下图所示： 从图中可以看出经过一次洗牌，序列1 2 3 4 5 6变为4 1 5 2 6 3。当然，再对得到的序列进行一次洗牌，又会变为2 4 6 1 3 5。 游戏是这样的，如果给定长度为N的一叠扑克牌，并且牌面大小从1开始连续增加到N（不考虑花色），对这样的一叠扑克牌，进行M次洗牌。最先说出经过洗牌后的扑克牌序列中第L张扑克牌的牌面大小是多少的科学家得胜。小联想赢取游戏的胜利，你能帮助他吗？ 输入格式 有三个用空格间隔的整数，分别表示N，M，L （其中0＜ N ≤ 10 ^ 10 ，0 ≤ M ≤ 10^ 10，且N为偶数）。 输出格式 单行输出指定的扑克牌的牌面大小。 样例输入 6 2 3 样例输出 6 观察一次洗牌后对应牌的位置，比如 1 2 3 4 5 62 4 6 1 3 5 可以发现如果后面三个数都加上$n+1$那么就是 2 4 6 8 10 12 那么规律就很明显了，得到递推式$x=2x \ mod(n+1)$ 如果没有观察出来，那么暴力写递推，有 设当前状态下的位置为$x(1\leq x\leq n)$，洗一次牌后的位置为$x’$。当$x\leq \frac{n}{2}$时，$x’=2x$。当$x&gt;\frac{n}{2}$时，$x’=2(x-\frac{n}{2})-1=2x-n-1$。可以发现，两种状态可以合并，得到$x’=2x\ mod\ (n+1)$ 于是题目的解变成了方程$2^m\times x\equiv L\ mod\ (n+1)$的解，用扩欧处理即可。 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll n,m,l,p;ll QM(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1)ans=ans*a%p; b&gt;&gt;=1;a=a*a%p; &#125; return ans;&#125;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1;y=0;return a;&#125; ll r,x1,y1; r=exgcd(b,a%b,x1,y1); x=y1;y=x1-a/b*y1; return r;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;l);p=n+1; ll a=QM(2,m),b=n+1,x,y,d,k; d=exgcd(a,b,x,y);k=l/d; x=k*x;x%=p;x+=p;x%=p; printf("%lld",x);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>扩展欧几里德</category>
      </categories>
      <tags>
        <tag>扩展欧几里德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI 2010 软件安装（Tarjan+树形dp）]]></title>
    <url>%2F2018%2F03%2F15%2FHAOI-2010-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88Tarjan-%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【HAOI2010 Day1】软件安装问题描述 现在我们的手头有N个软件，对于一个软件i，它要占用Wi的磁盘空间，它的价值为Vi。我们希望从中选择一些软件安装到一台磁盘容量为M的计算机上，使得这些软件的价值尽可能大（即Vi的和最大）。但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件j（包括软件j的直接或间接依赖）的情况下才能正确工作（软件吗i依赖软件j）。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么他能够发挥的作用为0。我们现在知道了软件之间的依赖关系：软件i依赖Di。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则Di=0，这是只要这个软件安装了，它就能正常工作。 输入格式 第1行：N,M （0&lt;=N&lt;=100,0&lt;=M&lt;=500）第2行：W1,W2, … Wi, … ,Wn第3行：V1,V2, … Vi, … ,Vn第4行：D1,D2, … Di, … ,Dn 输出格式 一个整数，代表最大价值。 样例输入 3 105 5 62 3 40 1 1 样例输出 5 此题看上去是裸的树形dp，然而，软件的依赖关系形成的是一个图，这个图可能有多个联通块，还可能存在环，因此需要用Tarjan缩点，然后添加一个虚拟的原点，向每一个缩点后的树根连边，构成一棵树，然后跑dp就好。 关于dp，将每个点看成一个$M-Wi$的背包，然后再把自己加进去就行了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define N 1005using namespace std;int n,m,W[N],V[N],NW[N],NV[N],D[N];int scc,VT,BE[N],low[N],dfn[N];int TOT,LA[N],NE[N],ST[N],EN[N];int tot,la[N],ne[N],en[N];int F[N][N];bool mark[N],map[N][N];stack&lt;int&gt;S;void ADD(int x,int y)&#123; TOT++; ST[TOT]=x; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void add(int x,int y)&#123; tot++; en[tot]=y; ne[tot]=la[x]; la[x]=tot;&#125;void Tarjan(int u)&#123; int i,v; dfn[u]=low[u]=++VT; S.push(u);mark[u]=1; for(i=LA[u];i;i=NE[i]) &#123; v=EN[i]; if(!dfn[v]) &#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(mark[v])low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u]) &#123; scc++; do&#123; v=S.top(); S.pop(); mark[v]=0; BE[v]=scc; NW[scc]+=W[v]; NV[scc]+=V[v]; &#125;while(u!=v); &#125;&#125;void DP(int x)&#123; int i,j,k,y; for(i=la[x];i;i=ne[i]) &#123; y=en[i]; DP(y); for(j=m-NW[x];j&gt;=0;j--) for(k=j;k&gt;=0;k--)F[x][j]=max(F[x][j],F[x][k]+F[y][j-k]); &#125; for(i=m;i&gt;=0;i--) if(i&gt;=NW[x])F[x][i]=F[x][i-NW[x]]+NV[x]; else F[x][i]=0;&#125;int main()&#123; int i,j,x,y,ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;W[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;V[i]); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;x); if(x)ADD(x,i); &#125; for(i=1;i&lt;=n;i++)if(!dfn[i])Tarjan(i); for(i=1;i&lt;=TOT;i++) &#123; x=ST[i];y=EN[i]; if(BE[x]!=BE[y])add(BE[x],BE[y]),D[BE[y]]++; &#125; BE[0]=scc+1; for(i=1;i&lt;=scc;i++)if(!D[i])add(BE[0],i); DP(BE[0]); for(i=0;i&lt;=m;i++)ans=max(ans,F[BE[0]][i]); printf("%d",ans);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
        <category>树形dp</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 2015 Feb Gold 检查 （AC自动机+栈）]]></title>
    <url>%2F2018%2F03%2F15%2FUSACO-2015-Feb-Gold-%E6%A3%80%E6%9F%A5-%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【USACO 2015 Feb Gold】检查问题描述 FJ把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过10^5的字符串S。他有一个包含n个单词的列表，列表里的n个单词记为t_1…t_N。他希望从S中删除这些单词。FJ每次在S中找到最早出现的列表中的单词(最早出现指该单词的开始位置最小)，然后从S中删除这个单词。他重复这个操作直到S中没有列表里的单词为止。注意删除一个单词后可能会导致S中出现另一个列表中的单词FJ注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在S中出现的开始位置是互不相同的请帮助FJ完成这些操作并输出最后的S 输入格式 第一行包含一个字符串S第二行包含一个整数N接下来的N行，每行包含一个字符串，第i行的字符串是t_i 输出格式 一行，输出操作后的S 样例输入 begintheescapexecutionatthebreakofdawn2escapeexecution 样例输出 beginthatthebreakofdawn 提示 t_1…t_N的长度和不超过10^5所有字符串都只包含小写字母 显然建立AC自动机进行匹配，那么考虑删除操作，用一个栈来存已匹配过的主串，那么删除时直接退栈即可，问题在于退栈后应该从AC自动机的哪一个节点开始讨论，因此需要存下主串每一个位置匹配后在AC自动机上的位置，那么退栈时只要跑到之前存下的位置即可。 需要注意的是建立Fail指针的时候，某些写法会超时，背一个优秀的模板。（有限状态自动机） 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 100005using namespace std;struct node&#123;int Son[26],k,Fail,dep;&#125;;node trie[N*10];char S[N],s[N];int C[N],D[N],Top;int n,l,tot=1;queue&lt;int&gt;Q;void Ins()&#123; int i,p=1,le=strlen(s)-1; for(i=1;i&lt;=le;i++) &#123; int t=s[i]-'a'; if(!trie[p].Son[t])trie[p].Son[t]=++tot,trie[tot].dep=trie[p].dep+1; p=trie[p].Son[t]; &#125; trie[p].k=1;&#125;void BUF()&#123; int i,p,son,tmp; for(i=0;i&lt;26;i++) &#123; if(trie[1].Son[i])trie[trie[1].Son[i]].Fail=1,Q.push(trie[1].Son[i]); else trie[1].Son[i]=1; &#125; while(Q.size()) &#123; p=Q.front();Q.pop(); for(i=0;i&lt;26;i++) if(trie[p].Son[i])trie[trie[p].Son[i]].Fail=trie[trie[p].Fail].Son[i],Q.push(trie[p].Son[i]); else trie[p].Son[i]=trie[trie[p].Fail].Son[i]; &#125;&#125;void Find()&#123; int i=0,p=1,t;D[0]=1; while(++i&lt;=l) &#123; t=S[i]-'a'; p=D[C[Top]]; C[++Top]=i; while(p&amp;&amp;(!trie[p].Son[t]))p=trie[p].Fail; p=trie[p].Son[t]; if(!p)p=1; if(trie[p].k==1)Top-=trie[p].dep; D[i]=p; &#125;&#125;int main()&#123; int i; scanf("%s",&amp;S[1]);S[0]='%'; l=strlen(S)-1; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%s",&amp;s[1]);s[0]='%'; Ins(); &#125; BUF();Find(); for(i=1;i&lt;=Top;i++)printf("%c",S[C[i]]);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4254 区间MEX （线段树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4254-%E5%8C%BA%E9%97%B4MEX-%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4254区间MEX问题描述 给你一个长度为n的数列，元素编号1到n，第i个元素值为Ai。现在有m个形如(L,R)的提问，你需要回答出区间[L,R]的mex值。即求出区间[L,R]中没有出现过的最小的非负整数。 输入格式 第一行，两个整数n和m第二行，n个空格间隔的整数，表示数列A接下来m行，每行两个整数L,R,表示一次询问 输出格式 m行，每行一个整数，表示对应询问的答案。 样例输入 7 50 2 1 0 1 3 21 32 31 43 62 7 样例输出 30324 提示 1&lt;=n,m&lt;=2000000&lt;=Ai&lt;=2000001&lt;=L&lt;=R&lt;=n 由于没有修改，可以考虑离线算法。先将询问按照左端点排序。 令$S[i]$表示区间$[1,i]$的$MEX值$，容易发现$S[i]$单调不降，并且可以$O(n)$的处理出来$S$数组。那么左端点为1的询问都可以处理，然后考虑如何处理左端点为2时 考虑删掉$A[1]$对$S$数组的影响，那么令$x=A[1]下一次出现的位置$，那么$S[x]$以后肯定不会受到影响，而对于$x$之前的$S[k]$ 如果$S[k]&gt;A[i]$，那么$S[k]=A[i]$，否则不变 那么区间修改用线段树来维护，按照左端点升序讨论即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200005#define M 2000005#define min(a,b) ((a&gt;b)?(b):(a))using namespace std;struct node&#123;int id,l,r,ans;&#125;Q[N];bool cmp(node a,node b)&#123;return a.l&lt;b.l;&#125;bool ccp(node a,node b)&#123;return a.id&lt;b.id;&#125;int n,m,A[N],B[N],NE[N],LA[N];bool mark[N];int ls[M],rs[M],v[M],lazy[M],tot,rt;int BT(int x,int y)&#123; int p=++tot; lazy[p]=-1; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; else v[p]=B[x]; return p;&#125;void PD(int p)&#123; int l=ls[p],r=rs[p],d=lazy[p]; lazy[p]=-1; v[l]=min(v[l],d); v[r]=min(v[r],d); if(lazy[l]==-1)lazy[l]=d; else lazy[l]=min(lazy[l],d); if(lazy[r]==-1)lazy[r]=d; else lazy[r]=min(lazy[r],d);&#125;void MD(int p,int l,int r,int x,int y,int d)&#123; if(lazy[p]!=-1)PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;lazy[p]=d;v[p]=min(v[p],d);return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)MD(ls[p],l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)MD(rs[p],mid+1,r,x,y,d);&#125;int GA(int p,int l,int r,int k)&#123; if(lazy[p]!=-1)PD(p); if(l==r)return v[p]; int mid=l+r&gt;&gt;1; if(k&lt;=mid)return GA(ls[p],l,mid,k); return GA(rs[p],mid+1,r,k);&#125;int main()&#123; int i,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r),Q[i].id=i; sort(Q+1,Q+m+1,cmp);x=0; for(i=1;i&lt;=n;i++) &#123; mark[A[i]]=1; while(mark[x])x++; B[i]=x; &#125; for(i=n;i&gt;=1;i--) &#123; if(!LA[A[i]])NE[i]=n+1; else NE[i]=LA[A[i]]; LA[A[i]]=i; &#125; rt=BT(1,n);x=1;i=1; while(i&lt;=m) &#123; while(x&lt;Q[i].l) &#123; if(x+1&lt;NE[x])MD(rt,1,n,x+1,NE[x]-1,A[x]); x++; &#125; while(x==Q[i].l) &#123; Q[i].ans=GA(rt,1,n,Q[i].r); i++; &#125; &#125; sort(Q+1,Q+m+1,ccp); for(i=1;i&lt;=m;i++)printf("%d\n",Q[i].ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4252 数三角形（乱搞）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4252-%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4252数三角形问题描述 刚刚上高中的洁洁在学习组合数学的过程中遇到一道麻烦的题目，她希望你能帮助她解决。给定一张无向完全图 G，其中大部分边被染成蓝色，但也有一些边被染成红色或者绿色。现在，洁洁需要给这张图的多样性进行打分。一张图的多样性取决于它的同色和异色三角形的个数。具体来说，G 中每有一个三边颜色都互不同的三角形（异色三角形）可以得 3 分，每有一个三边颜色都相同的三角形（同色三角形）则要被扣掉 6 分，其它三角形不得分也不扣分。 现在，请你写一个程序来计算 G 的多样性分数。 输入格式 第一行两个正整数 n 和 m，其中 n 表示 G 中顶点的个数，m表示 G 中红色或者绿色的边的条数。 接下来 m行每行包括三个整数 a,b,c代表连接顶点 a和顶点 b的边颜色为红色 (c=1)或者绿色 (c=2)。 输出格式 一行G的多样性得分。 样例输入 4 31 2 11 3 12 3 1 样例输出 -6 此题纯属巧合。令$Same$表示同色角的个数，$Dif$表示异色角的个数，同时令 $A=同色三角形的个数$$B=有两边同色的三角形的个数$$C=三边都异色的三角形的个数$ 那么有$Same=3\times A+B$$Dif=2\times B+3\times C$注意到我们要求的是$3\times C-6\times A$，那么就等于$Dif-2\times Same$ 那么此题得解。 代码： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 100005#define ll long longusing namespace std;ll n,m,cnt1,cnt2,cnt[N][3];int main()&#123; ll i,j,x,y,z; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); cnt[x][z]++;cnt[y][z]++; &#125; for(i=1;i&lt;=n;i++) &#123; cnt[i][0]=n-1-cnt[i][1]-cnt[i][2]; for(j=0;j&lt;=2;j++)cnt1+=cnt[i][j]*(cnt[i][j]-1)/2; cnt2+=cnt[i][0]*cnt[i][1]; cnt2+=cnt[i][0]*cnt[i][2]; cnt2+=cnt[i][1]*cnt[i][2]; &#125; printf("%lld",cnt2-cnt1*2);&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>数学杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3861 子矩阵（矩阵dp+单调队列）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3861-%E5%AD%90%E7%9F%A9%E9%98%B5%EF%BC%88%E7%9F%A9%E9%98%B5dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3861子矩阵问题描述 小 A 有一个 N×M 的矩阵，矩阵中 1~NM 这(NM)个整数均出现过一次。 现在小 A 在这个矩阵内选择一个子矩阵，其权值等于这个子矩阵中的所有数的最 小值。小 A 想知道，如果他选择的子矩阵的权值为 i(1&lt;=i&lt;=N×M)，那么他选择 的子矩阵可能有多少种？小 A 希望知道所有可能的 i 值对应的结果，但是这些结 果太多了，他算不了，因此他向你求助。 输入格式 第一行，两个整数 N,M。接下来的 N 行，每行 M 个整数，表示矩阵中的元素。 输出格式 N×M 行，每行一个整数，其中第 i 行的整数表示如果小 A 选择的子矩阵权 值为 i，他选择的子矩阵的种类数。 数据范围 对于 30%的数据，1&lt;=N,M&lt;=50；对于全部的数据，1&lt;=N,M&lt;=300。 注意到处理矩阵问题的基本套路，先考虑一维的情况，那么显然变成了单调队列的模板题，即找到左边第一个小于它的数，和右边第一个小于它的数，然后乘一下就是矩阵数 那么处理二维的情况时，枚举上下边界，将矩阵每一列压成一个数，就是这一列最小的一个数，然后仍然变成了单调队列的模板题。复杂度$O(n^2m)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define N 305using namespace std;stack&lt;int&gt;Q;int n,m,map[N][N],Min[N][N][N],L[N],R[N];long long Ans[N*N];int main()&#123; int i,j,k,p,t; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)scanf("%d",&amp;map[i][j]); for(k=1;k&lt;=n;k++) for(i=1;i&lt;=m;i++) &#123; t=map[k][i]; for(j=i;j&lt;=m;j++) &#123; if(map[k][j]&lt;t)t=map[k][j]; Min[k][i][j]=t; &#125; &#125; for(i=1;i&lt;=m;i++) for(j=i;j&lt;=m;j++) &#123; for(k=1;k&lt;=n+1;k++) &#123; while(Q.size()&amp;&amp;Min[Q.top()][i][j]&gt;Min[k][i][j])R[Q.top()]=k,Q.pop(); Q.push(k); &#125; for(k=n;k&gt;=0;k--) &#123; while(Q.size()&amp;&amp;Min[Q.top()][i][j]&gt;Min[k][i][j])L[Q.top()]=k,Q.pop(); Q.push(k); &#125; Q.pop(); for(k=1;k&lt;=n;k++)Ans[Min[k][i][j]]+=(L[k]-k)*(k-R[k]); &#125; for(i=1;i&lt;=n*m;i++)printf("%lld\n",Ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3860 分队问题（DP+前缀和优化）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3860-%E5%88%86%E9%98%9F%E9%97%AE%E9%A2%98%EF%BC%88DP-%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3860分队问题问题描述 给定 n 个选手，将他们分成若干只队伍。其中第 i 个选手要求自己所属的队 伍的人数大等于 a[i]人。 在满足所有选手的要求的前提下，最大化队伍的总数。 注：每个选手属于且仅属于一支队伍。 输入格式 第一行一个整数 n，表示人数。 以下 n 行，每行一个整数表示 a[i]。 输出格式 输出队伍总数的最大值。数据保证有解。 样例输入 521223 样例输出 2 数据范围 对于 20%的数据，n &lt;= 10对于 40%的数据，n &lt;= 1000对于 60%的数据，n &lt;= 10000对于 100%的数据，1 &lt;= n &lt;= 10^6 此题容易想成由大到小贪心，但是贪心是错的，比如1 1 1 6 6 6 6 6 6 6这种数据。 正解是dp，令$F[i]$表示将$1-i$个人分队的最多分队数。容易得到$F[i]=max{\ F[j]\ }+1,j&lt;=i-A[i]$那么只需要$G[i]=max{\ F[j]\ },j&lt;=i$即可实现$O(n)$ 代码： 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 1234567using namespace std;int n,A[N],F[N],G[N];int main()&#123; int i,j,k; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); sort(A+1,A+n+1); for(i=1;i&lt;=n;i++) &#123; if(i&gt;=A[i])F[i]=G[i-A[i]]+1; G[i]=max(F[i],G[i-1]); &#125; printf("%d",F[n]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2821 作诗 （分块）]]></title>
    <url>%2F2018%2F03%2F15%2FBZOJ-2821-%E4%BD%9C%E8%AF%97-%EF%BC%88%E5%88%86%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[作诗问题描述 神犇SJY虐完HEOI之后给傻×LYD出了一题：SHY是T国的公主，平时的一大爱好是作诗。由于时间紧迫，SHY作完诗之后还要虐OI，于是SHY找来一篇长度为N的文章，阅读M次，每次只阅读其中连续的一段[l,r]，从这一段中选出一些汉字构成诗。因为SHY喜欢对偶，所以SHY规定最后选出的每个汉字都必须在[l,r]里出现了正偶数次。而且SHY认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是SHY请LYD安排选法。LYD这种傻×当然不会了，于是向你请教……问题简述：N个数，M组询问，每次问[l,r]中有多少个数出现正偶数次。 输入格式 输入第一行三个整数n、c以及m。表示文章字数、汉字的种类数、要选择M次。第二行有n个整数，每个数Ai在[1, c]间，代表一个编码为Ai的汉字。接下来m行每行两个整数l和r，设上一个询问的答案为ans(第一个询问时ans=0)，令L=(l+ans)mod n+1, R=(r+ans)mod n+1，若L&gt;R，交换L和R，则本次询问为[L,R]。 输出格式 输出共m行，每行一个整数，第i个数表示SHY第i次能选出的汉字的最多种类数。 样例输入 5 3 51 2 2 3 10 41 22 22 33 5 样例输出 20001 提示 1&lt;=n,c,m&lt;=10^5 强制在线，用分块处理。 首先，如果$L$，$R$在同一块，那么暴力枚举每一个位置，算出答案。然后考虑不在同一块时。 注意到为了算出答案，需要知道每种颜色出现的次数，但是每个位置去算肯定会超时，注意到询问可以分成三个部分，$L$所在的块，$R$所在的块，和他们中间的块，那么如果知道了中间所有块中，出现了正偶数次的数有多少个，同时知道了$L$,$R$所在块中出现的颜色在整个询问区间中出现的次数，那么就可以算出答案。 首先处理中间块的出现了正偶数次的数有多少。显然需要预处理。那么令$F[i][j]$表示从第$i$块到第$j$块的答案，那么这个可以在$O(n\sqrt{n}$内处理出来，具体实现可以参考代码。 然后考虑如何知道$L$,$R$所在块中的数字在整个区间中出现的次数，同样分成两部分来考虑，一部分是中间块的出现次数，另一部分是$L$，$R$所在块的出现次数。后者每次暴力枚举即可，考虑前者，考虑前缀和。那么令$G[i][j]$表示$[1,i]$块中数字$j$出现的次数，那么同样可以$O(n\sqrt{n})$处理出来，处理方法见代码。 于是就可以处理不在同一块的情况了，先令$Sum$为中间块的答案，每次只需要看$L$,$R$所在块中出现的数字在中间块中出现的次数和在全区间出现次数的关系对$Sum$进行修改即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define M 100005using namespace std;int n,c,m,S,N,ans,A[M],F[333][333],G[333][M],cnt[M],T[M],Q[M],ID[M];int GS(int x,int y,int t)&#123; int l=ID[x]; int r=ID[y]; int sum=0,p,q,i,j; if(l==r) &#123; for(i=x;i&lt;=y;i++) &#123; if(T[A[i]]!=t)cnt[A[i]]=0,T[A[i]]=t; if(!(cnt[A[i]]&amp;1)&amp;&amp;cnt[A[i]])sum--; cnt[A[i]]++; if(!(cnt[A[i]]&amp;1))sum++; &#125; return sum; &#125; if(l+1&lt;=r-1)sum=F[l+1][r-1]; for(i=x;i&lt;=l*S&amp;&amp;i&lt;=n;i++) &#123; if(T[A[i]]!=t)cnt[A[i]]=0,T[A[i]]=t; p=cnt[A[i]]; if(l+1&lt;=r-1)p+=G[r-1][A[i]]-G[l][A[i]]; if(p&amp;&amp;(!(p&amp;1)))sum--; cnt[A[i]]++;p++; if(p&amp;&amp;(!(p&amp;1)))sum++; &#125; for(i=y;i&gt;(r-1)*S;i--) &#123; if(T[A[i]]!=t)cnt[A[i]]=0,T[A[i]]=t; p=cnt[A[i]]; if(l+1&lt;=r-1)p+=G[r-1][A[i]]-G[l][A[i]]; if(p&amp;&amp;(!(p&amp;1)))sum--; cnt[A[i]]++;p++; if(p&amp;&amp;(!(p&amp;1)))sum++; &#125; return sum;&#125;int main()&#123; int i,j,k,p,x,y; scanf("%d%d%d",&amp;n,&amp;c,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); S=sqrt(n);N=(n-1)/S+1; for(i=1;i&lt;=n;i++)ID[i]=(i-1)/S+1;//预处理块的id for(i=1;i&lt;=N;i++) for(j=(i-1)*S+1;j&lt;=n;j++)//预处理F[i][j] &#123; p=ID[j]; if(j%S==1)F[i][p]=F[i][p-1]; if(Q[A[j]]!=i)Q[A[j]]=i,cnt[A[j]]=0; if(!(cnt[A[j]]&amp;1)&amp;&amp;cnt[A[j]])F[i][p]--; cnt[A[j]]++; if(!(cnt[A[j]]&amp;1))F[i][p]++; &#125; memset(cnt,0,sizeof(cnt)); for(i=1;i&lt;=n;i++)//预处理G[i][j] &#123; cnt[A[i]]++; if(i%S==0||i==n) &#123; p=ID[i]; for(k=1;k&lt;=c;k++)G[p][k]=cnt[k]; &#125; &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); x=(x+ans)%n+1; y=(y+ans)%n+1; if(x&gt;y)x^=y^=x^=y; ans=GS(x,y,i); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4250 小区划分（dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4250-%E5%B0%8F%E5%8C%BA%E5%88%92%E5%88%86%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4250小区划分问题描述 一条街道的两侧各连续坐落着 N 座单元楼。现在要为这些单元楼划分居民校区。 规则如下： 每个小区只能由同一侧连续的若干座单元楼组成。且两侧都恰有 K 个小区（每个小区至少有一栋楼）。 两侧的小区划分规则应该相同，比如，若左边的房子被分成 {1,2},{3} 这两个小区，那么右边也应该如此。 这样两边合计一共有 K 对小区。 用 ai,bii​​,b​i​​ 表示左右两边每座楼的人口在同侧所有单元楼总人口中所占的百分比，定义一个小区的相对拥挤程度为其人口百分比之和（左边就是对应 aia_ia​i​​ 的和，右边是对应 bib_ib​i​​ 的和)。定义这条街道的总拥挤程度为左右两边 KKK 对小区的相对拥挤程度之差的绝对值之和。 现在，请你求出可能的最大拥挤程度。 输入格式 第一行两个整数 N 和 k。 第二行 N 个实数，第 i 个数为 ai​i​​。 第三行 N 个实数，第 i 个数位 bi​i​​。 输出格式 一个实数，表示这条街道的最大相对拥挤程度，保留到小数点后六位。 样例输入 3 20.1 0.75 0.150.4 0.3 0.3 样例输出 0.600000 提示 对于 30%的数据：n≤20。 对于 100% 的数据：n≤800,k≤80。 保证 ∑ai=1,∑b​i​​=1。 令$F[i][j]$表示前$i$座单元楼，划分成$j$个小区的最大拥挤度，那么容易得到$$f[i][j]=max(f[k][j−1]+abs((Suma[i]−Suma[k])−(Sumb[i]−Sumb[k])))$$复杂度$O(n^2k)$ 关键是注意细节，$F[i][1]$在上述式子中会出问题，因此$F[i][0]$必须赋值为$-inf$，而$F[0][0]=0$ 代码： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 805using namespace std;int n,m;double A[N],B[N],SA[N],SB[N],F[N][100];int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%lf",&amp;A[i]),SA[i]=SA[i-1]+A[i]; for(i=1;i&lt;=n;i++)scanf("%lf",&amp;B[i]),SB[i]=SB[i-1]+B[i]; for(i=0;i&lt;=n;i++) for(j=0;j&lt;=m;j++)F[i][j]=-1e9; F[0][0]=0; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m&amp;&amp;j&lt;=i;j++) for(k=0;k&lt;i;k++)F[i][j]=max(F[i][j],F[k][j-1]+fabs(SA[i]-SA[k]-SB[i]+SB[k])); printf("%.6lf",F[n][m]);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4247 老蒋的数列（乱搞）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4247-%E8%80%81%E8%92%8B%E7%9A%84%E6%95%B0%E5%88%97%EF%BC%88%E4%B9%B1%E6%90%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4247老蒋的数列问题描述 输入格式 第一行一个整数n 接下来n行每行一个整数xi 输出格式 输出共包含n行 每行两个正整数q，p（要求q&gt;p），表示与xi相对应的整数对 样例输入 42036100666 样例输出 6 138 379 21156 1155 提示 对于30%的数据，输出的p，q均不超过20 对于另外40%的数据，保证p，q之差为1 对于100%的数据，n&lt;=250000，xi&lt;=10^9 数据是有梯度的 观察发现，$a[i]$的增长速度非常的快，那么当$a[i]$大于$10^9$之后，当$a[i]=2\times a[i-1]$，$a[i]-a[i-1]$的值大于$10^9$就不会对答案产生影响了。 基于这一点，本题可以先递推一部分，处理出一部分差值，存到数据结构里面，然后再处理较大的一部分。递推的复杂度$O(n^2)$ 然后需要考虑当$a[i]$比较大的时候，怎么求出所求数对。显然这时差值只能是$b[i]$，即$a[i]=a[i-1]$，那么观察$b[i]$的增长，发现$b[i+2]=b[i]+1$，然而有的时候$b[i+2]=b[i]+k$，这种时候是由于前面递推的一部分中出现了$b[i]+1$，那么可以用二分查找 对于一个询问$x​$，当他大于了我们递推出来的最大差值$T​$时，二分查找$x​$之前，到递推终点之间，有多少个差值已经出现了，然后考虑$b[i]​$何时达到$x​$，显然如果$b[i]+1​$没有出现过，那么$b[i+2]=b[i]+1​$，那么只需要$递推终点+2\times(x-T)-2\times已出现差值数​$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define ll long longusing namespace std;struct node&#123;ll d,x,y;&#125;;bool cmp(node a,node b)&#123;return a.d&lt;b.d;&#125;ll n,A[1234],B[1234],tot;node C[5555],tmp;map&lt;ll,bool&gt;Q;int main()&#123; ll i,j,k=3,x; scanf("%lld",&amp;n); A[1]=1;A[2]=2;B[1]=1;B[2]=2; C[++tot].d=1;C[tot].x=2;C[tot].y=1; for(i=3;i&lt;=79;i++) &#123; if(i&amp;1)A[i]=A[i-1]*2; else A[i]=A[i-1]+B[i-1]; for(j=1;j&lt;i;j++)C[++tot].d=A[i]-A[j],C[tot].x=i,C[tot].y=j,Q[A[i]-A[j]]=1; while(Q[k])k++; B[i]=k; &#125; sort(C+1,C+tot+1,cmp); tmp.d=k-1; k=lower_bound(C+1,C+tot+1,tmp,cmp)-C; for(i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;x); if(x==0)&#123;printf("62 61\n");continue;&#125; tmp.d=x; j=lower_bound(C+1,C+tot+1,tmp,cmp)-C; if(C[j].d==x)printf("%lld %lld\n",C[j].x,C[j].y); else printf("%lld %lld\n",C[k].x+2*(x-C[k].d)-2*(j-1-k),C[k].y+2*(x-C[k].d)-2*(j-1-k)); &#125;&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>数学杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4244 （HAOI 2008） 木棍分割 （二分答案+DP+单调队列+前缀和优化+滚动数组）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4244-%EF%BC%88HAOI-2008%EF%BC%89-%E6%9C%A8%E6%A3%8D%E5%88%86%E5%89%B2-%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-DP-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4244【HAOI2008】木棍分割问题描述 有n根木棍, 第i根木棍的长度为Li,n根木棍依次连结了一起, 总共有n-1个连接处. 现在允许你最多砍断m个连接处, 砍完后n根木棍被分成了很多段,要求满足总长度最大的一段长度最小, 并且输出有多少种砍的方法使得总长度最大的一段长度最小. 并将结果mod 10007 输入格式 第一行有2个数n,m. 接下来n行每行一个正整数Li,表示第i根木棍的长度. 输出格式 2个数, 第一个数是总长度最大的一段的长度最小值, 第二个数是有多少种砍的方法使得满足条件. 样例输入 3 21110 样例输出 10 2 数据范围 n&lt;=50000, 0&lt;=m&lt;=min(n-1,1000)1&lt;=Li&lt;=1000 首先，总长度最大的一段的最小值，显然的二分答案，水过。同时令答案为$T$ 然后，考虑方案数，考虑递推，令$F[i][j]$表示前$i$段切$j$刀，且使得每段长度不超过$T$的方案数。容易得到$$F[i][j]=\sum_{Sum[i]-Sum[k] \leq T} F[k][j-1]$$其中$Sum$表示长度的前缀和，那么时间复杂度$O(mn^2)$，空间复杂度$O(mn)$，显然过不了。 空间很容易用滚动数组解决，那么考虑优化时间，注意到$Sum$单调递增，那么我们可以用单调队列维护$k$，那么就可以$O(1)$的获取到$k$的最小值，然后需要将$F[k][j-1]$到$F[i-1][j-1]$累和，考虑用前缀和优化，那么观察可以发现，只需要优先枚举$j$，然后就可以实现前缀和优化了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int n,m,p,q,A[50005],S[50005],SS[2][50005],F[2][50005],mod=10007,ans;bool ok(int k)&#123; int i,tot=0,tmp=0; for(i=1;i&lt;=n;i++) &#123; tot+=A[i]; if(tot&gt;k)tot=A[i],tmp++; &#125; if(tmp&gt;m)return 0; return 1;&#125;int EF(int l,int r)&#123; int mid; while(l&lt;=r) &#123; mid=l+r&gt;&gt;1; if(ok(mid))r=mid-1; else l=mid+1; &#125; return l;&#125;int main()&#123; int i,j,k,t=0,l,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;A[i]); t+=A[i]; q=max(q,A[i]); S[i]=S[i-1]+A[i]; &#125; p=EF(q,t); for(i=1;i&lt;=n;i++) &#123; if(S[i]&lt;=p)F[0][i]=1; SS[0][i]=SS[0][i-1]+F[0][i]; &#125; for(i=1;i&lt;=m;i++) &#123; l=i;x=i&amp;1;y=x^1; for(j=i+1;j&lt;=n;j++) &#123; while(S[j]-S[l]&gt;p)l++; F[x][j]=(SS[y][j-1]-SS[y][l-1])%mod; SS[x][j]=(SS[x][j-1]+F[x][j])%mod; &#125; ans+=F[x][n];ans%=mod; &#125; printf("%d %d",p,(ans+mod)%mod);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>分治法</category>
        <category>一般dp</category>
        <category>二分答案</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2182 （HEOI 2012） 采花（树状数组/线段树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2182-%EF%BC%88HEOI-2012%EF%BC%89-%E9%87%87%E8%8A%B1%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2182【河北OI 2012 DAY1】采花问题描述 萧芸斓是Z 国的公主，平时的一大爱好是采花。今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。花园足够大，容纳了n 朵花，花有c 种颜色（用整数1-c 表示），且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴！同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了m 个行程，然后一一向你询问公主能采到多少朵花（她知道你是编程高手，定能快速给出答案！），最后会选择令公主最高兴的行程（为了拿到更多奖金！）。 输入格式 第一行四个空格隔开的整数n、c 以及m。接下来一行n 个空格隔开的整数，每个数在[1, c]间，第i 个数表示第i 朵花的颜色。接下来m 行每行两个空格隔开的整数l 和r（l ≤ r），表示女仆安排的行程为公主经过第l 到第r 朵花进行采花。 输出格式 共m 行，每行一个整数，第i 个数表示公主在女仆的第i 个行程中能采到的花的颜色数。 样例输入 5 3 51 2 2 3 11 51 22 22 33 5 样例输出 20010 数据范围 对于20%的数据，n ≤ 10^2，c ≤ 10^2，m ≤ 10^2；对于50%的数据，n ≤ 10^5，c ≤ 10^2，m ≤ 10^5；对于100%的数据，1 ≤ n ≤10^5，c ≤ n，m ≤ 10^5。 主要是两种思路，都是离线算法。做法一：令$C[i]$表示从1到i总共出现的不同颜色且出现次数大于1的花的数量，那么预处理出每一朵花的下一个和他同颜色的花的位置，记到$next[x]$数组中令当前讨论的左端点为$x$，那么当x左移的时候，对$C[i]$产生的影响是$next[x]$到$next[next[x]]-1$位置的$C[i]$减一，于是将区间排序，用线段树维护$C[i]$，进行区间操作即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200005using namespace std;struct node&#123;int x,y,id,ans;&#125;B[N];bool cmp1(node a,node b)&#123;return a.x&lt;b.x;&#125;bool cmp2(node a,node b)&#123;return a.id&lt;b.id;&#125;int n,c,m,A[N],NE[N],LA[N],C[N],cnt[N];int ls[N*10],rs[N*10],v[N*10],lazy[N*10],tot;int BT(int x,int y)&#123; int p=++tot; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); &#125; else v[p]=C[x]; return p;&#125;void PD(int p)&#123; v[ls[p]]+=lazy[p]; v[rs[p]]+=lazy[p]; lazy[ls[p]]+=lazy[p]; lazy[rs[p]]+=lazy[p]; lazy[p]=0;&#125;void MD(int p,int l,int r,int x,int y,int d)&#123; if(lazy[p])PD(p); if(x&lt;=l&amp;&amp;y&gt;=r)&#123;lazy[p]+=d;v[p]+=d;return;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid&amp;&amp;y&gt;=l)MD(ls[p],l,mid,x,y,d); if(x&lt;=r&amp;&amp;y&gt;mid)MD(rs[p],mid+1,r,x,y,d);&#125;int GS(int p,int l,int r,int k)&#123; if(lazy[p])PD(p); if(l==r)return v[p]; int mid=l+r&gt;&gt;1; if(k&lt;=mid)return GS(ls[p],l,mid,k); return GS(rs[p],mid+1,r,k);&#125;int main()&#123; int i,j,k; scanf("%d%d%d",&amp;n,&amp;c,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); for(i=n;i&gt;=1;i--) &#123; if(!LA[A[i]])NE[i]=n+1; else NE[i]=LA[A[i]]; LA[A[i]]=i; &#125; NE[n+1]=n+1; for(i=1;i&lt;=n;i++) &#123; cnt[A[i]]++; C[i]=C[i-1]; if(cnt[A[i]]==2)C[i]++; &#125; BT(1,n); for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;B[i].x,&amp;B[i].y),B[i].id=i; sort(B+1,B+m+1,cmp1);i=1;j=1; while(j&lt;=m) &#123; while(B[j].x&gt;i)MD(1,1,n,NE[i],NE[NE[i]]-1,-1),i++; while(B[j].x==i)B[j].ans=GS(1,1,n,B[j].y),j++; &#125; sort(B+1,B+m+1,cmp2); for(i=1;i&lt;=m;i++)printf("%d\n",B[i].ans);&#125; 做法二：始终将从当前讨论位置往后，每种颜色的第二次出现的位置的地方为1，其他地方为0，那么维护前缀和数组即可求出答案。因此，同样用$next$数组，然后用树状数组维护前缀和。当讨论到一个询问的左端点时，右端点的前缀和值就是答案，只需要始终维护从当前讨论位置开始，每种颜色第二次出现的位置即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 200005using namespace std;struct node&#123;int x,y,id,ans;&#125;B[N];bool cmp1(node a,node b)&#123;return a.x&lt;b.x;&#125;bool cmp2(node a,node b)&#123;return a.id&lt;b.id;&#125;int n,c,m,A[N],NE[N],LA[N],C[N],D[N];void MD(int x,int d)&#123;for(int i=x;i&lt;=n;i+=(i&amp;-i))D[i]+=d;&#125;int GS(int x)&#123; int i,sum=0; for(i=x;i;i-=(i&amp;-i))sum+=D[i]; return sum;&#125;int main()&#123; int i,j,k; scanf("%d%d%d",&amp;n,&amp;c,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); NE[n+1]=n+1; for(i=n;i&gt;=1;i--) &#123; if(!LA[A[i]])NE[i]=n+1; else NE[i]=LA[A[i]]; LA[A[i]]=i; MD(NE[i],1); MD(NE[NE[i]],-1); &#125; for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;B[i].x,&amp;B[i].y),B[i].id=i; sort(B+1,B+m+1,cmp1); i=1;k=1; while(k&lt;=m) &#123; while(i&lt;B[k].x)MD(NE[i],-1),MD(NE[NE[i]],1),i++; while(i==B[k].x)B[k].ans=GS(B[k].y),k++; &#125; sort(B+1,B+m+1,cmp2); for(i=1;i&lt;=m;i++)printf("%d\n",B[i].ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2040 （CQOI 2011）放棋子（递推+容斥原理+组合数）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2040-%EF%BC%88CQOI-2011%EF%BC%89%E6%94%BE%E6%A3%8B%E5%AD%90%EF%BC%88%E9%80%92%E6%8E%A8-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2040【CQOI2011】放棋子问题描述 在一个n行m列的棋盘里放一些彩色的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列。有多少种方法？ 例如，n=m=3，有两个白棋子和一个灰棋子，下面左边两种方法都是合法的，但右边两种都是非法的。 输入格式 输入第一行为两个整数n, m, c，即行数、列数和棋子的颜色数。第二行包含c个正整数，即每个颜色的棋子数。所有颜色的棋子总数保证不超过nm。 输出格式 输出仅一行，即方案总数除以 1,000,000,009的余数。 样例输入1： 5 2 31 1 1 样例输入2： 4 2 23 1 样例输入3： 8 8 81 1 1 1 1 1 1 1 样例输出1： 0 样例输出2： 8 样例输出3： 625702391 数据范围 编号 1-2 3-5 6-7 8-10n, m &lt;=4 &lt;=10 &lt;=30 &lt;=30c &lt;=2 &lt;=5 &lt;=2 &lt;=10总棋子数 &lt;=5 &lt;=20 &lt;=900 &lt;=250 此题显然考虑递推，关键是如何定状态，关键是要注意到不同颜色的棋子既不在同一行，也不在同一列。 那么对于单一颜色，令$G[k][x][y]$表示将颜色为k的棋子，恰好放在$x$行，$y$列中，保证每一行，每一列至少有一个棋子的方案数那么考虑用容斥原理求解，用$A[k]$表示第$k$种棋子的棋子数，那么有，$$G[k][x][y]=C_{x\times y}^{A[k]}-\sum_{i=0}^{x}\sum_{j=0}^{y}(C_{x}^{x-i}\times C_{y}^{y-j}\times G[k][x-i][y-j])，其中i，j不同时为0$$那么先求出$G[k][x][y]$然后考虑多种颜色，用$F[k][x][y]$表示将前$k$种颜色的棋子放在恰好$x$行，$y$列中，保证每一行，每一列至少有一个棋子的方案数 考虑第$k$种颜色的棋子占了$i$行，$j$列，有$$F[k][x][y]=\sum_{i=1}^{x} \sum_{j=1}^{y}(C_{n+i-x}^{i}\times C_{m+j-y}^{j}\times F[k-1][x-i][y-j]\times G[k][i][j])$$最后统计答案，有$$ans=\sum_{i=1}^{n} \sum_{j=1}^{m}F[c][i][j]$$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll ans,n,m,c,A[15],C[1005][1005],G[15][33][33],F[15][33][33],mod=1000000009;int main()&#123; ll i,j,k,x,y; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;c); for(i=1;i&lt;=c;i++)scanf("%lld",&amp;A[i]); for(i=0;i&lt;=1000;i++)C[i][0]=1; for(i=1;i&lt;=1000;i++) for(j=1;j&lt;=1000;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; for(k=1;k&lt;=c;k++) for(i=1;i&lt;=min(n,A[k]);i++) for(j=1;j&lt;=min(m,A[k]);j++) &#123; G[k][i][j]=C[i*j][A[k]]; for(x=0;x&lt;i;x++) for(y=0;y&lt;j;y++) if(x||y)G[k][i][j]=(G[k][i][j]-C[i][i-x]*C[j][j-y]%mod*G[k][i-x][j-y])%mod; &#125; F[0][0][0]=1; for(k=1;k&lt;=c;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(x=1;x&lt;=min(i,A[k]);x++) for(y=1;y&lt;=min(j,A[k]);y++) F[k][i][j]=(F[k][i][j]+C[n+x-i][x]*C[m+y-j][y]%mod*F[k-1][i-x][j-y]%mod*G[k][x][y]%mod)%mod; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)ans=(ans+F[c][i][j])%mod; printf("%lld",(ans+mod)%mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>容斥原理</category>
        <category>递推</category>
        <category>组合数</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>容斥原理</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4191 Trie （状压dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4191-Trie-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4191中山纪念中学 Trie问题描述 字母（Trie）树是一个表示一个字符串集合中所有字符串的前缀的数据结构，其有如下特征： 1.树的每一条边表示字母表中的一个字母2.树根表示一个空的前缀3.树上所有其他的节点都表示一个非空前缀，每一个节点表示的前缀为树根到该节点的路径上所有字母依次连接而成的字符串。4.一个节点的所有出边（节点到儿子节点的边）中不存在重复的字母。 现在Matej手上有N个英文小写字母组成的单词，他想知道，如果将这N个单词中的字母分别进行重新排列，形成的字母树的节点数最少是多少。 输入格式 第一行包含一个正整数N（1&lt;=N&lt;=16）接下来N行每行一个单词，每个单词都由小写字母组成。单词的总长度不超过1,000,000。 输出格式 输出仅一个正整数表示N个单词经过重新排列后，字母树的最少节点数。 样例输入 10jgdadbfdjjhehegdfhfaeejicacagdgfcjcjifiigdbiffdbdiichcadccdd 样例输出 42 此题题目是trie，但是和trie没有什么太大关系，只需要知道，对于这些串，将他们的公共部分作为公共前缀是最优的即可。那么首先考虑两个串，答案显然是他们的长度和减去公共部分。那么再考虑三个串，显然可能出现两两的公共部分大于三个的公共部分的情况，这种时候trie树必然会出现分叉，我们需要考虑如何分叉，分成二叉或三叉，再者哪些串在同一子树上，既然一定会分成多颗子树，那么我们可以直接将这三个串拆成两个子集，先求出两个子集的最优解，然后减去公共部分即可。也就是说，令$F[S]$表示将$S$集合中的字符串弄到一棵树上的最少节点数，那么有$F[S]=min{ F[k]+F[S\ xor\ k] }-S中字符串的公共部分长度$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 66666#define M 1000005using namespace std;int n,S,F[N],cnt[20][200],A[200],sum;char s[M];int main()&#123; int i,j,k; scanf("%d",&amp;n); S=(1&lt;&lt;n)-1; for(i=1;i&lt;=n;i++) &#123; scanf("%s",&amp;s); k=strlen(s); for(j=0;j&lt;k;j++)cnt[i][s[j]]++; &#125; for(i=1;i&lt;=S;i++) &#123; memset(A,60,sizeof(A));sum=0; for(j=1;j&lt;=n;j++) if(i&amp;(1&lt;&lt;j-1)) &#123; for(k='a';k&lt;='z';k++) &#123; F[i]+=cnt[j][k]; A[k]=min(A[k],cnt[j][k]); &#125; &#125; for(j='a';j&lt;='z';j++)sum+=A[j]; for(j=i&amp;i-1;j;j=i&amp;j-1)F[i]=min(F[i],F[i^j]+F[j]); if(F[i]&gt;sum)F[i]-=sum; &#125; printf("%d",F[S]+1);&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>杂学</category>
        <category>状态压缩</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3893 聪聪和可可（数学期望+递推+最短路）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3893-%E8%81%AA%E8%81%AA%E5%92%8C%E5%8F%AF%E5%8F%AF%EF%BC%88%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B-%E9%80%92%E6%8E%A8-%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3893【概率】聪聪和可可问题描述 输入格式 数据的第1行为两个整数N和E，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。第2行包含两个整数C和M，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。接下来E行，每行两个整数，第i+2行的两个整数Ai和Bi表示景点Ai和景点Bi之间有一条路。所有的路都是无向的，即：如果能从A走到B，就可以从B走到A。输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。 输出格式 输出1个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。 样例输入 1 4 31 41 22 33 4 样例输出 1 1.500 样例输入 2 9 99 31 22 33 44 53 64 64 77 88 9 样例输出 2 2.167 令$F[x][y]$表示聪聪在$x$节点，可可在$y$节点时，聪聪吃到可可的期望步数。那么令$tx=聪聪移动后的位置$那么如果$x=y$，$F[x][y]=0$如果$tx=y$，$F[x][y]=1$否则，令$k=可可可能的移动位置$，$D[y]表示y的度数$有$F[x][y]=(\sum F[tx][k] \times \frac{1}{D[y]+1})+1 $ 然后用最短路算法或者BFS预处理出$tx$即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 1005#define MM 2005using namespace std;int n,m,C,M,D[N],P[N][N];int TOT,LA[N],NE[MM],EN[MM];double F[N][N];queue&lt;int&gt;Q;int dis[N];bool mark[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void SPFA(int s)&#123; int i,x,y; memset(dis,60,sizeof(dis)); Q.push(s);mark[s]=1;dis[s]=0; while(Q.size()) &#123; x=Q.front(); Q.pop(); mark[x]=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(dis[y]&gt;dis[x]+1||(dis[y]==dis[x]+1&amp;&amp;P[s][y]&gt;P[s][x])) &#123; dis[y]=dis[x]+1; if(P[s][x])P[s][y]=P[s][x]; else P[s][y]=y; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125;&#125;double DFS(int x,int y)&#123; if(F[x][y])return F[x][y]; if(x==y)return F[x][y]=0; int tx=x,ty=y; tx=P[tx][ty]; if(tx==ty)return F[x][y]=1.0; tx=P[tx][ty]; if(tx==ty)return F[x][y]=1.0; double sum=0; for(int i=LA[y];i;i=NE[i]) &#123; ty=EN[i]; sum+=DFS(tx,ty); &#125; sum+=DFS(tx,y); return F[x][y]=sum/(D[y]+1)+1;&#125;int main()&#123; int i,x,y; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;C,&amp;M); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); D[x]++;D[y]++; &#125; for(i=1;i&lt;=n;i++)SPFA(i); printf("%.3lf",DFS(C,M));&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>图论</category>
        <category>概率与期望</category>
        <category>最短路</category>
        <category>递推</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>概率与期望</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3805 距离（线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3805-%E8%B7%9D%E7%A6%BB%EF%BC%88%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3805距离问题描述 对于两个正整数a、b，这样定义函数d(a,b)：每次操作可以选择一个质数p，将a变成a*p或a/p， 如果选择变成a/p就要保证p是a的约数，d(a,b)表示将a变成b所需的最少操作次数。例如d(69,42)=3。 现在给出n个正整数A1,A2,…,An，对于每个i (1&lt;=i&lt;=n)，求最小的j(1&lt;=j&lt;=n)使得i≠j且d(Ai,Aj)最小。 输入格式 第一行一个正整数n (2&lt;=n&lt;=100,000)。第二行n个正整数A1,A2,…,An (Ai&lt;=1,000,000)。 输出格式 输出n行，依次表示答案。 样例输入 6123456 样例输出 211212 分析一下容易发现，最对于一个数对$(a,b)$最优的变化方法就是$a-&gt;gcd(a,b)-&gt;b$那么，如果我们用$cnt[x]$表示$x$所含的质因数的个数，比如$cnt[8]=3$显然有$d(a,b)=cnt[a]+cnt[b]-2*cnt[gcd(a,b)]$那么对于一个数$a$我们需要找出最优的$b$不妨考虑枚举$gcd$,那么$b$是$gcd$的倍数，但是如果枚举$gcd$再枚举$b$显然要超时。观察发现上式中$cnt[a]$为定值，那么如果我们对于每一个$gcd$处理出使$F[gcd]=cnt[b]-cnt[gcd]$最小的$b$，就能很快解决问题，而这显然是可以预处理出来的，只需要枚举$b$的因数，用$b$更新$F$即可。注意到不能选到相等的下标，因此我们需要记录最小和次小。最后，$cnt$可以线性筛预处理出来，$F$可以枚举因数预处理出来，时间复杂度$O(n\times \sqrt{n})$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(a,b) ((a&gt;b)?(a):(b))#define N 1234567using namespace std;int n,Max,A[N],Cnt[N],cnt,P[N],F1[N],F2[N],ans,Num;void EUL()&#123; int i,j; for(i=2;i&lt;=Max;i++) &#123; if(!Cnt[i])Cnt[i]=1,P[++cnt]=i; for(j=1;j&lt;=cnt&amp;&amp;P[j]*i&lt;=Max;j++) &#123; Cnt[i*P[j]]=Cnt[i]+1; if(i%P[j]==0)break; &#125; &#125;&#125;void Cha(int i,int j)&#123; if(Cnt[A[i]]&lt;=Cnt[A[F1[j]]])F2[j]=F1[j],F1[j]=i; else if(Cnt[A[i]]&lt;=Cnt[A[F2[j]]])F2[j]=i;&#125;void Pre()&#123; int i,j; for(i=n;i&gt;=1;i--) &#123; for(j=1;j*j&lt;=A[i];j++) if(A[i]%j==0) &#123; Cha(i,j); if(j*j!=A[i])Cha(i,A[i]/j); &#125; &#125;&#125;void MD(int x,int i)&#123; int t,k; if(F1[x]!=i)k=F1[x]; else k=F2[x]; t=Cnt[A[k]]-2*Cnt[x]; if(t&lt;ans||(t==ans&amp;&amp;k&lt;Num))ans=t,Num=k;&#125;int main()&#123; int i,j,x; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]),Max=max(A[i],Max); Cnt[0]=1e9;EUL();Pre(); for(i=1;i&lt;=n;i++) &#123; ans=1e9;Num=1e9; for(j=1;j*j&lt;=A[i];j++)if(A[i]%j==0)MD(j,i),MD(A[i]/j,i); printf("%d\n",Num); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3804 机器人M号（递推+欧拉函数）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3804-%E6%9C%BA%E5%99%A8%E4%BA%BAM%E5%8F%B7%EF%BC%88%E9%80%92%E6%8E%A8-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3804机器人 M 号问题描述 3030 年，Macsy正在火星部署一批机器人。第 1 秒，他把机器人 1 号运到了火星，机器人 1 号可以制造其他的机器人。第 2 秒，机器人 1 号造出了第一个机器人——机器人 2 号。第 3 秒，机器人 1 号造出了另一个机器人——机器人 3 号。之后每一秒，机器人 1 号都可以造出一个新的机器人。第 m 秒 造 出的机器人 编号为 m。我们可以称它为机器人 m号，或者 m 号机器人。 机器人造出来后，马上开始工作。m 号机器人，每 m 秒会休息一次。比如 3 号机器人，会在第 6，9，12，……秒休息，而其它时间都在工作。 机器人休息时，它的记忆将会被移植到当时出生的机器人的脑中。比如 6 号 机器人出生时，2，3 号机器人正在休息，因此，6 号机器人会收到第 2，3 号机 器人的记忆副本。我们称第 2，3 号机器人是 6 号机器人的老师。 如果两个机器人没有师徒关系，且没有共同的老师，则称这两个机器人的知 识是互相独立的。 注意： 1 号机器人与其他所有机器人的知识独立（因为只有 1 号才会造机器人 ），它也不是任何机器人的老师。 一个机器人的 独立数 ，是指所有编号比它小且与它知识互相独立的机器人的 个数。比如 1 号机器人的 独立数 为 0，2 号机器人的 独立数 为 1（1 号机器人与它 知识互相独立），6 号机器人的 独立数 为 2（1，5 号机器人与它知识互相独立，2， 3 号机器人都是它的老师，而 4 号机器人与它有共同的老师——2 号机器人）。 新造出来的机器人有 3 种不同的职业。对于编号为 m 的机器人，如果能把 m 分解成偶数个不同奇素数的积，则它是政客，例如编号 15；否则，如果 m 本身 就是奇素数或者能把 m 分解成奇数个不同奇素数的积，则它是军人，例如编号 3, 编号 165。其它编号的机器人都是学者，例如编号 2, 编号 6, 编号 9。 第 m 秒诞生的机器人 m 号，想知道它和它的老师中，所有政客的 独立数 之 和，所有军人的 独立数 之和，以及所有学者的 独立数 之和。可机器人 m 号忙于 工作没时间计算，你能够帮助它吗？ 为了方便你的计算，Macsy已经帮你做了 m 的素因子分解。为了输出方便， 只要求输出总和除以 10000 的余数。 输入格式 第一行是一个正整数 k(1&lt;=k&lt;=1000)，k 是 m 的不同的 素因子个数。以下k行，每行两个整数， pi, ei,表示m的第i个素因子和它的指数(i = 1, 2, …, k)。p1, p2, …, pk是不同的素数，$m=\prod_{i=1}^{k}{p_{i}^{e_i}}$。所有素因子按照从小到大排列，即 p1 &lt; p2 &lt; … &lt; pk。2&lt;=pi&lt;10,000, 1&lt;=ei&lt;=1,000,000。 输出格式 包括三行。 第一行是机器人 m 号和它的老师中，所有政客的 独立数 之和除以 10000 的余 数。 第二行是机器人 m 号和它的老师中，所有军人的 独立数 之和除以 10000 的余 数。 第三行是机器人 m 号和它的老师中，所有学者的 独立数 之和除以 10000 的余 数。 样例输入 32 13 25 1 样例输出 8675 首先考虑政客和军人，由于政客再乘上一个新的质数变成军人，而军人乘上一个新的质数变成政客，那么令$F[i][0]$表示前i个军人的$\phi$之和，$F[i][1]$表示前i个政客的$\phi$之和，那么有$$F[i][0]=F[i-1][0]+F[i-1][1] \times \varphi(A[i])$$$$F[i][1]=F[i-1][1]+F[i-1][0] \times \varphi(A[i])$$于是递推即可求出政客和军人的独立数之和，然后背出公式$n=\sum_{d|n}\varphi(d)$于是学者的独立数之和等于$m-F[k][0]-F[k][1]$ 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll k,A[1234],E[1234],F[1234][2],mod=10000,m=1;ll QM(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1)ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;int main()&#123; ll i; scanf("%lld",&amp;k); for(i=1;i&lt;=k;i++)scanf("%lld%lld",&amp;A[i],&amp;E[i]); if(A[1]==2)F[1][0]=1; else F[0][0]=1; for(i=1;i&lt;=k;i++) &#123; if(A[i]==2)continue; F[i][0]=(F[i-1][0]+F[i-1][1]*(A[i]-1))%mod; F[i][1]=(F[i-1][1]+F[i-1][0]*(A[i]-1))%mod; &#125; F[k][0]--; for(i=1;i&lt;=k;i++)m=m*QM(A[i],E[i])%mod; m=(m-F[k][0]-F[k][1]-1)%mod; m%=mod;m+=mod;m%=mod; printf("%lld\n%lld\n%lld",F[k][0],F[k][1],m);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>递推</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3614(CQOI 2016) 密钥破解（Pollard Rho）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3614-CQOI-2016-%E5%AF%86%E9%92%A5%E7%A0%B4%E8%A7%A3%EF%BC%88Pollard-Rho%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3614【CQOI2016 Day2】密钥破解 问题描述 一种非对称加密算法的密钥生成过程如下： 1.任选两个不同的质数p,q； 2.计算N=pq，r=(p-1)(q-1)； 3.选取小于r，且与r互质的整数e； 4.计算整数d，使得ed≡1 mod r； 5.二元组(N,e)称为公钥，二元组(N,d)称为私钥。 当需要加密消息n时（假设n是一个小于N的整数，因为任何格式的消息都可以转为整数表示），使用公钥(N,e)，按照 ne≡c mod N 运算，可以得到密文c。 对密文解密时，用私钥(N,d)，按照 cd≡n mod N 运算，可以得到原文n。算法正确性证明省略。 由于公钥加密的密文仅能用对应的私钥解密，而不能用公钥解密，因此称为非对称加密算法。通常情况下，公钥有消息的接收方公开，而私钥由消息的接收方自己持有。这样任何发消息的人都可以用公钥对消息加密，而只有消息的接收方自己能够解密消息。 现在，你的任务是寻找一种可行的方法来破解这种加密算法，即根据公钥破接出私钥，并据此解密密文。 输入格式 输入文件内容只有一行，为空格分隔的3个正整数e,N,c。 输出格式 输出文件内容只有一行，为空格分隔的2个整数d,n。 样例输入 3 187 45 样例输出 107 12 提示 样例解释： 样例中p=11，q=17。 数据范围： 对于30%的测试数据，N≤$10^6$； 对于50%的测试数据，N≤$10^{14}$； 对于100%的测试数据，N≤$2^{62}$； 此题需要 Pollard Rho算法 快速幂 快速乘 求逆元 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; ll x1,y1,r; if(b==0)&#123;x=1;y=0;return a;&#125; r=exgcd(b,a%b,x1,y1); x=y1;y=x1-a/b*y1; return r;&#125;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;ll QC(ll a,ll b,ll c)&#123; ll ans=0;a%=c; while(b) &#123; if(b&amp;1)ans=(ans+a)%c; b&gt;&gt;=1; a=(a+a)%c; &#125; return ans;&#125;ll QM(ll a,ll b,ll c)&#123; ll ans=1;a%=c; while(b) &#123; if(b&amp;1)ans=QC(ans,a,c); b&gt;&gt;=1; a=QC(a,a,c); &#125; return ans;&#125;void P_RHO(ll x,ll &amp;p,ll &amp;q)&#123; ll a=1,y1,y2,t; while(1) &#123; y1=y2=rand()%x;y1=(QC(y1,y1,x)+a)%x; while(1) &#123; if(y1==y2)break; t=gcd(y1&gt;y2?y1-y2:y2-y1,x); if(t!=1)&#123;p=t;q=x/t;return;&#125; y2=(QC(y2,y2,x)+a)%x; y1=(QC(y1,y1,x)+a)%x; y1=(QC(y1,y1,x)+a)%x; &#125; a++; &#125;&#125;int main()&#123; ll e,N,c,p,q,d,n,r,t,m; scanf("%lld%lld%lld",&amp;e,&amp;N,&amp;c); P_RHO(N,p,q); r=(p-1)*(q-1); t=exgcd(e,r,d,m); d=(d%r+r)%r; n=QM(c,d,N); cout&lt;&lt;d&lt;&lt;" "&lt;&lt;n;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>Pollard_Rho</category>
      </categories>
      <tags>
        <tag>Pollard_Rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3616(CQOI 2016) 伪光滑数（暴力堆/可持久化可并堆+dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3616-CQOI-2016-%E4%BC%AA%E5%85%89%E6%BB%91%E6%95%B0%EF%BC%88%E6%9A%B4%E5%8A%9B%E5%A0%86-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%AF%E5%B9%B6%E5%A0%86-dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3616【CQOI2016 Day2】伪光滑数 问题描述 若一个大于1的整数M的质因数分解有k项，其最大的质因子为$a_k$，并且满足$a_k^k$≤N，$a_k$&lt;128，我们就称整数M为N-伪光滑数。 现在给出N，求所有整数中，第K大的N-伪光滑数。 输入格式 输入文件内容只有一行，为用空格隔开的整数N和K。 输出格式 输出文件内容只有一行，为一个整数，表示答案。 样例输入 12345 20 样例输出 9167 数据范围： &gt; 对于30%的数据，N≤$10^6$； 对于60%的数据，K≤$10^5$； 对于100%的数据，2≤N≤$10^{18}$，1≤K≤8*$10^5$，保证至少有K个满足要求的数。 算法一：贪心（暴力）+堆观察题目，很容易想到可以将数分类，按照最大素因子来分类，如果最大素因子确定，那么最多可以有多少项也就确定了，因此，一个显然的贪心是，尽量取大的素数构造出来的数肯定是最大的。因此，先弄一个素数表，先把满足条件的素数的最大的次方加入一个大根堆，每次取出堆顶后，构造比他小的且最接近他的数，即除去一个最大素因子，再乘上一个比他小的素数。K-1次操作后取堆顶即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll unsigned long longusing namespace std;struct node&#123;ll x,v,p;&#125;;bool operator&lt;(node a,node b)&#123;return a.v&lt;b.v;&#125;priority_queue&lt;node&gt;Q;ll n,k;ll A[32]=&#123;1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127&#125;;int main()&#123; ll i,t;node tmp,ttp; scanf("%lld%lld",&amp;n,&amp;k); for(i=1;i&lt;32;i++) &#123; t=1; while(t*A[i]&lt;=n)t*=A[i]; tmp.x=A[i];tmp.p=i;tmp.v=t; Q.push(tmp); &#125; while(--k) &#123; tmp=Q.top(); Q.pop(); ttp=tmp; if(tmp.v%tmp.x==0) &#123; for(i=0;i&lt;tmp.p;i++) &#123; ttp.v=tmp.v/tmp.x*A[i]; Q.push(ttp); &#125; &#125; while(Q.top().v==tmp.v)Q.pop(); &#125; cout&lt;&lt;Q.top().v;&#125; 算法二：可持久化可并堆+dp这里先说明一个很简单思想，如果我们要解决求很大的数据中的第K大或第K小之类的问题，如果可以将这些数据归类，并且每一类数可以用一个堆来装起来，那么可以将这些堆放到一个全局堆中来维护，这样就可以解决问题了。实际上，在上一个算法中，我们也是用的这样的方式来实现的，但是并没有将每一个堆实际上开出来，而是由于我们可以很直接的得到恰比某个数小的另一个数，所以采用了暴力枚举来替代堆。因此，算法一实际上优于算法二。算法二的核心在于，我们可以将数归类，用F[i,j]表示最大质因数为p[i]，可以分解成j项的数的集合，利用dp的手段我们可以递推的来将所有的F[i,j]算出来，为了实现，令G[i,j]表示F[i,j]的前缀和，于是$f[i,j]=\sum_{k=1}^jg[i-1,j-k]*p[i]^k$$g[i,j]=g[i-1,j]+f[i,j]$而这里的集合显然可以用可持久化可并堆来维护，于是就可以将所有的F集合全部算出来，并且每一个都是大根堆，最后从全局堆取答案即可。 PS：实际上可以看出，算法二并不如算法一优秀，但是，如果遇到不能够很方便的将恰比某元素小的数找出来的话，算法二就有意义了。]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3611(CQOI 2016) 不同的最小割（分治+最小割=最小割树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3611-CQOI-2016-%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%88%E5%88%86%E6%B2%BB-%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3611【CQOI2016 Day1】不同的最小割 问题描述 学过图论的同学都知道最小割的概念：对于一个图，某个对图中节点的划分将图中所有节点分成两部分，如果节点s,t不在同一个部分中，则称这个划分是关于s,t的割。对于带权图来说，将所有顶点处在不同部分的权值相加所得到的定义为这个割的容量，而s,t的最小割指的是在关于s,t的个中容量最小的割。 而对冲刺NOI竞赛的选手而言，求带权图中两点的最小割已经不是什么难事。我们可以把视野放宽，考虑有N个点的无向连通图中所有点对的最小割容量，共能得到N(N-1)/2个数值。这些数值中互不相同的有多少个呢？这似乎是一个有趣的问题。 输入格式输入格式 输入文件第一行包含两个数N,M，表示点数和边数。 接下来M行，每行三个数u,v,w，表示点u和点v（从1开始标号）之间有条边权值为w。 输出格式 输出文件第一行为一个整数，表示个数。 样例输入 4 41 2 31 3 62 4 53 4 4 样例输出 3 提示 数据范围：​ 对于50%的数据，N≤200，M≤2000；​ 对于100%的数据，1≤N≤850，1≤M≤8500,1≤w≤100000​ 题意大概就是让任选点对(x,y)求他们的最小割，最后统计这些最小割中不同的有多少个。一个显然的想法是，我们可以求出所有的最小割然后统计。但是这样就需要$n^2$次SAP，显然要超时。这种时候，就可以使用分治最小割-最小割树的方法来求解了。 以下内容均针对无向图 首先，不同的最小割数量不超过n-1个（一个割将点的集合分成两个独立的点集，而最多可以分成n个点集）事实上，这些最小割构成一颗最小割树，构建过程就是每次选在同一个集合中的两点求最小割然后递归的求最小割，比如我们举个栗子 在这幅图中，我们先任选两个点比如(1,2)来求最小割，肉眼目测应该是10，并且将点集划分为｛1，3，4｝和｛2，5｝两个集合，我们用一条横线来表示这个最小割 显然，在两个集合中任取两个点，他们的最小割不超过10。然后我们求(2,5)的最小割，显然是11。之后求(1,4)的最小割，显然是12，这两次之后，同样用一条边来代表最小割，于是得到 最后求(3,4)的最小割，得到一颗完整的最小割树 注意到，以上的点的选择是可以任意选择的，得到这颗树具有一个厉害的性质，即任意两点的最小割等于这棵树上两点间路径经过的边的权值的最小值。注意连边必须是在所求最小割的两点间。 以下提供伪证，可作理解，已经懂了请忽略。 首先我们注意到，当我们求（a，b）的最小割C后，可以将集合划分成两个独立的集合S和T，那么连边的意义显然就是这两个集合中各取一个点x和点y，他们的最小割不会大于C，这是显然的。那么我们来考虑他们的最小割小于C的情况，根据假设我们可以画一个示意图 我们用一条线来代表一个割，两边分别是S集和T集。如果x，y的最小割D小于C，那么a点和b点必须位于D的同侧，否则C就不是a，b的最小割，同时x，y必须位于D的异侧，那么我们假设x，a，b位于D的同侧 也就是说，这个割D必然会在我们讨论T集合时被讨论到，他同时是b，y的最小割，因此我们会有y-b的一条边。 因此最后对S和T递归完成后，x，y之间的最小割D一定会被讨论到，因为如果没有被讨论到，说明存在一个较大的割将他们划分入了不同的集合，但显然这是可以递归的证明的。 总结一下，关键就在于如果划分了S集和T集，但存在一个更小的最小割，这个最小割割一定会是S集或T集中的两个点的最小割。 实际代码实现时，我们每次任求一个最小割，然后划分出S集和T集，更新S集和T集之间的最小割，然后递归处理S集和T集。注意的是，假设递归处理了S集，那么更新的时候也必须是对所有点进行更新，而划分却只需要划分S集内部的点。根据上文，在我们递归结束后，所得到的最小割一定不小于实际最小割，同时也不会大于实际的最小割，同时由于最后每个点是一个单独的集合，因此所有点对的最小割一定都被求出来了。当然，也可以使用连边的方式构造出最小割树。 接着，回到题目，显然就是个模板题了，只需要注意到本题本不需要求出最小割，只需要将每次求出的最小割的值加入一个set中，答案就是set的大小。 附代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;#define M 50000#define H 1234using namespace std;int n,m,A[H],B[H],C[H],cntb,cntc;int TOT=1,LA[M],NE[M],EN[M],G[M],F[M];int S,T,N,dis[H],cnt[H];bool vis[H];set&lt;int&gt;Q;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; G[TOT]=z; F[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int SAP(int u,int f)&#123; int i,tmp,d=0; if(u==T)return f; for(i=LA[u];i&gt;1;i=NE[i]) if(G[i]&amp;&amp;dis[u]==dis[EN[i]]+1) &#123; tmp=SAP(EN[i],min(G[i],f-d)); G[i]-=tmp; G[i^1]+=tmp; d+=tmp; if(d==f||dis[S]&gt;=n)return d; &#125; if(!--cnt[dis[u]])dis[S]=n; cnt[++dis[u]]++; return d;&#125;void DFS(int x)&#123; int i; vis[x]=1; for(i=LA[x];i&gt;1;i=NE[i]) if(G[i]&amp;&amp;(!vis[EN[i]]))DFS(EN[i]);&#125;void FZ(int l,int r)&#123; int i,j,flow=0,mid; if(l==r)return; S=A[l];T=A[r];cntb=cntc=0; memset(dis,0,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); for(i=2;i&lt;=TOT;i++)G[i]=F[i]; while(dis[S]&lt;n)flow+=SAP(S,1e9); Q.insert(flow); DFS(S); for(i=l;i&lt;=r;i++) if(vis[A[i]])B[++cntb]=A[i]; else C[++cntc]=A[i]; mid=l+cntb-1; for(i=1;i&lt;=cntb;i++)A[l+i-1]=B[i]; for(i=1;i&lt;=cntc;i++)A[mid+i]=C[i]; FZ(l,mid); FZ(mid+1,r);&#125;int main()&#123; int i,j,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,0); ADD(y,x,z);ADD(x,y,0); &#125; for(i=1;i&lt;=n;i++)A[i]=i; FZ(1,n); x=Q.size(); cout&lt;&lt;x;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小割树</category>
      </categories>
      <tags>
        <tag>最小割树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4040 (CQOI 2017) 小Q的表格（莫比乌斯反演+分块+递推+线性筛/欧拉函数+分块+线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4040-CQOI-2017-%E5%B0%8FQ%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E5%88%86%E5%9D%97-%E9%80%92%E6%8E%A8-%E7%BA%BF%E6%80%A7%E7%AD%9B-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E5%88%86%E5%9D%97-%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4040小Q 的表格 问题描述 题目给出了一个有规律的表格，因此我们先随便修改一个数找一下所有被修改的数之间有没有什么规律，很容易发现好像被修改的数的行号和列号的gcd是一样的，于是我们考虑证明，实际上我们的修改过程和辗转相减的过程是一样的，因此很容易得证。接着我们来考虑gcd一样的这些格子的数有什么特点，容易发现他们的倍数关系是固定的，等于行号列号乘积之商，所以我们用 $A[d]$ 表示 $(d,d)$ 这个格子的值，列出求和式$$Ans=\sum_{d=1}^k A[d] \sum_{i=1}^k \sum_{j=1}^k (gcd(i,j)==d) \frac{ij}{d^2}$$ 接下来就有两种做法了。 做法一： 上面的式子看起来很眼熟，于是我们将他变形$$Ans=\sum_{d=1}^k A[d] \sum_{i=1}^{\lfloor{\frac{k}{d}}\rfloor} \sum_{j=1}^{\lfloor{\frac{k}{d}}\rfloor}(gcd(i,j)==1) ij$$于是莫比乌斯反演一下，$$f(x)=\sum_{i=1}^{\lfloor{\frac{k}{d}}\rfloor} \sum_{j=1}^{\lfloor{\frac{k}{d}}\rfloor}(gcd(i,j)==x) ij$$ $$F(x)=\sum_{i=1}^{\lfloor{\frac{k}{d}}\rfloor} \sum_{j=1}^{\lfloor{\frac{k}{d}}\rfloor}(x|gcd(i,j)) ij$$ $$Ans=\sum_{d=1}^k A[d]\times f(1)=\sum_{d=1}^k A[d] \sum_{x=1}^{\lfloor{\frac{k}{d}}\rfloor} u(x)\times x^2\times [\frac{\lfloor\frac{k}{dx}\rfloor(\lfloor\frac{k}{dx}\rfloor+1)}{2}]^2$$ 现在，我们希望把A[d]后面的一坨解决掉，于是，我们令$$g(i)=\sum_{x=1}^{i} u(x)\times x^2\times[\frac{\lfloor\frac{i}{x}\rfloor(\lfloor\frac{i}{x}\rfloor+1)}{2}]^2$$ $$Ans=\sum_{d=1}^k A[d]\times g(\lfloor\frac{k}{d}\rfloor)$$ 现在我们发现，如果能预处理出$g(i)$的值，那么可以利用分块的方法在$O(\sqrt{n})$的复杂度内处理每一次询问，问题在于如何预处理，直接算显然不靠谱，我们考虑递推。可以发现，如果$\lfloor\frac{i}{x}\rfloor$和$\lfloor\frac{i-1}{x}\rfloor$是一样的，那么这一项就被减掉了，简单推到一下可以得到$$g(i)-g(i-1)=\sum_{x|i} u(x)\frac{i^3}{x}$$不妨令右边这一坨为$h(i)$,因此我们有$g(i)-g(i-1)=h(i)$然后$h(i)$显然是积性的，可以用线性筛搞出来，因此我们可以在$O(n)$的复杂度内搞出我们想要的$g(i)$，之后就可以愉快的分块处理了。 最后还需要注意，分块时我们需要$A[i]$的前缀和，然而用树状数组维护查询是$O(\log{n})$的，肯定要T，因此我们需要用到分块前缀和这种黑科技，它可以实现$O(\sqrt{n})$插入，$O(1)$查询，方法就是将前缀和数组分块，一般分成$\sqrt{n}$块，然后我们每次更新前缀和相当于将一个区间整体增加一个d，因此我们借鉴线段树的lazy思想，用一个数组记录下整块的更新，然后暴力更新零碎的部分，时间复杂度不超过$O(\sqrt{n})$，查询的时候只需要返回两个数组的和即可。 附上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define ll long long#define N 4444444using namespace std;const ll mod=1000000007LL;ll A[N],S[N],Q[N],sn,ssn,n,m;ll pri[N],G[N],F[N],tot;bool mark[N];ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;void Pretreat()&#123; ll i,j; for(i=1;i&lt;=n;i++) &#123; A[i]=i*i%mod; S[i]=(S[i-1]+A[i])%mod; &#125; F[1]=1;G[1]=1; for(i=2;i&lt;=n;i++) &#123; if(!mark[i])pri[++tot]=i,F[i]=i*i%mod*(i-1)%mod; for(j=1;j&lt;=tot&amp;&amp;pri[j]*i&lt;=n;j++) if(i%pri[j])mark[i*pri[j]]=1,F[i*pri[j]]=F[i]*F[pri[j]]%mod; else &#123;mark[i*pri[j]]=1;F[i*pri[j]]=F[i]*(pri[j]*pri[j]%mod)%mod*pri[j]%mod;&#125; G[i]=(G[i-1]+F[i])%mod; &#125;&#125;void MD(ll x,ll d)&#123; ll i,l=(x-1)/sn+1,r=l*sn; for(i=x;i&lt;=r&amp;&amp;i&lt;=n;i++)S[i]=(S[i]+d)%mod; for(i=l+1;i&lt;=ssn;i++)Q[i]=(Q[i]+d)%mod;&#125;ll GS(ll x)&#123; ll l=(x-1)/sn+1; if(x==0)return 0; return (S[x]+Q[l])%mod;&#125;int main()&#123; ll i,j,k,t,a,b,x,y,ans; scanf("%lld%lld",&amp;m,&amp;n); Pretreat();sn=sqrt(n);ssn=(n-1)/sn+1; for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;x,&amp;k); y=gcd(a,b); x=x/(a*b/y/y)%mod; MD(y,x-A[y]); A[y]=x;ans=0; for(j=1;j&lt;=k;j=t+1) &#123; t=k/(k/j); ans=(ans+G[k/j]*(GS(t)-GS(j-1))%mod)%mod; &#125; printf("%lld\n",(ans+mod)%mod); &#125;&#125; 做法二： 做法二非常的厉害，我们先回顾一下做法一中$$Ans=\sum_{d=1}^k A[d] \sum_{i=1}^{\lfloor{\frac{k}{d}}\rfloor} \sum_{j=1}^{\lfloor{\frac{k}{d}}\rfloor}(gcd(i,j)==1) ij$$然后，厉害的来了，根据欧拉函数的性质，我们有$$\sum_{i=1}^{n}i[gcd(i,n)==1]=\frac{n\varphi(n)}{2}$$注意到$i$和$j$是相互独立的，于是套用公式，注意到上面公式中$i$是小于$n$的，但是我们要求的式子中，$i$和$j$并没有大小关系，于是需要乘上2，于是我们可以得到$$Ans=\sum_{d=1}^{k}A(d)\sum_{i=1}^{\lfloor{\frac{k}{d}}\rfloor}i^{2}\varphi(i)$$于是，后面一坨显然是积性的，之后同样分块处理即可。关于这个公式的证明，注意到如果a和n互质，那么n-a和n也一定互质，因为假设p同时整除n和n-a，那么他一定整除a，矛盾。 以下代码引用自F.F.Chopin，同时不得不说，做法二比做法一跑得要快，因为预处理取模较少，更快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;cmath&gt;#define LL long longconst int MAXN=4000005;const LL mod=1000000007;using namespace std;LL m,n,prime[MAXN&gt;&gt;3],phi[MAXN],tot,g[MAXN],w[MAXN],f[MAXN],tg[MAXN];bool ntpr[MAXN];LL a,b,x,k,d,nn;LL gcd(LL a,LL b)&#123; if(!b)return a; return gcd(b,a%b);&#125;void getphi(int n)&#123; phi[1]=g[1]=f[1]=w[1]=1; for(LL i=2; i&lt;=n; i++) &#123; if(!ntpr[i]) prime[++tot]=i,phi[i]=i-1; for(int j=1; j&lt;=tot&amp;&amp;i*prime[j]&lt;=n; j++) &#123; ntpr[i*prime[j]]=1; if(!(i%prime[j])) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; f[i]=i*i%mod; g[i]=(g[i-1]+f[i]*phi[i]%mod)%mod; w[i]=(w[i-1]+f[i])%mod; &#125;&#125;void calc(LL k)&#123; LL ans=0,i,ls; for(i=1; i&lt;=k; i=ls+1) &#123; ls=k/(k/i); ans=((w[ls]-w[i-1]+tg[(ls+nn-1)/nn]-tg[(i+nn-2)/nn])*g[k/i]%mod+ans)%mod; &#125; printf("%lld\n",(ans+mod)%mod);&#125;int main()&#123; scanf("%lld%lld",&amp;m,&amp;n); getphi(n); nn=sqrt(n); LL c,v; while(m--) &#123; scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;x,&amp;k); d=gcd(a,b); c=f[d],f[d]=x/(a/d)/(b/d)%mod; for(int i=d; i&lt;=(nn-1+d)/nn*nn; i++) w[i]=(w[i]+f[d]-c)%mod; for(int i=(d+nn-1)/nn+1; i&lt;=(n+nn-1)/nn; i++) tg[i]=(tg[i]+f[d]-c)%mod; calc(k); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>分治法</category>
        <category>分块</category>
        <category>递推</category>
        <category>莫比乌斯反演</category>
        <category>欧拉函数</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>递推</tag>
        <tag>莫比乌斯反演</tag>
        <tag>线性筛</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4042 (CQOI 2017) 老C的方块（最小割+染色）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4042-CQOI-2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%9F%93%E8%89%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4042老C的方块 问题描述 此题比较明显可以想到图论，由于是经典的棋盘问题，我们观察四种讨厌的形状，发现这四种形状有一个共同特点，即都可以看成以特殊边为邻边的两个方块各自再连上一个方块，然后我们发现，特殊边的分布刚好是配合这个规律的，于是我们将棋盘染色 染色很丑陋，因为是我故意的。简单说一下，我们将格子分成4类，分别是四种颜色，我们发现，如果一个图形是讨厌的，那么一定满足这个图形是黄-黑-白-蓝，或者黄-白-黑-蓝，于是构图的方法也就出来了我们新建一个源点S，和一个汇点T。从S出发连到黄色格子，容量是他的费用。从黄色格子连到他所相邻的黑色和白色格子，容量无穷大。相邻黑白格子之间连双向边，容量是黑白格子中费用较小的一个。从黑白格子出发，连到相邻的蓝色格子，容量无穷大。从蓝色格子出发，连到汇点T。最后求出上图的最小割即可。 附上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define ll long long#define N 4234567using namespace std;struct node&#123;ll xi,yi,wi,id;&#125;;const ll ct=1000000LL;ll S,T,C,R,n;map&lt;ll,node&gt;Q;node P[N];ll TOT=1,NE[N],EN[N],G[N],LA[N],dis[N],cnt[N];void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; G[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void A1(ll k)&#123; ll t;node tmp; ADD(S,k,P[k].wi);ADD(k,S,0); t=P[k].xi*ct+ct+P[k].yi; if(Q.count(t)) &#123; tmp=Q[t]; ADD(k,tmp.id,1e18); ADD(tmp.id,k,0); &#125; t-=2*ct; if(Q.count(t)) &#123; tmp=Q[t]; ADD(k,tmp.id,1e18); ADD(tmp.id,k,0); &#125; if(P[k].xi&amp;1) &#123; t=P[k].xi*ct+P[k].yi+1; if(Q.count(t)) &#123; tmp=Q[t]; ADD(k,tmp.id,1e18); ADD(tmp.id,k,0); &#125; &#125; else &#123; t=P[k].xi*ct+P[k].yi-1; if(Q.count(t)) &#123; tmp=Q[t]; ADD(k,tmp.id,1e18); ADD(tmp.id,k,0); &#125; &#125;&#125;void A2(ll k)&#123; ll t;node tmp; t=P[k].xi*ct+P[k].yi+1; if(Q.count(t)) &#123; tmp=Q[t]; ADD(k,tmp.id,min(P[k].wi,tmp.wi)); ADD(tmp.id,k,0); ADD(tmp.id,k,min(P[k].wi,tmp.wi)); ADD(k,tmp.id,0); &#125;&#125;void A3(ll k)&#123; ll t;node tmp; ADD(k,T,P[k].wi);ADD(T,k,0); t=P[k].xi*ct+ct+P[k].yi; if(Q.count(t)) &#123; tmp=Q[t]; ADD(tmp.id,k,1e18); ADD(k,tmp.id,0); &#125; t-=2*ct; if(Q.count(t)) &#123; tmp=Q[t]; ADD(tmp.id,k,1e18); ADD(k,tmp.id,0); &#125; if(!(P[k].xi&amp;1)) &#123; t=P[k].xi*ct+P[k].yi+1; if(Q.count(t)) &#123; tmp=Q[t]; ADD(tmp.id,k,1e18); ADD(k,tmp.id,0); &#125; &#125; else &#123; t=P[k].xi*ct+P[k].yi-1; if(Q.count(t)) &#123; tmp=Q[t]; ADD(tmp.id,k,1e18); ADD(k,tmp.id,0); &#125; &#125;&#125;ll tp(ll x,ll y)&#123; ll p=y&amp;3; if(x&amp;1)return p+1; if(p==0)return 3; if(p==1)return 1; if(p==2)return 4; if(p==3)return 2;&#125;void edge()&#123; ll i,t; for(i=1;i&lt;=n;i++) &#123; t=tp(P[i].xi,P[i].yi); if(t==1)A1(i); if(t==2)A2(i); if(t==4)A3(i); &#125;&#125;ll SAP(ll u,ll f)&#123; ll i,v,d=0,tmp; if(u==T)return f; for(i=LA[u];i&gt;1;i=NE[i]) &#123; v=EN[i]; if(G[i]&amp;&amp;dis[u]==dis[v]+1) &#123; tmp=SAP(v,min(f-d,G[i])); G[i]-=tmp; G[i^1]+=tmp; d+=tmp; if(f==d||dis[S]&gt;=n+2)return d; &#125; &#125; if(!--cnt[dis[u]])dis[S]=n+2; cnt[++dis[u]]++; return d;&#125;int main()&#123; ll i,x,y,w,ans=0;node tmp; scanf("%lld%lld%lld",&amp;C,&amp;R,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%lld%lld%lld",&amp;y,&amp;x,&amp;w); tmp.id=i;tmp.wi=w; P[i].xi=x;P[i].yi=y;P[i].wi=w;P[i].id=i; Q[x*ct+y]=tmp; &#125; S=n+1;T=S+1;edge(); while(dis[S]&lt;n+2)ans+=SAP(S,1e18); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4043 (CQOI 2017) 老C的键盘 （树形DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4043-CQOI-2017-%E8%80%81C%E7%9A%84%E9%94%AE%E7%9B%98-%EF%BC%88%E6%A0%91%E5%BD%A2DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4043老C的键盘 此题由于给出的字符串，很容易想到变成一颗树，于是容易想到树形DP。 注意到将1-n分配到一棵树的时候，数的具体值是没有意义的，因此每一次往下分都可以认为是将1-size的排列分到这颗子树上。 因此，为了计算方案数，我们需要确定根的取值，再确定将哪些数分到左子树上，另一些分到右子树上，然后组合数乘一下，再乘上左子树和右子树各自的DP值。 注意到题目给出的限制是关于儿子和父亲的大小关系，因此我们预处理时，可以处理出在子树中有多少个与根的大小关系确定的数，由此确定根的取值范围，然后枚举根的取值，再枚举分配到子树上有多少个小于根的数或大于根的数。 最后，此题的重点，注意到由于子树的根和我当前讨论的这棵树的根的大小关系是确定的，并且讨论时确定了有多少个数小于根，因此相当于在子树中去分配数的时候，子树的根的取值范围是被限定了的。举个栗子，如果已知根的左儿子大于根，同时当前左子树分配了k个小于根的数，那么左儿子在左子树中分配数时显然只能取k+1 - size，因此我们需要增加一维用来限制根的取值。 总结一下，我们用$F[x][y]$来表示以x为根的子树，将1-size[x]这些数分配到子树上，并且x取y的方案数。 转移的时候，因为x的取值是定的，因此枚举将1到y-1这些数分k个给左子树，再用y+1到size补足，配合组合数，乘上左右子树的根的取值满足上面要求的dp值，注意转移的边界，同时需要用前缀和优化。具体转移方程太烦琐，可以参看代码。（个人为了图方便，DP方程是针对不同的大小关系分开写的） 最后，我觉得这个dp过程中取模居然会出现负数实在有毒。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 233using namespace std;string s;ll mod=1000000007LL;ll n,C[N][N],F[N][N],G[N][N],ty[N],ls[N],rs[N],lc[N],rc[N],Sma[N],Big[N],size[N];void DFS(ll x)&#123; size[x]=1; if(ls[x]) &#123; DFS(ls[x]); size[x]+=size[ls[x]]; if(ty[ls[x]]==-1) &#123; Sma[x]+=1+Sma[ls[x]]; lc[x]=1+Sma[ls[x]]; &#125; else &#123; Big[x]+=1+Big[ls[x]]; lc[x]=1+Big[ls[x]]; &#125; &#125; if(rs[x]) &#123; DFS(rs[x]); size[x]+=size[rs[x]]; if(ty[rs[x]]==-1) &#123; Sma[x]+=1+Sma[rs[x]]; rc[x]=1+Sma[rs[x]]; &#125; else &#123; Big[x]+=1+Big[rs[x]]; rc[x]=1+Big[rs[x]]; &#125; &#125;&#125;void DP(ll x,ll y)&#123; if(ls[x])DP(ls[x],size[ls[x]]); if(rs[x])DP(rs[x],size[rs[x]]); ll i,j,k,t,p,q,ans; for(k=Sma[x]+1;k&lt;=y-Big[x];k++) &#123; ans=0; if(!rs[x])ans=1; if(ty[ls[x]]==-1&amp;&amp;ty[rs[x]]==-1) &#123; for(i=max(lc[x],size[ls[x]]-y+k);i&lt;=size[ls[x]]&amp;&amp;i&lt;=k-1-rc[x];i++) ans=(ans+G[ls[x]][i]*G[rs[x]][k-1-i]%mod*C[k-1][i]%mod*C[y-k][size[ls[x]]-i]%mod)%mod; &#125; if(ty[ls[x]]==1&amp;&amp;ty[rs[x]]==1) &#123; for(i=max(lc[x],size[ls[x]]-k+1);i&lt;=size[ls[x]]&amp;&amp;i&lt;=y-k-rc[x];i++) ans=(ans+(G[ls[x]][size[ls[x]]]-G[ls[x]][size[ls[x]]-i])*(G[rs[x]][size[rs[x]]]-G[rs[x]][size[rs[x]]-y+k+i])%mod*C[y-k][i]%mod*C[k-1][size[ls[x]]-i]%mod)%mod; &#125; if(ty[ls[x]]==-1&amp;&amp;ty[rs[x]]==1) &#123; for(i=max(lc[x],size[ls[x]]-y+k+rc[x]);i&lt;=size[ls[x]]&amp;&amp;i&lt;k;i++) ans=(ans+G[ls[x]][i]*(G[rs[x]][size[rs[x]]]-G[rs[x]][k-i-1])%mod*C[k-1][i]%mod*C[y-k][size[ls[x]]-i]%mod)%mod; &#125; F[x][k]=ans; &#125; for(i=1;i&lt;=y;i++)G[x][i]=(G[x][i-1]+F[x][i])%mod;&#125;int main()&#123; ll i,j; scanf("%lld",&amp;n);cin&gt;&gt;s;s=" "+s; for(i=0;i&lt;=n;i++)C[i][0]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; for(i=2;i&lt;=n;i++) &#123; if(s[i]=='&lt;')ty[i]=1; else ty[i]=-1; if(ls[i/2])rs[i/2]=i; else ls[i/2]=i; &#125; for(i=1;i&lt;=n;i++)if(ls[i]&amp;&amp;rs[i]&amp;&amp;ty[ls[i]]&gt;ty[rs[i]])swap(ls[i],rs[i]); DFS(1);DP(1,size[1]); cout&lt;&lt;(G[1][n]+mod)%mod;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #425 (Div. 2) C-Strange Radiation（二分答案）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-Round-425-Div-2-C-Strange-Radiation%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C. Strange Radiation n people are standing on a coordinate axis in points with positive integer coordinates strictly less than 106. For each person we know in which direction (left or right) he is facing, and his maximum speed. You can put a bomb in some point with non-negative integer coordinate, and blow it up. At this moment all people will start running with their maximum speed in the direction they are facing. Also, two strange rays will start propagating from the bomb with speed s: one to the right, and one to the left. Of course, the speed s is strictly greater than people&apos;s maximum speed. The rays are strange because if at any moment the position and the direction of movement of some ray and some person coincide, then the speed of the person immediately increases by the speed of the ray. You need to place the bomb is such a point that the minimum time moment in which there is a person that has run through point 0, and there is a person that has run through point 10^6, is as small as possible. In other words, find the minimum time moment t such that there is a point you can place the bomb to so that at time moment t some person has run through 0, and some person has run through point 10^6. Input The first line contains two integers n and s (2 ≤ n ≤ 10^5, 2 ≤ s ≤ 10^6) — the number of people and the rays&apos; speed. The next n lines contain the description of people. The i-th of these lines contains three integers xi, vi and ti (0 &lt; xi &lt; 10^6, 1 ≤ vi &lt; s, 1 ≤ ti ≤ 2) — the coordinate of the i-th person on the line, his maximum speed and the direction he will run to (1 is to the left, i.e. in the direction of coordinate decrease, 2 is to the right, i.e. in the direction of coordinate increase), respectively. It is guaranteed that the points 0 and 10^6 will be reached independently of the bomb&apos;s position. Output Print the minimum time needed for both points 0 and 10^6 to be reached. Your answer is considered correct if its absolute or relative error doesn&apos;t exceed 10 - 6. Namely, if your answer is a, and the jury&apos;s answer is b, then your answer is accepted, if . Examples input 2 999 400000 1 2 500000 1 1 output 500000.000000000000000000000000000000 input 2 1000 400000 500 1 600000 500 2 output 400.000000000000000000000000000000 Note In the first example, it is optimal to place the bomb at a point with a coordinate of 400000. Then at time 0, the speed of the first person becomes 1000 and he reaches the point 106 at the time 600. The bomb will not affect on the second person, and he will reach the 0 point at the time 500000. In the second example, it is optimal to place the bomb at the point 500000. The rays will catch up with both people at the time 200. At this time moment, the first is at the point with a coordinate of 300000, and the second is at the point with a coordinate of 700000. Their speed will become 1500 and at the time 400 they will simultaneously run through points 0 and 10^6. 题目大意： 有一根0-10^6的数轴，上面有一些面朝左边或者右边的人，每个人都在一个整数位置，并且有一个固定的速度。 现在可以在数轴上任意一整数位置放一个炸弹，炸弹爆炸后，所有人同时以固定的速度向面朝的方向跑，同时炸弹爆炸处会出现一种奇怪的射线，以速度s同时向左边和右边传播，如果射线超过了一个人，这个人的速度会增加s，问炸弹放在哪里可以使得同时存在到达了0点和10^6点的人的时间最小，求最小时间。 此题比较简单，二分答案即可。对时间二分，然后判断是否可行。判断时，枚举每一个向左跑的人，算出为了使这个人在给定时间内到达0点，炸弹能放的位置集合，然后枚举每一个向右跑的人，同样算出到达10^6点的炸弹位置集合，把所有集合交起来，如果不为空就是可行。注意到炸弹只能放在整数点，所以要注意取整。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 1234567using namespace std;struct node&#123;double x,v;&#125;;node L[N],R[N];int n,lcnt,rcnt;double s,EN=1000000;bool ok(double t)&#123; int i,j,k;bool f=0; double tmp; int LL=1e6,RR=0; for(i=1;i&lt;=lcnt;i++) &#123; if(L[i].x==0||(L[i].v!=0&amp;&amp;L[i].x/L[i].v&lt;=t))&#123;f=1;LL=0;RR=EN;break;&#125; if(L[i].x/(L[i].v+s)&gt;t)continue; tmp=(t*(s*s-L[i].v*L[i].v)+L[i].v*L[i].x)/s; RR=max(RR,int(floor(tmp))); LL=min(LL,int(ceil(L[i].x))); f=1; &#125; if(!f)return 0; for(i=1;i&lt;=rcnt;i++) &#123; if(R[i].x&lt;LL&amp;&amp;(R[i].v!=0&amp;&amp;(EN-R[i].x)/R[i].v&gt;t))continue; if(R[i].x==EN||(R[i].v!=0&amp;&amp;(EN-R[i].x)/R[i].v&lt;=t))return 1; if((EN-R[i].x)/(R[i].v+s)&gt;t)continue; if(RR&gt;R[i].x&amp;&amp;LL&lt;R[i].x)return 1; tmp=(R[i].x-RR)/(s-R[i].v); tmp=(EN-R[i].x-tmp*R[i].v)/(s+R[i].v)+tmp; if(tmp&lt;=t)return 1; &#125; return 0;&#125;void EF(double l,double r)&#123; while(r-l&gt;=0.0000000001) &#123; double mid=(l+r)/2; if(ok(mid))r=mid; else l=mid; &#125; printf("%.10lf",l);&#125;int main()&#123; double x,y;int i,j,k; scanf("%d%lf",&amp;n,&amp;s); for(i=1;i&lt;=n;i++) &#123; scanf("%lf%lf%d",&amp;x,&amp;y,&amp;k); if(k==1)&#123;++lcnt;L[lcnt].x=x;L[lcnt].v=y;&#125; else&#123;++rcnt;R[rcnt].x=x;R[rcnt].v=y;&#125; &#125; EF(0,1000000);&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #425 (Div. 2) E-Vasya and Shifts （高斯消元）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-Round-425-Div-2-E-Vasya-and-Shifts-%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Vasya and Shifts Vasya has a set of 4n strings of equal length, consisting of lowercase English letters &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; and &quot;e&quot;. Moreover, the set is split into n groups of 4 equal strings each. Vasya also has one special string a of the same length, consisting of letters &quot;a&quot; only. Vasya wants to obtain from string a some fixed string b, in order to do this, he can use the strings from his set in any order. When he uses some string x, each of the letters in string a replaces with the next letter in alphabet as many times as the alphabet position, counting from zero, of the corresponding letter in string x. Within this process the next letter in alphabet after &quot;e&quot; is &quot;a&quot;. For example, if some letter in a equals &quot;b&quot;, and the letter on the same position in x equals &quot;c&quot;, then the letter in a becomes equal &quot;d&quot;, because &quot;c&quot; is the second alphabet letter, counting from zero. If some letter in a equals &quot;e&quot;, and on the same position in x is &quot;d&quot;, then the letter in a becomes &quot;c&quot;. For example, if the string a equals &quot;abcde&quot;, and string x equals &quot;baddc&quot;, then a becomes &quot;bbabb&quot;. A used string disappears, but Vasya can use equal strings several times. Vasya wants to know for q given strings b, how many ways there are to obtain from the string a string b using the given set of 4n strings? Two ways are different if the number of strings used from some group of 4 strings is different. Help Vasya compute the answers for these questions modulo 109 + 7. Input The first line contains two integers n and m (1 ≤ n, m ≤ 500) — the number of groups of four strings in the set, and the length of all strings. Each of the next n lines contains a string s of length m, consisting of lowercase English letters &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; and &quot;e&quot;. This means that there is a group of four strings equal to s. The next line contains single integer q (1 ≤ q ≤ 300) — the number of strings b Vasya is interested in. Each of the next q strings contains a string b of length m, consisting of lowercase English letters &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; and &quot;e&quot; — a string Vasya is interested in. Output For each string Vasya is interested in print the number of ways to obtain it from string a, modulo 10^9 + 7. Examples​ input 1 1 b 2 a e output 1 1 input 2 4 aaaa bbbb 1 cccc output 5 Note​ In the first example, we have 4 strings “b”. Then we have the only way for each string b: select 0 strings “b” to get “a” and select 4 strings “b” to get “e”, respectively. So, we have 1 way for each request. In the second example, note that the choice of the string &quot;aaaa&quot; does not change anything, that is we can choose any amount of it (from 0 to 4, it&apos;s 5 different ways) and we have to select the line &quot;bbbb&quot; 2 times, since other variants do not fit. We get that we have 5 ways for the request. 题目大意 n个长度为m的串，每个串最多使用4次，每个串只含a,b,c,d,e。 a等价于0，b等价于1，以此类推，对串加和等价于每个位置单独相加，然后对5取模。 给出q次询问，问用这n个串共有多少种不同的方式得到给出的串。 此题的字母实际就是数字，因此我们很容易构造方程，对字符串的每一位列一个方程，目标串的对应位置就是方程的常数项，每一项前面的系数就等于对应串对应位置的数字，然后x表示这个串的使用次数。 因为每一个x不超过4，因此题目等价于在模5意义下求解线性方程组。高斯消元直接上即可。 注意到高斯消元的复杂度是$n^3$，而$q\times n^3$是不能接受的。注意到每次高斯消元时，方程的左边是一样的，只有常数项不一样，因此我们可以提前将所有串读进来，同时解q个方程组即可。具体可见代码。复杂度$n^2\times (n+q)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 666using namespace std;int n,m,q,G[N][N],R[N][N];char s[N][N];ll QM(ll a,ll b,ll c)&#123; a%=c;ll ans=1; while(b) &#123; if(b&amp;1)ans=ans*a%c; b&gt;&gt;=1; a=a*a%c; &#125; return ans;&#125;void Gauss(int row,int col)&#123; int i,j,k,MR,x,y,ta,tb; for(x=1,y=1;x&lt;=row&amp;&amp;y&lt;col;x++,y++) &#123; MR=x; for(i=x+1;i&lt;=row;i++) if(abs(G[i][y])&gt;abs(G[MR][y]))MR=i; if(MR!=x) &#123; for(i=1;i&lt;col;i++)swap(G[x][i],G[MR][i]); for(i=1;i&lt;=q;i++)swap(R[i][x],R[i][MR]); &#125; if(!G[x][y])&#123;x--;continue;&#125; for(i=x+1;i&lt;=row;i++) if(G[i][y]) &#123; ta=G[x][y];tb=G[i][y]; for(j=y;j&lt;col;j++)G[i][j]=(G[i][j]*ta-G[x][j]*tb)%5; for(j=1;j&lt;=q;j++)R[j][i]=(R[j][i]*ta-R[j][x]*tb)%5; &#125; &#125; ll tmp=col-x;bool f; if(tmp)tmp=QM(5,tmp,1000000007); else tmp=1; for(i=1;i&lt;=q;i++) &#123; f=1; for(j=x;j&lt;=row;j++)if(R[i][j])&#123;f=0;break;&#125; if(f)printf("%I64d\n",tmp); else printf("0\n"); &#125;&#125;int main()&#123; int i,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%s",&amp;s[i][1]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)G[j][i]=s[i][j]-'a'; scanf("%d",&amp;q); for(i=1;i&lt;=q;i++)scanf("%s",&amp;s[i][1]); for(i=1;i&lt;=q;i++) for(j=1;j&lt;=m;j++)R[i][j]=s[i][j]-'a'; Gauss(m,n+1);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #426 (Div. 2) E-Ever-Hungry Krakozyabra （爆搜）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-Round-426-Div-2-E-Ever-Hungry-Krakozyabra-%EF%BC%88%E7%88%86%E6%90%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[E. Ever-Hungry Krakozyabra Recently, a wild Krakozyabra appeared at Jelly Castle. It is, truth to be said, always eager to have something for dinner. Its favorite meal is natural numbers (typically served with honey sauce), or, to be more precise, the zeros in their corresponding decimal representations. As for other digits, Krakozyabra dislikes them; moreover, they often cause it indigestion! So, as a necessary precaution, Krakozyabra prefers to sort the digits of a number in non-descending order before proceeding to feast. Then, the leading zeros of the resulting number are eaten and the remaining part is discarded as an inedible tail. For example, if Krakozyabra is to have the number 57040 for dinner, its inedible tail would be the number 457. Slastyona is not really fond of the idea of Krakozyabra living in her castle. Hovewer, her natural hospitality prevents her from leaving her guest without food. Slastyona has a range of natural numbers from L to R, which she is going to feed the guest with. Help her determine how many distinct inedible tails are going to be discarded by Krakozyabra by the end of the dinner. Input In the first and only string, the numbers L and R are given – the boundaries of the range (1 ≤ L ≤ R ≤ 10^18). Output Output the sole number – the answer for the problem. Examples input 1 10 output 9 input 40 57 output 17 input 157 165 output 题目大意 给定区间[L,R]，求区间中的数去掉这个数中的0之后，把这个数各个数位上的数从小到大排列后，总共有多少个不同的排列情况。 此题看着很神，然而我们考虑一下发现，最多有18位，每个位置上只能是1-9，并且必须按顺序排列，因此只需要考虑1-9的末位放在哪里，也就是最多只有$C_{18+9}^{9}$中可能组合，大概是4686824种。因此我们可以考虑暴搜，枚举每一种可能，然后检验是否可以通过增加一些0的方式来使得当前的数被放到[L,R]区间中。 那么我们需要一个快速的验证。我们用B[x]表示当前数中数字x的个数，用L[i]和R[i]来表示L和R从高到低第i位的数字。那么，我们枚举L和R的每一位来讨论。 我们用（x,lf,rf）来表示枚举到第x位，lf表示当前构造出的数是否和L的1-x-1位完全相等，rf同理。分三种情况case 1. lf==1&amp;&amp;rf==1 这说明当前构造的数和L,R的前x-1位完全相等，那么我们令a=L[x],b=R[x] 如果a==b，那么直接进入（x+1，lf，rf） 如果a&lt;b&amp;&amp;在[a+1,b-1]内存在一个数c使得B[c]&gt;0,那么我们只需要令当前位置等于c，那么后面位置可以随意排列，显然可行。 如果a&lt;b&amp;&amp;a和b之间不存在c满足上述条件，那么如果B[a]&gt;0进入（x+1，1，0）和如果B[b]&gt;0进入（x+1，0，1）。 case 2.lf==1&amp;&amp;rf==0 这说明当前无论填入什么数字，构造出的数一定小于R。同样令a=L[x]。 如果在[a+1,9]内存在一个c使得B[c]&gt;0，那么显然可行。 否则如果B[a]&gt;0进入（x+1，1，0） case 3.lf==0&amp;&amp;rf==1 同case 2处理。 于是，观察复杂度可发现，复杂度大概和R的位数差不多，因为只有当lf==1&amp;&amp;rf==1使才会产生不同情况。而显然这个不同情况往下就是单链的搜索树。 于是总复杂度$C_{K+9}^{9}*K$，K是R的位数。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int L[20],R[20],B[10],A[10],ans,n;bool ok(int l,int r)&#123; if(l&gt;r)return 0; for(int i=l;i&lt;=r;i++) if(B[i])return 1; return 0;&#125;bool judge(int x,int lf,int rf)&#123; if(x&gt;n)return 1; int l=L[x],r=R[x]; if(lf&amp;&amp;rf) &#123; if(l==r) &#123; if(B[l]) &#123; B[l]--; if(judge(x+1,1,1))return 1; B[l]++; &#125; return 0; &#125; if(ok(l+1,r-1))return 1; if(B[l]) &#123; B[l]--; if(judge(x+1,1,0))return 1; B[l]++; &#125; if(B[r]) &#123; B[r]--; if(judge(x+1,0,1))return 1; B[r]++; &#125; return 0; &#125; else if(lf) &#123; if(ok(l+1,9))return 1; if(B[l]) &#123; B[l]--; if(judge(x+1,1,0))return 1; B[l]++; &#125; return 0; &#125; else if(rf) &#123; if(ok(0,r-1))return 1; if(B[r]) &#123; B[r]--; if(judge(x+1,0,1))return 1; B[r]++; &#125; return 0; &#125; return 0;&#125;void Work(int x,int sum)&#123; if(x==10) &#123; memcpy(B,A,sizeof(A)); B[0]+=sum; if(judge(1,1,1))ans++; return; &#125; for(int i=0;i&lt;=sum;i++) &#123; A[x]=i; Work(x+1,sum-i); &#125;&#125;int main()&#123; int i; long long x,y,t; cin&gt;&gt;x&gt;&gt;y;t=y; while(t)&#123;t/=10;n++;&#125; for(i=n;i&gt;=1;i--)R[i]=y%10,y/=10; for(i=n;i&gt;=1;i--)L[i]=x%10,x/=10; Work(1,n); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #427 (Div. 2) D-Palindromic characteristics （回文串，暴力）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-Round-427-Div-2-D-Palindromic-characteristics-%EF%BC%88%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%8C%E6%9A%B4%E5%8A%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[D. Palindromic characteristics Palindromic characteristics of string s with length |s| is a sequence of |s| integers, where k-th number is the total number of non-empty substrings of s which are k-palindromes. A string is 1-palindrome if and only if it reads the same backward as forward. A string is k-palindrome (k &gt; 1) if and only if: Its left half equals to its right half. Its left and right halfs are non-empty (k - 1)-palindromes. The left half of string t is its prefix of length ⌊|t| / 2⌋, and right half — the suffix of the same length. ⌊|t| / 2⌋ denotes the length of string t divided by 2, rounded down. Note that each substring is counted as many times as it appears in the string. For example, in the string &quot;aaa&quot; the substring &quot;a&quot; appears 3 times. Input The first line contains the string s (1 ≤ |s| ≤ 5000) consisting of lowercase English letters. Output Print |s| integers — palindromic characteristics of string s. Examples input abba output 6 1 0 0 input abacaba output 12 4 1 0 0 0 0 Note In the first example 1-palindromes are substring «a», «b», «b», «a», «bb», «abba», the substring «bb» is 2-palindrome. There are no 3- and 4-palindromes here. 题目大意 找回文串，一个k阶回文串的定义是他的左边一半是一个k-1阶回文串。输出1-|s|阶回文串的个数。 注意题目要求，一个k阶回文串也会在k-1阶里面计数，但这问题不大。 首先用通用技巧，在每两个字符之间增加一个字符，来避免讨论奇偶。然后为了方便的判断阶数，我们可以暴力的开一个数组，来记录以L为起点以R为终点的字符串的阶数，非回文串为0，于是我们只需要枚举中间数，向两边拓展，然后阶数就等于一边的阶数加一即可。注意不要把前面增加的字符算进来。具体可以参见代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll cnt[12345],i,j,k,l,p,x,y,tmp,n;string s;char A[12345];short Q[10005][10005];int main()&#123; cin&gt;&gt;s;n=s.length();s=" "+s; for(i=1;i&lt;=n;i++) &#123; A[2*i-1]=s[i]; A[2*i]='#'; &#125; cnt[1]+=n; n=2*n-1; for(i=1;i&lt;=n;i++) if(A[i]!='#')Q[i][i]=1; for(k=1;k&lt;=n;k++) &#123; for(l=1;k-l&gt;=1&amp;&amp;k+l&lt;=n;l++) &#123; if(A[k-l]=='#')continue; i=k-l;j=k+l; if(A[i]!=A[j])break; if(A[k-1]=='#')x=k-2; else x=k-1; tmp=Q[i][x]+1; cnt[tmp]++; Q[i][j]=tmp; &#125; &#125; for(i=s.length()-1;i&gt;0;i--)cnt[i]+=cnt[i+1]; for(i=1;i&lt;s.length();i++)printf("%I64d ",cnt[i]);&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #427 (Div. 2) F-Roads in the Kingdom （基环树）]]></title>
    <url>%2F2018%2F03%2F15%2FCodeforces-Round-427-Div-2-F-Roads-in-the-Kingdom-%EF%BC%88%E5%9F%BA%E7%8E%AF%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[F. Roads in the Kingdom In the Kingdom K., there are n towns numbered with integers from 1 to n. The towns are connected by n bi-directional roads numbered with integers from 1 to n. The i-th road connects the towns ui and vi and its length is li. There is no more than one road between two towns. Also, there are no roads that connect the towns with itself. Let&apos;s call the inconvenience of the roads the maximum of the shortest distances between all pairs of towns. Because of lack of money, it was decided to close down one of the roads so that after its removal it is still possible to reach any town from any other. You have to find the minimum possible inconvenience of the roads after closing down one of the roads. Input The first line contains the integer n (3 ≤ n ≤ 2·105) — the number of towns and roads. The next n lines contain the roads description. The i-th from these lines contains three integers ui, vi, li (1 ≤ ui, vi ≤ n, 1 ≤ li ≤ 109) — the numbers of towns connected by the i-th road and the length of the i-th road. No road connects a town to itself, no two roads connect the same towns. It&apos;s guaranteed that it&apos;s always possible to close down one of the roads so that all the towns are still reachable from each other. Output Print a single integer — the minimum possible inconvenience of the roads after the refusal from one of the roads. Examples input 3 1 2 4 2 3 5 1 3 1 output 5 input 5 2 3 7 3 1 9 4 1 8 3 5 4 4 5 5 output 18 题目大意 给定一个有n个节点和n条边的图，任意两点相互联通，无自环，无重边，求删掉一条边形成的树的直径的最小值。 易知所给的图中仅有一个环，即为一颗基环树。容易发现只能删环上的边。 显然问题的关键在于删边之后如何快速求出直径。 考虑在环上来讨论，将环上的边编号，下文中均为从 $1$ 到 $m$ 。 可以将直径的来源分为两类，一类为经过环，另一类为不经过环。 首先考虑环上每个节点环外挂着的树的部分，这一部分不会发生变化，可以先求出树的直径。 考虑经过环的部分，设每个点与其环外的树中点的最大距离为 $d_i$ 枚举删除环上 $(x,x+1)$ 这条边，那么经过环的路径可以分为三类：1～x中取两个 $d_i$ 再加上环上的一段，x+1~m中取两个 $d_i$ 再加上环上的一段，两部分各取一个 $d_i$ 再加上环上经过边 $(1,m)$ 的一段。 分别处理这三种情况，对于前两种情况，设 $\rm pre_ans[x]$ 表示1~x中第一种路径的最大值， $\rm suf_ans[x]$ 表示x~n中第二种路径的最大值。 计算这两个数组就是一个简单的 $\rm dp$ ，令 $\rm sum[x]$ 表示从环上不经过 $(1,m)$ 这条边从 $1$ 走到 $x$ 的距离，那么只需要记录前面最大的一个 $\rm d[y]-sum[y]$ 就可以算出 $\rm pre_ans[x]$ 了， $\rm suf_ans[x]$ 同理。 考虑最后一部分，那么预处理两个数组， $\rm pre[x]$ 表示1~x中 $\rm d[i]+sum[i]$ 的最大值， $\rm suf[x]$ 表示x~n中 $\rm sum[m]-sum[i]+d[i]$ 的最大值，那么如果删除边 $(x,x+1) $ ，则答案就是 $\rm pre[x]+suf[x+1]$ 注意到如果删除 $(1,m)$ 这条边，那么结果就是 $\rm pre_ans[m]$ 那么到这里，这道题就解决了。总时间复杂度 $O(n)$ 。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define ll long long#define N 222222#define M 444444using namespace std;stack&lt;ll&gt;S;bool vis[N];ll n,R[N],L[N],H[N],PA[N],SA[N],PL[N],SL[N],tot;ll TOT,LA[N],NE[M],EN[M],LE[M],d;ll GM(ll x,ll y,ll z)&#123; if(x&gt;=y&amp;&amp;x&gt;=z)return x; if(y&gt;=z)return y; return z;&#125;void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;ll DFS(ll x,ll f)&#123; if(vis[x])return x; vis[x]=1;S.push(x); for(ll i=LA[x];i;i=NE[i]) if(EN[i]!=f) &#123; ll y=DFS(EN[i],x); if(y)return y; &#125; S.pop();return 0;&#125;ll DFSH(ll x,ll f)&#123; ll A=0,B=0; for(ll i=LA[x];i;i=NE[i]) if(EN[i]!=f) &#123; B=max(B,DFSH(EN[i],x)+LE[i]); if(A&lt;B)swap(A,B); &#125; d=max(A+B,d); return A;&#125;void FSON(ll x)&#123; ll A=0,B=0; for(ll i=LA[R[x]];i;i=NE[i]) if(EN[i]!=R[x-1]&amp;&amp;EN[i]!=R[x+1]) &#123; ll y=DFSH(EN[i],R[x]); B=max(B,y+LE[i]); if(A&lt;B)swap(A,B); &#125; H[x]=A; d=max(d,A+B);&#125;int main()&#123; ll i,j,x,y,z,Maxl,TL,ans; scanf("%I64d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%I64d%I64d%I64d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; x=DFS(1,0); while(!S.empty()) &#123; R[++tot]=S.top(); S.pop(); if(R[tot]==x)break; &#125; R[tot+1]=R[1];R[0]=R[tot]; for(i=1;i&lt;=tot;i++) for(j=LA[R[i]];j;j=NE[j]) if(EN[j]==R[i+1])&#123;L[i]=LE[j];break;&#125; for(i=1;i&lt;=tot;i++)FSON(i); PA[1]=PL[1]=H[1]; SA[tot]=SL[tot]=H[tot]; SA[tot+1]=-1e18;SL[tot+1]=-1e18; TL=0;for(i=2;i&lt;=tot;i++)TL+=L[i-1],PL[i]=max(PL[i-1],TL+H[i]); TL=0;for(i=tot;i&gt;=1;i--)TL+=L[i],SL[i]=max(SL[i+1],TL+H[i]); Maxl=H[1]; for(i=2;i&lt;=tot;i++) &#123; Maxl+=L[i-1]; PA[i]=max(PA[i-1],H[i]+Maxl); Maxl=max(Maxl,H[i]); &#125; Maxl=H[tot]; for(i=tot-1;i&gt;=1;i--) &#123; Maxl+=L[i]; SA[i]=max(SA[i+1],H[i]+Maxl); Maxl=max(Maxl,H[i]); &#125; ans=max(d,PA[tot]); for(i=1;i&lt;=tot;i++) ans=min(ans,GM(max(d,PA[i]),SA[i+1],PL[i]+SL[i+1])); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>基环树</category>
      </categories>
      <tags>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3823 水果怪 （组合数）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3823-%E6%B0%B4%E6%9E%9C%E6%80%AA-%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3823水果怪问题描述 小南和小开在三友路上养了很多只果冻怪。我们可以将三友路想象成一根长度无限的数 轴，在这上面生活着n只果冻怪。每经过一秒，一只果冻怪便会分裂成两只。具体来说，一 只坐标为x的果冻怪，会分裂成两只分别在(x − 1),(x + 1)上的果冻怪，并且原来在x上的果 冻怪会消失。 由于生存空间有限，若一个位置上有不少于P只果冻怪，那么会立刻消失 P 只。经过测 定P = 10^9 + 7。 小南和小开想知道在第T秒末，位置w有多少只果冻怪。初始时刻是0秒初。 输入格式 第一行为三个整数，n，T，w。含义如题所述。 接下来 n 行，每行两个整数xi,ci，表示xi位置，有ci只果冻怪。注意xi可能有重复。 输出格式 输出一个非负整数，表示 T 秒末 w 位置上的果冻怪个数 样例输入 2 2 2 0 3 1 2 样例输出 3 提示 对于 30%的数据： 1 ≤ n ≤ 100，1 ≤ T ≤ 16。 对于 60%的数据：1 ≤ n ≤ 10^5，1 ≤ T ≤ 16。 对于 100%的数据：1 ≤ n,T,ci ≤ 10^5,0 ≤ |w|,|xi| ≤ 10^5。 找找规律容易发现是组合数，然而此题需要求$C_{T}^{i}$，直接卢卡斯要超时，需要使用递推求解。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll p=1000000007,ans;ll C[1234567];ll QM(ll a,ll b)&#123; ll c=1;a=a%p; while(b) &#123; if(b&amp;1)c=c*a%p; b&gt;&gt;=1; a=a*a%p; &#125; return c;&#125;int main()&#123; ll i,n,T,w,x,c,d; scanf("%lld%lld%lld",&amp;n,&amp;T,&amp;w); C[0]=1; for(i=1;i&lt;=T;i++)C[i]=C[i-1]*(T-i+1)%p*QM(i,p-2)%p; for(i=1;i&lt;=n;i++) &#123; scanf("%lld%lld",&amp;x,&amp;c); if(w&gt;x)d=w-x; else d=x-w; if((T&amp;1)&amp;&amp;(d&amp;1))ans=(ans+c*C[d/2+T/2+1]%p)%p; if((!(T&amp;1))&amp;&amp;(!(d&amp;1)))ans=(ans+c*C[d/2+T/2]%p)%p; &#125; printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3824 解密游戏（trie，dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3824-%E8%A7%A3%E5%AF%86%E6%B8%B8%E6%88%8F%EF%BC%88trie%EF%BC%8Cdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3824解密游戏问题描述 小南和小开特别喜欢玩解密游戏，轮到小南加密的时候，由于他的加密方式过于丧心病 狂，所以小开怎么也不能解密成功，于是她来找你帮忙。 密文是一个长度为 n 的数字串，只由 0~9 之间的数字组成。每个小写字母对应 0~9 之 间的一个数字。小南和小开共同拥有一本字典，字典中有 m 个单词，每个单词长度不超过 50。 明文是一个数字，表示最少用多少个单词首尾拼接在一起，使得拼接而成的这个字符串 可以表示密文（也即相同位置的字符串中字母对应数字跟密文相同）。单词可以重复使用。 输出明文，如果无解的话明文为-1。 输入格式 第一行两个正整数 n,m。 第二行有 26 个数字，每个数字是 0~9 之间的数，分别表示字母 a~z 对应的数字。 第三行是长度为 n 的数字串，表示密文。 接下来 m 行，每行一个小写字母串，表示字典中的一个单词。 输出格式 输出一个整数，表示明文 样例输入 1 10 5 2 2 2 3 3 3 4 4 1 1 5 5 6 6 0 7 0 7 7 8 8 8 9 9 9 0 7325189087 it your reality real our 样例输出 1 2 样例输入 2 10 5 2 2 2 3 3 3 4 4 1 1 5 5 6 6 0 7 0 7 7 8 8 8 9 9 9 0 4294967296 it your reality real our 样例输出 2 -1 提示 【数据范围】 对于 30%的数据：1 ≤ n,m ≤ 1000。 对于 100%的数据：1 ≤ n,m ≤ 105。 【样例 1 解释】 我们最少可以用两个单词 reality our，组成的字符串 realityour 去表示密文。 【样例 2 解释】 没有选法使得单词组成的字符串可以表示密文。 此题显然需要进行字符串的匹配，KMP显然要超时，于是考虑trie。对单词建立trie树后，把原串拿来匹配，套一个DP。$F[j]=min(F[j],F[i-1]+1)，i和j是一个单词的起点和终点$把原串的每一个位置都当做起点匹配一次，然后输出$F[length]$即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;struct node&#123;int son[10],v;&#125;trie[5000005];int n,m,Q[233],LA,LB[100005],F[100005],tot=1;char A[100005],B[100005][55];void Ins(int x)&#123; int i,t,p=1; for(i=1;i&lt;=LB[x];i++) &#123; t=B[x][i]-48; if(!trie[p].son[t])trie[p].son[t]=++tot; p=trie[p].son[t]; &#125; trie[p].v=1;&#125;void Fin(int x)&#123; int i,t,p=1; for(i=x;i&lt;=LA;i++) &#123; t=A[i]-48; if(!trie[p].son[t])break; p=trie[p].son[t]; if(trie[p].v)F[i]=min(F[i],F[x-1]+1); &#125;&#125;int main()&#123; int i,j,k;char t; scanf("%d%d",&amp;n,&amp;m); for(i='a';i&lt;='z';i++)scanf("%d",&amp;Q[i]); scanf("%s",&amp;A[1]);LA=strlen(A+1); for(i=1;i&lt;=m;i++) &#123; t=getchar(); while(t&lt;'a'||t&gt;'z')t=getchar(); for(k=0;t&gt;='a'&amp;&amp;t&lt;='z';t=getchar())B[i][++k]=Q[t]+48; LB[i]=k;Ins(i); &#125; memset(F,60,sizeof(F));k=F[0];F[0]=0; for(i=1;i&lt;=LA;i++)Fin(i); if(F[LA]==k)printf("-1"); else printf("%d",F[LA]);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>trie</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1314 爬山（背包dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-1314-%E7%88%AC%E5%B1%B1%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1314爬山问题描述 DD 和好朋友们要去爬山啦！他们一共有 K 个人，每个人都会背一个包。这些包的容量是相同的，都是 V。可以装进背包里的一共有 N 种物品，每种物品都有给定的体积和价值。 在 DD 看来，合理的背包安排方案是这样的： 每个人背包里装的物品的总体积恰等于包的容量。 每个包里的每种物品最多只有一件，但两个不同的包中可以存在相同的物品。 任意两个人，他们包里的物品清单不能完全相同。 在满足以上要求的前提下，所有包里的所有物品的总价值最大是多少呢？ 输入格式 第一行有三个整数：K、V、N。 第二行开始的 N 行，每行有两个整数，分别代表这件物品的体积和价值。 输出格式 只需输出一个整数，即在满足以上要求的前提下所有物品的总价值的最大值。 样例输入 2 10 5 3 12 7 20 2 4 5 6 1 1 样例输出 57 提示 K&lt;=50 V&lt;=5000 此题相当于求最大K优解，需要求出前K大的解。只需要像K短路一样将F数组开成二维，记录下每一个背包状态下的前K大解即可。具体来讲用$F[i][k]$表示容积为i时的第k大解，于是转移的时候有$F[i][1-k]$和$F[i-w][1-k]+v$总共2k个值，取前k个作为$F[i][k]$即可，注意到$F[i][1-k]$和$F[i-w][1-k]+v$都是有序的，所以可以归并处理。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int t,V,n,v[233],w[233],F[5555][55],x[55],y[55],ans;int main()&#123; int i,j,k,p1,p2; scanf("%d%d%d",&amp;t,&amp;V,&amp;n); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;v[i],&amp;w[i]); for(i=0;i&lt;=V;i++) for(j=0;j&lt;=t;j++)F[i][j]=-1e9; F[0][1]=0; for(i=1;i&lt;=n;i++) for(j=V;j&gt;=v[i];j--) &#123; for(k=1;k&lt;=t;k++) &#123; x[k]=F[j][k]; y[k]=F[j-v[i]][k]+w[i]; &#125; for(k=p1=p2=1;k&lt;=t;k++) if(x[p1]&gt;y[p2])F[j][k]=x[p1++]; else F[j][k]=y[p2++]; &#125; for(i=1;i&lt;=t;i++)ans+=F[V][i]; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2107 可爱的猴子（并查集）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2107-%E5%8F%AF%E7%88%B1%E7%9A%84%E7%8C%B4%E5%AD%90%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2107 可爱的猴子问题描述 树上有n只猴子。它们编号为 1 到n。1 号猴子用它的尾巴勾着树枝。剩下的猴子都被其他的猴子用手抓着。每只猴子的每只手可以抓住另一只猴子的尾巴。从0 时刻开始，每一秒都有一只猴子松开它的一只手。这会导致一些猴子掉到地上（它们在地上也能继续松开它们的手，猴子落地的时间很短可以不计）。 你的任务是： 写一个程序，从标准输入读入猴子间抓与被抓住的关系信息，和它们放开手的顺 序，对于每一只猴子算出它落地的时间，把结果输出到标准输出。 输入格式 第一行有两个正整数n和m。n是猴子的数量，m是我们观察猴子的时间（单位为秒）。 接下来n行是初始情 况的描述。第k+1 行有两个整数表示第k个猴子抓住的猴子的编号，前一个数 代表左手抓的猴子的编号，后一个数是右手抓的猴子的编号。如果读入的数为-1 则代表猴子的手是空的。 接下来m行是对猴子观察的结果。在这m行里的第i行，有两个整数。前一个是猴子的编号，后一个是它在时刻i−1 时松开的手的编 号（1-左手，2-右手）。 输出格式 输出n个整数，每行一个。第i行表示第i个猴子落地的时间，如果在观察结束前猴子没有落地，那么输出-1 样例输入 3 2 -1 3 3 -1 1 2 1 2 3 1 样例输出 -1 1 1 提示 1≤n≤200000,1≤m≤400000 本题将猴子间的拉手关系看成边，依次删边倒着讨论变成依次加边，于是变成维护联通块的操作。 所以用并查集来维护联通块，加边过程中如果使原来不和1号点联通的点，与1号点联通了，就需要更新答案。问题在于存在已经掉下的猴子之间可能联通的情况，所以每次更新答案需要更新一个联通块，这是不容易实现的。 考虑到每个联通块只会更新一次答案，所以可以给每个点增加一个权值用来记录答案，合并的时候由于总是合并父亲，所以可以每次更新父亲的权值，用父亲的答案更新儿子的答案，从而在getfather的时候完成对联通块的更新，把所有点的初始权值设为无穷大即可。 最后需要注意将1号节点始终作为父亲。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 222222#define M 1234567using namespace std;int n,m,F[N],A[N][3],D[N][3],ans[N],B[2*N],C[2*N];int GF(int x)&#123; int t=F[x]; if(F[x]!=x)F[x]=GF(F[x]); ans[x]=min(ans[x],ans[t]); return F[x];&#125;void Merge(int x,int y,int z)&#123; int fx=GF(x),fy=GF(y); if(fx!=fy) &#123; if(fx==1)swap(fx,fy); F[fx]=fy; ans[fx]=z; &#125;&#125;int main()&#123; int i,x,y; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;A[i][1],&amp;A[i][2]); D[i][1]=A[i][1]; D[i][2]=A[i][2]; &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;B[i],&amp;C[i]); A[B[i]][C[i]]=-1; &#125; for(i=1;i&lt;=n;i++)F[i]=i,ans[i]=1e9; for(i=1;i&lt;=n;i++) &#123; if(A[i][1]!=-1)Merge(i,A[i][1],1e9); if(A[i][2]!=-1)Merge(i,A[i][2],1e9); &#125; for(i=m;i&gt;=1;i--) &#123; x=B[i];y=D[x][C[i]]; if(y==-1)continue; Merge(x,y,i-1); &#125; for(i=1;i&lt;=n;i++) &#123; GF(i); if(ans[i]!=1e9)printf("%d\n",ans[i]); else printf("-1\n"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2244 奶牛阵列（KMP+Hash）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2244-%E5%A5%B6%E7%89%9B%E9%98%B5%E5%88%97%EF%BC%88KMP-Hash%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2244奶牛阵列问题描述 每天早晨约翰的奶牛都会在挤奶的时候排成阵列，即站成R(1&lt;=R&lt;=10000)行C(1&lt;=C&lt;=75)列的矩阵。我们知道，约翰是奶牛专家，他打算写一本关于喂养奶牛的书，他发现，当奶牛按不同血统标记以后，整个大矩阵就像由很多小矩阵无缝拼接的一样。 请帮助约翰找到面积最小的模型矩阵，使他能拼出整个大矩阵，当然，模型矩阵的尺寸不一定能整除大矩阵，也就是说你可以用若干个模型矩阵，拼出一个包含大矩阵的更大的矩阵。 输入格式 第一行， 两个整数R和C 接下来是由大写字母构成的R*C的矩阵 输出格式 一个整数，表示最小模型矩阵的面积。 样例输入 2 5 ABABA BABAB 样例输出 4 提示 样例说明： 模型矩阵如下： AB BA 拼出的大矩阵如下： ABABAB BABABA 本题usaco官方数据很弱，很多错解可以AC，下面提供两种正确思路。 思路一： 首先明确小矩阵不能够重叠，所以我们考虑循环节。一个简单的想法是求出每一行和每一列的分别的最小循环节，然后求最小公倍数，把行和列的最小公倍数乘起来，然而这并不是最优解，因为循环节可能有多个，比如AAABCAAAABABABAB这样的数据，两行的最小循环节的最小公倍数是10，算出答案20，然而显然正解是12。所以我们需要求出每一行所有的循环节，然后求出他们取不同循环节时最小的最小公倍数。观察可以发现只需要取所有行的最小公共循环节长度即可（因为循环节的倍数也是循环节）。列的处理同理。 思路二： 将每一行Hash成一个数字，然后求形成数列的最小循环节，列同理，然后将两个最小循环节长度乘起来就是答案。这样相当求出了最小循环矩形。 思路二代码（By rgnoH）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define ll long long#define mod 0xffffint R,C,fail[10005],rans,cans;ll Hash[10005];char ch[10005][80];int main()&#123; int i,j,sd=131; ll h; scanf("%d%d",&amp;R,&amp;C); for(i=1;i&lt;=R;i++)scanf("%s",&amp;ch[i][1]); for(i=1;i&lt;=R;i++) &#123; h=0; for(j=1;j&lt;=C;j++)h=(h+ch[i][j])*sd%mod; Hash[i]=h; &#125; fail[1]=j=0; for(i=2;i&lt;=R;i++) &#123; while(j&gt;0&amp;&amp;Hash[j+1]!=Hash[i])j=fail[j]; if(Hash[j+1]==Hash[i])j++; fail[i]=j; &#125; rans=R-fail[R]; for(i=1;i&lt;=C;i++) &#123; h=0; for(j=1;j&lt;=R;j++)h=(h+ch[j][i])*sd%mod; Hash[i]=h; &#125; fail[1]=j=0; for(i=2;i&lt;=C;i++) &#123; while(j&gt;0&amp;&amp;Hash[j+1]!=Hash[i])j=fail[j]; if(Hash[j+1]==Hash[i])j++; fail[i]=j; &#125; cans=C-fail[C]; printf("%d",cans*rans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>哈希</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2439 四叶草魔杖（最小生成树+状压dp/网络流）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2439-%E5%9B%9B%E5%8F%B6%E8%8D%89%E9%AD%94%E6%9D%96%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E7%8A%B6%E5%8E%8Bdp-%E7%BD%91%E7%BB%9C%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2439 四叶草魔杖问题描述 魔杖护法Freda融合了四件武器，于是魔杖顶端缓缓地生出了一棵四叶草，四片叶子幻发着淡淡的七色光。圣剑护法rainbow取出了一个圆盘，圆盘上镶嵌着N颗宝石，编号为0~N-1。第i颗宝石的能量是Ai。如果Ai&gt;0，表示这颗宝石能量过高，需要把Ai的能量传给其它宝石；如果Ai&lt;0，表示这颗宝石的能量过低，需要从其它宝石处获取-Ai的能量。保证∑Ai =0。只有当所有宝石的能量均相同时，把四叶草魔杖插入圆盘中央，才能开启超自然之界的通道。 不过，只有M对宝石之间可以互相传递能量，其中第i对宝石之间无论传递多少能量，都要花费Ti的代价。探险队员们想知道，最少需要花费多少代价才能使所有宝石的能量都相同? 输入格式 第一行两个整数N、M。 第二行N个整数Ai。 接下来M行每行三个整数pi,qi,Ti，表示在编号为pi和qi的宝石之间传递能量需要花费Ti的代价。数据保证每对pi、qi最多出现一次。 输出格式 输出一个整数表示答案。无解输出Impossible 样例输入 3 3 50 -20 -30 0 1 10 1 2 20 0 2 100 样例输出 30 提示 对于 50% 的数据，2&lt;=N&lt;=8。 对于 100% 的数据，2&lt;=N&lt;=16，0&lt;=M&lt;=N*(N-1)/2，0&lt;=pi,qi&lt;N，-1000&lt;=Ai&lt;=1000，0&lt;=Ti&lt;=1000，∑Ai=0。 做法一：最小生成树+状压dp 枚举点集，若当前点集构成联通块且能量之和为0，显然当前联通块传递能量的最小代价是其最小生成树，因此将每个这样的联通块看成一个物品，背包dp算出最小费用即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct node&#123;int x,y,z;&#125;;bool cmp(node a,node b)&#123;return a.z&lt;b.z;&#125;int n,m,A[20],S[66666],V[66666],F[66666],TOT;int fa[20];bool mark[20];node P[200];int GF(int x)&#123; if(fa[x]!=x)fa[x]=GF(fa[x]); return fa[x];&#125;int Kruscal(int s)&#123; int i,j,fx,fy,x,y,k=1,tot=0,cnt=0,ans=0; memset(mark,0,sizeof(mark)); for(i=1;i&lt;=n;i++)if((1&lt;&lt;i-1)&amp;s)tot++,mark[i]=1; for(i=1;i&lt;=n;i++)fa[i]=i; while(k&lt;=m&amp;&amp;cnt&lt;tot) &#123; x=P[k].x; y=P[k].y; fx=GF(x);fy=GF(y); if(mark[x]&amp;&amp;mark[y]&amp;&amp;fx!=fy) &#123; ans+=P[k].z; fa[fx]=fy; cnt++; &#125; k++; &#125; if(cnt+1&lt;tot)return 1e9; return ans;&#125;int main()&#123; int i,j; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;A[i]); for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;P[i].x,&amp;P[i].y,&amp;P[i].z); P[i].x++;P[i].y++; &#125; sort(P+1,P+m+1,cmp); TOT=(1&lt;&lt;n)-1; for(i=1;i&lt;=TOT;i++) for(j=1;j&lt;=n;j++)if((1&lt;&lt;j-1)&amp;i)S[i]+=A[j]; for(i=1;i&lt;=TOT;i++)if(S[i]==0)V[i]=Kruscal(i); for(i=1;i&lt;=TOT;i++)F[i]=1e9;F[0]=0; for(i=0;i&lt;=TOT;i++) &#123; if(S[i])continue; for(j=0;j&lt;=TOT;j++)F[i|j]=min(F[i|j],F[j]+V[i]); &#125; if(F[TOT]==1e9)puts(&quot;Impossible&quot;); else cout&lt;&lt;F[TOT];&#125; 做法二：网络流 建图比较简单，从源点向每个$A[i]&gt;0$的点连边，容量为$A[i]$，费用为0，从每个$A[i]&lt;0$的点向汇点连边，容量为$-A[i]$，费用为0，然后点之间的边容量设为无穷。需要注意的是与普通的费用流不同，每次找到一条路时，要将有流经过的边费用改成0，将没有流经过的边费用改成原值，双向边都要改，因为第二次走是不产生费用的。最后再将有流的边的费用加起来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;deque&gt;#define N 123#define M 1234using namespace std;int qg=0,n,m,S,T,A[123];int TOT=1,LA[N],EN[M],NE[M],G[M],W[M],F[M];int dis[N],use[N],pre[N],maxflow,mincost;bool mark[N];queue&lt;int&gt;Q;void ADD(int x,int y,int w,int c)&#123; TOT++; EN[TOT]=y; G[TOT]=w; F[TOT]=c; W[TOT]=c; NE[TOT]=LA[x]; LA[x]=TOT;&#125;bool FP()&#123; int i,x,y; memset(dis,60,sizeof(dis)); dis[S]=0;mark[S]=1;Q.push(S); while(!Q.empty()) &#123; x=Q.front(); Q.pop(); mark[x]=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(G[i]&amp;&amp;dis[y]&gt;dis[x]+W[i]) &#123; dis[y]=dis[x]+W[i]; pre[y]=x;use[y]=i; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125; if(dis[T]!=dis[0])return 1; return 0;&#125;void AF()&#123; int f=1e9,i; for(i=T;i!=S;i=pre[i])f=min(f,G[use[i]]); maxflow+=f; for(i=T;i!=S;i=pre[i]) &#123; G[use[i]]-=f; G[use[i]^1]+=f; if(G[use[i]]!=1e9)W[use[i]^1]=W[use[i]]=0; else &#123; W[use[i]]=F[use[i]]; W[use[i]^1]=F[use[i]^1]; &#125; &#125;&#125;int main()&#123; int i,x,y,z; scanf("%d%d",&amp;n,&amp;m); S=n+1;T=S+1; for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;A[i]); if(A[i]&gt;0) &#123; ADD(S,i,A[i],0); ADD(i,S,0,0); qg+=A[i]; &#125; else &#123; ADD(i,T,-A[i],0); ADD(T,i,0,0); &#125; &#125; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); x++;y++; ADD(x,y,1e9,z); ADD(y,x,1e9,z); &#125; while(FP())AF(); if(maxflow!=qg)puts("Impossible"); else &#123; for(i=2;i&lt;=TOT;i++) if(G[i]&amp;&amp;G[i]!=1e9)mincost+=F[i]; cout&lt;&lt;mincost/2; &#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
        <category>杂学</category>
        <category>网络流</category>
        <category>状态压缩</category>
        <category>最小生成树</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>网络流</tag>
        <tag>状态压缩</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2784 (APIO 2013) 道路费用（最小生成树+缩点）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2784-APIO-2013-%E9%81%93%E8%B7%AF%E8%B4%B9%E7%94%A8%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E7%BC%A9%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2784 道路费用问题描述输入格式 你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数N，M和K。接下来的 M行描述最开始的M 条道路。这M行中的第i行包含由空格隔开的整数ai，bi和c i，表示有一条在a i和b i之间，费用为c i的双向道路。接下来的K行描述新建的K条道路。这 K行中的第i行包含由空格隔开的整数 xi和yi，表示有一条连接城镇xi和yi新道路。最后一行包含N个由空格隔开的整数，其中的第j个为pj，表示从城镇j 前往城镇 1的人数。 输入也满足以下约束条件。  1 ≤ N ≤ 100000；  1 ≤ K ≤ 20；  1 ≤ M ≤ 300000；  对每个i和j，1 ≤ ci, pj ≤ 10^6； 输出格式 你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。 样例输入 5 5 1 3 5 2 1 2 3 2 3 5 2 4 4 4 3 6 1 3 10 20 30 40 50 样例输出 400 首先，分析题目发现，本题给出的图的最小生成树是唯一的（每条边权值不同），于是我们先求出不含K条边的最小生成树A，再求出将K条边的权值设为0后的最小生成树B，容易发现，最后的目标最小生成树C中的边，一定来自A或给出的K条边中（B中除了给出的K条边外，其他边一定也在A中）。 同时观察可得，同时在A,B中出现的边一定是必须要选的边，因此我们可以利用这些边来缩点，将这些边构成的图中每一个联通块缩成一个点，这个点的人数等于该联通块所有点的人数和。 观察发现，缩点后最多存在K+1个点，由于K很小，为了求出答案，我们容易想到枚举K条边的子集，每次将选中的边先加入生成树C中，然后拿A中没用的边来跑生成树，此时的到的生成树C就是加入该子集后的目标生成树。 最后只需要枚举加入一条没选中的边，一定构成一个环，该环上每条边的权值不能大于该边的值，最后将每条边的权值取最大值，DFS算出每条边经过的人数，统计答案即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 123456#define M 1234567#define ll long longusing namespace std;struct node&#123;int x,y;ll z;&#125;;bool cmp(node a,node b)&#123;return a.z&lt;b.z;&#125;ll n,m,k,rt,ans,P[N],V[N],F[N],NP[N],C_cnt,NP_cnt;node edge[M],K_edge[N],C_edge[N];bool A_mark[M],B_mark[M],C_mark[N];ll GF(ll v)&#123; if(F[v]!=v)F[v]=GF(F[v]); return F[v];&#125;ll TOT,LA[N],NE[N],EN[N],TY[N];ll K_max[N],dep[N],size[N],fa[N],pre[N];void ADD(ll x,ll y,ll z)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; TY[TOT]=z; LA[x]=TOT;&#125;void DFS(ll x,ll f)&#123; ll i,y; dep[x]=dep[f]+1; size[x]=V[x]; fa[x]=f; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f) &#123; DFS(y,x); size[x]+=size[y]; pre[y]=TY[i]; &#125; &#125;&#125;void Work(ll S)&#123; ll i,j,x,y;TOT=0; for(i=1;i&lt;=NP_cnt;i++)F[i]=i,LA[i]=0; for(i=1;i&lt;=C_cnt;i++)C_mark[i]=0; for(i=1;i&lt;=k;i++)K_max[i]=1e9; for(i=1;i&lt;=k;i++) if(S&amp;(1&lt;&lt;i-1)) &#123; x=GF(K_edge[i].x); y=GF(K_edge[i].y); if(x==y)return; F[x]=y; ADD(K_edge[i].x,K_edge[i].y,i); ADD(K_edge[i].y,K_edge[i].x,i); &#125; for(i=1;i&lt;=C_cnt;i++) &#123; x=GF(C_edge[i].x); y=GF(C_edge[i].y); if(x==y)continue; F[x]=y; C_mark[i]=1; ADD(C_edge[i].x,C_edge[i].y,0); ADD(C_edge[i].y,C_edge[i].x,0); &#125; DFS(rt,0); for(i=1;i&lt;=C_cnt;i++) &#123; if(C_mark[i])continue; x=C_edge[i].x; y=C_edge[i].y; while(x!=y) &#123; if(dep[x]&lt;dep[y])swap(x,y); K_max[pre[x]]=min(K_max[pre[x]],C_edge[i].z); x=fa[x]; &#125; &#125; ll tmp=0; for(i=1;i&lt;=k;i++) if(S&amp;(1&lt;&lt;i-1)) &#123; x=K_edge[i].x; y=K_edge[i].y; if(dep[x]&lt;dep[y])swap(x,y); tmp+=1ll*K_max[i]*size[x]; &#125; ans=max(ans,tmp);&#125;int main()&#123; ll cnt,x,y,i,j; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); for(i=1;i&lt;=m;i++)scanf("%lld%lld%lld",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].z); for(i=1;i&lt;=k;i++)scanf("%lld%lld",&amp;K_edge[i].x,&amp;K_edge[i].y); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;P[i]); sort(edge+1,edge+m+1,cmp); for(j=1;j&lt;=n;j++)F[j]=j; i=1;cnt=0; while(cnt&lt;n&amp;&amp;i&lt;=m) &#123; x=GF(edge[i].x); y=GF(edge[i].y); if(x!=y) &#123; cnt++; A_mark[i]=1; F[x]=y; &#125; i++; &#125; cnt=0;i=1; for(j=1;j&lt;=n;j++)F[j]=j; for(j=1;j&lt;=k;j++) &#123; x=GF(K_edge[j].x); y=GF(K_edge[j].y); if(x!=y) &#123; cnt++; F[x]=y; &#125; &#125; while(cnt&lt;n&amp;&amp;i&lt;=m) &#123; x=GF(edge[i].x); y=GF(edge[i].y); if(x!=y) &#123; cnt++; B_mark[i]=1; F[x]=y; &#125; i++; &#125; for(i=1;i&lt;=n;i++)F[i]=i; for(i=1;i&lt;=m;i++) &#123; if(A_mark[i]&amp;&amp;B_mark[i]) &#123; x=GF(edge[i].x); y=GF(edge[i].y); F[x]=y; &#125; else if(A_mark[i])C_edge[++C_cnt]=edge[i]; &#125; for(i=1;i&lt;=n;i++) &#123; x=GF(i); if(!NP[x])NP[x]=++NP_cnt; NP[i]=NP[x]; V[NP[i]]+=P[i]; &#125; rt=NP[1]; for(i=1;i&lt;=k;i++) &#123; K_edge[i].x=NP[K_edge[i].x]; K_edge[i].y=NP[K_edge[i].y]; &#125; for(i=1;i&lt;=C_cnt;i++) &#123; C_edge[i].x=NP[C_edge[i].x]; C_edge[i].y=NP[C_edge[i].y]; &#125; ll S=(1&lt;&lt;k)-1; for(i=1;i&lt;=S;i++)Work(i); printf("%lld",ans);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2770 难度系数（最小生成树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2770-%E9%9A%BE%E5%BA%A6%E7%B3%BB%E6%95%B0%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2770【USACO 2014 January Gold】难度系数问题描述 奶牛冬奥会的越野滑雪场可以被看做是一个M x N(1 &lt;= M,N &lt;= 500)的网格区域。其中每格都有一个海拔高度（海拔高度的范围：0 .. 1,000,000,000）。 其中一些格子被设计成了滑雪的起点，赛会组织者想要给每个滑雪起点做一个难度的评级。 一个起点P的难度系数D应该尽可能小，使得一只奶牛能够成功的滑过至少T(1 &lt;= T &lt;= MN)个格子。如果奶牛从P出发，它只能朝相邻的格子滑行，且要求相邻的格子的海拔高度差的绝对值不超过D。 请帮助组织者计算出每个起点的难度系数。 输入格式 第一行，三个整数M, N, 和 T 接下来是一个M x N的整数矩阵，表示每个格子的海拔高度 接下来是一个M x N的矩阵，矩阵由数字0和1构成，数字1表示该处是一个起点。 输出格式 一个整数，表示所有起点的难度系数总和(可能超过int范围) 样例输入 3 5 10 20 21 18 99 5 19 22 20 16 17 18 17 40 60 80 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 样例输出 24 首先我们要理解一个起点的难度系数是指：从该起点出发经过的相邻的两点的高度差的最大值。同时我们注意到每个点是可以反复经过的，并且反复经过不会影响难度系数。因此我们可以发现，对于一个起点，它最后经过的所有的点必然是一个联通块。我们定义两点之间的边的权值等于他们的高度差。那么一个起点的难度系数就是它所在联通块中最大的边权。 我们考虑将所有的边按照权值从小到大排序，将Kruscal算法修改一下。每次选出权值最小的边，合并它连接的两个联通块，如果合并后的大联通块包含的点数大于等于T，并且小联通块各自包含的点数小于T，那么ans+=小联通块中起点数*当前边的权值。 正确性是显然的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define Abs(a,b) ((a&gt;b)?(a-b):(b-a))#define N 505#define M 500005using namespace std;struct node&#123;int x,y,z;&#125;edge[M];bool cmp(node a,node b)&#123;return a.z&lt;b.z;&#125;int m,n,t,map[N][N],Map[N][N],id[N][N],F[M],size[M],p[M],tot,TOT,cnt;long long ans;int GF(int v)&#123; if(F[v]!=v)F[v]=GF(F[v]); return F[v];&#125;int main()&#123; int i,j,x,y,k; scanf("%d%d%d",&amp;m,&amp;n,&amp;t); for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++)scanf("%d",&amp;map[i][j]); for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) &#123; scanf("%d",&amp;Map[i][j]); cnt+=Map[i][j];//cnt表示起点总数 &#125; for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) &#123; id[i][j]=++tot; size[tot]=Map[i][j];//size记录起点数 &#125; for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) &#123; if(i!=m) &#123; TOT++; edge[TOT].x=id[i][j]; edge[TOT].y=id[i+1][j]; edge[TOT].z=Abs(map[i][j],map[i+1][j]); &#125; if(j!=n) &#123; TOT++; edge[TOT].x=id[i][j]; edge[TOT].y=id[i][j+1]; edge[TOT].z=Abs(map[i][j],map[i][j+1]); &#125; &#125; sort(edge+1,edge+TOT+1,cmp); for(i=1;i&lt;=tot;i++)F[i]=i,p[i]=1;//p记录总点数 i=1; while(cnt&amp;&amp;i&lt;=TOT) &#123; x=GF(edge[i].x); y=GF(edge[i].y); if(x!=y) &#123; if(p[x]+p[y]&gt;=t) &#123; if(p[x]&lt;t)ans+=1ll*size[x]*edge[i].z,cnt-=size[x]; if(p[y]&lt;t)ans+=1ll*size[y]*edge[i].z,cnt-=size[y]; &#125; F[x]=y; size[y]+=size[x]; p[y]+=p[x]; &#125; i++; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3102 取数（堆）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3102-%E5%8F%96%E6%95%B0%EF%BC%88%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3102取数问题描述 n个整数组成的一个环，现在要从中取出m个数，取走一个数字就不能取跟它相邻的数字(相邻的数不能同时取)。要求取出的数字的总和尽可能大，问这个最大和是多少？ 如果无解，请输出“Error!” 输入格式 第一行包含两个正整数n、m。 第二行为n个整数Ai。 输出格式 仅一个整数，表示所求结果。如果无解输出“Error!”，不包含引号。 样例输入 8 4 8 5 6 2 3 4 8 9 样例输出 25 提示 对于全部数据：m&lt;=n；-1000&lt;=Ai&lt;=1000 N&lt;=200000 此题容易想到dp，然而dp的复杂度是$n^2$的，显然不能通过。正解是用堆维护。我们将每个元素编号1-tot，记录它左边元素，右边元素，本身的值。将它的值和编号加入堆中，每次取出堆顶可用元素，将它，它左边元素，它右边元素标记为不可用。这样做显然是不对的，因为我们无法解决$2 \ 4 \ 3$这种情况。为了解决这种情况，我们每次取出一个点后，要向堆中加入一个点，这个点的编号是tot++，值等于左边元素+右边元素-中间元素。这个点代表的意义就是选择左边元素和右边元素，而不选择中间元素。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;deque&gt;using namespace std;struct node&#123;int d,x;&#125;;bool operator&lt;(node a,node b)&#123;return a.x&lt;b.x;&#125;priority_queue&lt;node&gt;Q;int i,ans,n,m,x,y,tot;int A[2000005],L[2000005],R[2000005];bool mark[2000005];node tmp,temp;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); if(m&gt;n/2)&#123;puts("Error!");return 0;&#125; L[1]=n;R[1]=2;tmp.d=1;tmp.x=A[1];Q.push(tmp); L[n]=n-1;R[n]=1;tmp.d=n;tmp.x=A[n];Q.push(tmp); for(i=2;i&lt;n;i++) &#123; L[i]=i-1; R[i]=i+1; tmp.d=i; tmp.x=A[i]; Q.push(tmp); &#125; tot=n; for(i=1;i&lt;=m;i++) &#123; tmp=Q.top(); Q.pop(); x=tmp.d; if(mark[x])&#123;i--;continue;&#125; ans+=A[x]; A[++tot]=A[L[x]]+A[R[x]]-A[x]; L[tot]=L[L[x]];R[L[L[x]]]=tot; R[tot]=R[R[x]];L[R[R[x]]]=tot; temp.x=A[tot];temp.d=tot; Q.push(temp); mark[L[x]]=mark[R[x]]=mark[x]=1; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3540 方块游戏（dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3540-%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3540积木游戏问题描述 小时候我们都喜欢玩积木。这里的积木都是单位边长的正方体块，多个积木可以堆成一个“高木”，“高木”的高度就是叠放的积木块个数。多个“高木”形成一个排列，如果高度满足先严格上升再严格下降，则称这个排列为一座山峰。严格的定义是：假设有N个高木从左到右排列，第i个高度为H[i](i=1,2,...,N)。那么如果存在一个整数k[2,N-1],使得对所有的位置i，下式都成立，则称H是一座山峰。 H[i]&gt;H[i-1],1&lt;i&lt;=k H[i]&gt;H[i+1],k&lt;i&lt;=N 现在你有一个超级工具，每次操作可以给一段连续的区间各位置都叠放上一块积木，使得高度同时增加1个单位，现在有一个“高木”排列，需要将其改造为一座山峰，只允许使用这种超级工具，最少需要操作几次可以达到这个目标呢？假设积木无限供应。 输入格式 输入文件只有一组数据。 第一行包含一个整数N，为上文提到的初始排列中“高木”的个数。 第二行包含N个正整数，表示由左到右的N个位置“高木”的初始高度H[i],数字由空格隔开。 输出格式 输出包含一个整数，表示所需要的最少的操作次数。 样例输入 6 3 4 3 6 7 8 样例输出 2 提示 对于30%的数据，满足N&lt;=20,H[i]&lt;=50. 对于50%的数据，满足N&lt;=100,H[i]&lt;=1000 对于全部的数据，满足3&lt;=N&lt;=10^5,H[i]&lt;=10^7 此题我们考虑计算两个值，$L[i]$表示将1-i区间变成递增需要的最少操作次数，$R[i]$表示将i-n区间变成递减区间的最少操作次数。计算$L[i]$的时候，我们如果要增加$i$号点的高度，那么显然这次操作同时增加$i-n$是最优的，因为这不会影响后面方块的高度差，然而如果只增加$i$号点，那么后面需要额外一次操作来形成递增序列。$R[i]$同理。那么最后$ans=min{max(L[i],R[i])}$。因为次数较少的一边肯定可以在另一边的操作的同时完成。 代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 123456using namespace std;int n,A[N],L[N],R[N],ans=1e9;int main()&#123; int i,j,k,tmp; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); for(i=2;i&lt;=n;i++) &#123; if(A[i]&lt;=A[i-1])L[i]=A[i-1]+L[i-1]+1-A[i]; else L[i]=L[i-1]; &#125; for(i=n-1;i&gt;=1;i--) &#123; if(A[i]&lt;=A[i+1])R[i]=A[i+1]+R[i+1]+1-A[i]; else R[i]=R[i+1]; &#125; for(i=1;i&lt;=n;i++)ans=min(ans,max(L[i],R[i])); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3544 回文数（数学）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3544-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3544回文数问题描述 给你一个数N，求出最小的B（B&gt;=2），使得 N在 B进制下为回文数。 输入格式 第一行1个整数TEST，表示数据组数。 接下来TEST行，每行一个整数N。 输出格式 共输出TEST行，每行对应一个答案B 样例输入 3 1 4 21 样例输出 2 3 2 提示 30%的数据 TEST&lt;=10，N&lt;=10^4。 100%的数据 TEST&lt;=1,000，N&lt;=10^10。 我们考虑N在B进制下的位数。如果N在B进制下只有一位，那么B最小为N+1。 如果N在B进制下只有两位，那么设$N=(AA)_B$，那么$N=A\times B+A=A\times(B+1)$，那么B+1必然是N的因数，注意$A&lt;B​$，分解因数讨论即可。 如果N在B进制下至少有三位，那么B进制下最小的三位数为$(100)_B$，那么$N&gt;=B^2$，那么有$B&lt;=\sqrt{N}$，那么枚举即可。 最后将三种情况取最小的B即可。复杂度$T\sqrt{N}$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll T,n,tot,A[123];bool ok(ll x,ll k)&#123; tot=0; while(x) &#123; A[++tot]=x%k; x/=k; &#125; ll i=1,j=tot; while(i&lt;=j) &#123; if(A[i]!=A[j])return 0; i++;j--; &#125; return 1;&#125;void Solve(ll x)&#123; ll i,t1=x+1; for(i=2;i*i&lt;=x;i++) &#123; if(x%i==0)continue; if(ok(x,i))break; &#125; if(i*i&lt;=x)&#123;printf("%lld\n",i);return;&#125; for(i=1;i*i&lt;=x;i++) if(x%i==0) &#123; if(x/i-1&gt;1)t1=min(x/i-1,t1); &#125; printf("%lld\n",t1);&#125;int main()&#123; scanf("%lld",&amp;T); while(T--) &#123; scanf("%lld",&amp;n); Solve(n); &#125;&#125;]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>数学杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3844 服务器信息储存（最短路）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3844-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF%E5%82%A8%E5%AD%98%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3844服务器信息储存问题描述 Byteland王国准备在各服务器间建立大型网络并提供多种服务。 网络由n台服务器组成，用双向的线连接。两台服务器之间最多只能有一条线直接连接，同时，每台服务器最多只能和10台服务器直接连接，但是任意两台服务器间必然存在一条路径将它们连接在一起。每条传输线都有一个固定传输的速度。δ(V, W)表示服务器V和W之间的最短路径长度，且对任意的V有δ(V, V)＝0。 有些服务器比别的服务器提供更多的服务，它们的重要程度要高一些。我们用r(V)表示服务器V的重要程度(rank)。rank越高的服务器越重要。 每台服务器都会存储它附近的服务器的信息。当然，不是所有服务器的信息都存，只有感兴趣的服务器信息才会被存储。服务器V对服务器W感兴趣是指，不存在服务器U满足，r(U)&gt;r(W)且δ(V, U)&lt;=δ(V, W)。 举个例子来说，所有具有最高rank的服务器都会被别的服务器感兴趣。如果V是一台具有最高rank的服务器，由于δ(V, V)＝0，所以V只对具有最高rank的服务器感兴趣。我们定义B(V)为V感兴趣的服务器的集合。 我们希望计算所有服务器储存的信息量，即所有服务器的|B(V)|之和。Byteland王国并不希望存储大量的数据，所以所有服务器存储的数据量(|B(V)|之和)不会超过30n。 你的任务是写一个程序，读入Byteland王国的网络分布，计算所有服务器存储的数据量。 输入格式 第一行两个整数n和m，(1≤n≤30000，1≤m≤5n)。n表示服务器的数量，m表示传输线的数量。 接下来n行，每行一个整数，第i行的整数为r(i)(1≤r(i)≤10)，表示第i台服务器的rank。 接下来m行，每行表示各条传输线的信息，包含三个整数a，b，t(1≤t≤1000，1≤a，b≤n，a≠b)。a和b是传榆线所连接的两台服务器的编号，t是传输线的长度。 输出格式 一个整数，表示所有服务器存储的数据总量，即|B(V)|之和。 样例输入 4 3 2 3 1 1 1 4 30 2 3 20 3 4 20 样例输出 9 提示 样例解释 B(1)={1，2}，B(2)={2}，B(3)={2，3}，B(4)={1，2，3，4}。 数据范围 对于 30%的数据，n≤100,m&lt;=300。 对于 60%的数据，n≤1000,m&lt;=20000。 对于 100%的数据, 1≤n≤30000，1≤m≤5n 首先预处理出$dis[i][k]$表示$i$号点所有到$rank=k$的点的距离的最小值。实现方式是在dijkstra时向堆中添加所有$rank=k$的点作为起点。 然后处理出$mindis[i][k]$表示$i$号点到所有$rank&gt;=k$的点的距离的最小值。 最后枚举点$i$，跑一次dijkstra，算出有那些点对$i$号点感兴趣，如果一个点$x$出堆时，它和$i$的距离小于$mindis[x][rank[i]]$那么说明不存在rank大于$i$的点和$x$的距离小于等于$dis(x,i)$，因此$x$对$i$感兴趣。反之如果$dis(x,i)$大于等于$mindis[x][rank[i]]$，那么从$x$点再拓展出的点一定不可能对$i$感兴趣。因为假设从$x$经过一条长度为$k$的边到达$y$，那么$dis(y,i)=dis(x,i)+k$，而$$mindis[y][rank[i]]&lt;=mindis[x][rank[i]]+k&lt;=dis(x,i)+k=dis(y,i)$$所以我们可以不从$x$点拓展新的节点，即$continue$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define min(a,b) ((a&lt;b)?(a):(b))#define N 33333#define M 333333using namespace std;struct node&#123;int x,d;&#125;;bool operator&lt;(node a,node b)&#123;return a.d&gt;b.d;&#125;priority_queue&lt;node&gt;Q;int n,m,Rank[N],F[12],ans;int TOT,LA[N],NE[M],EN[M],LE[M];int dis[N][12],Dis[N],mark[N],mindis[N][12];void Dijkstra(int s)&#123; int i,x,y,d; node tmp,temp; for(i=1;i&lt;=n;i++) if(Rank[i]==s) &#123; dis[i][s]=0; tmp.x=i;tmp.d=0; Q.push(tmp); &#125; while(!Q.empty()) &#123; temp=Q.top(); Q.pop(); x=temp.x; d=temp.d; if(d!=dis[x][s])continue; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(dis[y][s]&gt;LE[i]+d) &#123; dis[y][s]=LE[i]+d; tmp.x=y;tmp.d=dis[y][s]; Q.push(tmp); &#125; &#125; &#125;&#125;void dijkstra(int s)&#123; int i,x,y,d; node tmp,temp; Dis[s]=0; mark[s]=s; tmp.x=s; tmp.d=0; Q.push(tmp); while(!Q.empty()) &#123; tmp=Q.top(); Q.pop(); x=tmp.x; d=tmp.d; if(Dis[x]!=d)continue; if(d&lt;mindis[x][Rank[s]])ans++; else continue; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(mark[y]!=s||Dis[y]&gt;LE[i]+d) &#123; Dis[y]=LE[i]+d; if(mark[y]!=s)mark[y]=s; temp.d=Dis[y]; temp.x=y; Q.push(temp); &#125; &#125; &#125;&#125;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int main()&#123; int i,j,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;Rank[i]),F[Rank[i]]++; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; memset(dis,60,sizeof(dis)); for(i=1;i&lt;=10;i++)if(F[i])Dijkstra(i); for(i=1;i&lt;=n;i++) &#123; mindis[i][10]=1e9; for(j=9;j&gt;=1;j--)mindis[i][j]=min(mindis[i][j+1],dis[i][j+1]); &#125; for(i=1;i&lt;=n;i++)dijkstra(i); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3213 牧草鉴赏家（Tarjan缩点+最长路）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3213-%E7%89%A7%E8%8D%89%E9%89%B4%E8%B5%8F%E5%AE%B6%EF%BC%88Tarjan%E7%BC%A9%E7%82%B9-%E6%9C%80%E9%95%BF%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3213【USACO 2015 Jan Gold】牧草鉴赏家问题描述 约翰有n块草场，编号1到n，这些草场由若干条单行道相连。奶牛贝西是美味牧草的鉴赏家，她想到达尽可能多的草场去品尝牧草。 贝西总是从1号草场出发，最后回到1号草场。她想经过尽可能多的草场，贝西在通一个草场只吃一次草，所以一个草场可以经过多次。因为草场是单行道连接，这给贝西的品鉴工作带来了很大的不便，贝西想偷偷逆向行走一次，但最多只能有一次逆行。问，贝西最多能吃到多少个草场的牧草。 输入格式 第一行，两个整数N和M(1&lt;=N,M&lt;=100000) 接下来M行，表示有M条单向道路，每条道路有连个整数X和Y表示，从X出发到达Y。 输出格式 一个整数，表示所求答案 样例输入 7 10 1 2 3 1 2 5 2 4 3 7 3 5 3 6 6 5 7 2 4 7 样例输出 6 首先显然用Tarjan缩点，变成DAG。由于只用一条反向边，因此我们可以枚举这条反向边，那么路径是1-&gt;反向边起点-&gt;反向边终点-&gt;1那么显然我们只需要算出1到每一个点经过的最多点数，和每一个点到1经过的最多点数。然后枚举讨论即可。 关于正确性，我们只需要证明除了1号点经过两次外，所有点都只会经过一次即可。那么，首先，我们把这个DAG中的路径分成两种，一种是以1为起点的，一种是以1为终点的，其他的不讨论。那么显然这两种边是不能重合的，而且反向边肯定是从以1为起点的路径连到以1为终点的路径上。故正确性得证。 关于求出上述的最多点数，我们用缩点后的图跑最长路，将终点的缩点前包含点数当成边权即可。正图+反图跑两遍即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 123456#define M 234567using namespace std;inline int _R()&#123; int t=getchar();int o; while(t&lt;48||t&gt;57)t=getchar(); for(o=0;t&gt;47&amp;&amp;t&lt;58;t=getchar())o=o*10+t-48; return o;&#125;int n,m,VT,scc,size[N],ans=-1e9;int TOT,LA[N],NE[M],EN[M],ST[M];int NTOT,NLA[N],NNE[M],NEN[M],NST[M];int ntot,nla[N],nne[M],nen[M],nst[M];int dis[N],dist[N],dfn[N],low[N],be[N];bool mark[N],Mark[N];stack&lt;int&gt;S;queue&lt;int&gt;Q;void ADD(int x,int y)&#123; TOT++; ST[TOT]=x; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void NADD(int x,int y)&#123; NTOT++; NST[NTOT]=x; NEN[NTOT]=y; NNE[NTOT]=NLA[x]; NLA[x]=NTOT;&#125;void nadd(int x,int y)&#123; ntot++; nst[ntot]=x; nen[ntot]=y; nne[ntot]=nla[x]; nla[x]=ntot;&#125;void Tarjan(int u)&#123; int i,v; dfn[u]=low[u]=++VT; S.push(u); mark[u]=1; for(i=LA[u];i;i=NE[i]) &#123; v=EN[i]; if(!dfn[v]) &#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(mark[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; scc++; do&#123; v=S.top(); S.pop(); mark[v]=0; be[v]=scc; size[scc]++; &#125;while(u!=v); &#125;&#125;void SPFA(int s)&#123; int i,x,y; for(i=1;i&lt;=n;i++)dis[i]=-1e9; Mark[s]=1;dis[s]=size[s];Q.push(s); while(!Q.empty()) &#123; x=Q.front(); Q.pop(); Mark[x]=0; for(i=nla[x];i;i=nne[i]) &#123; y=nen[i]; if(dis[y]&lt;dis[x]+size[y]) &#123; dis[y]=dis[x]+size[y]; if(!Mark[y])Mark[y]=1,Q.push(y); &#125; &#125; &#125;&#125;void spfa(int s)&#123; int i,x,y; for(i=1;i&lt;=n;i++)dist[i]=-1e9; Mark[s]=1;dist[s]=size[s];Q.push(s); while(!Q.empty()) &#123; x=Q.front(); Q.pop(); Mark[x]=0; for(i=NLA[x];i;i=NNE[i]) &#123; y=NEN[i]; if(dist[y]&lt;dist[x]+size[y]) &#123; dist[y]=dist[x]+size[y]; if(!Mark[y])Mark[y]=1,Q.push(y); &#125; &#125; &#125;&#125;int main()&#123; int i,j,x,y; n=_R();m=_R(); for(i=1;i&lt;=m;i++) &#123; x=_R();y=_R(); ADD(x,y); &#125; for(i=1;i&lt;=n;i++)if(!dfn[i])Tarjan(i); for(i=1;i&lt;=TOT;i++) &#123; x=ST[i];y=EN[i]; if(be[x]!=be[y]) &#123; NADD(be[x],be[y]); nadd(be[y],be[x]); &#125; &#125; SPFA(be[1]); spfa(be[1]); for(i=1;i&lt;=ntot;i++) &#123; x=nst[i];y=nen[i]; if(dist[x]!=-1e9&amp;&amp;dis[y]!=-1e9)ans=max(ans,dist[x]+dis[y]-size[be[1]]); &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>Tarjan</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3761 送外卖（最短路+状压dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3761-%E9%80%81%E5%A4%96%E5%8D%96%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF-%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3761送外卖问题描述 暑期期间，何老板闲来无事，于是买了辆摩托车，签约某团外卖，跑起来送外卖的业务。 何老板负责的区域里有n个住宅小区(编号1到n)，小区间通过m条双向道路相连，两个小区间最多只有一条道路相连，也不存在某小区自己到它自己的道路。每条道路有一定的长度。 何老板先到1号小区的餐馆去领餐，然后去k个小区送餐(编号2,3,4,...,k+1)，最终到n号小区的加油站去给摩托车加油。要到k个小区去送餐，根据下单时间，公司规定了其中某些小区送餐的先后顺序，比如i小区的餐必须在给j小区送餐前送到。何老板希望在满足公司要求的情况下，使得行走的总路程最少，请你帮他计算一下。 例如，下图所示，起点为1号终点为8号小区。期间要给2、3、4、5号小区送餐。公司规定，给2号小区送餐后才能给3号小区送餐，给3号小区送餐后才能给4、5号小区送餐。最短的行程方案是1—&gt;2—&gt;4—&gt;3—&gt;4—&gt;5—&gt;8,总路程为19。 注意，可以先经过某些后送餐的小区而不停下来给它们送餐。假如，要送4号小区后才能给3号小区送餐，何老板可以从2号经过3号到达4号小区，中间虽然经过了3号小区，但他没有停下来，这样就不违法公司的规定了。 输入格式 第一行，3个空格间隔的整数n,m,k 接下来m行，每行三个整数x,y,z表示小区x也小区y间有一条长度为z的道路(1&lt;=x,y&lt;=n 1&lt;=z&lt;=1000) 接下来一行，一个整数t,表示公司有t条要求(0&lt;=t&lt;=k*(k-1)/2) 接下来t行，每行两个整数x和y,表示给x小区送餐后才能给y号小区送餐 (2&lt;=x,y&lt;=k+1 x!=y) 输出格式 一行，一个整数，表示所求最短总路程。 样例输入 8 15 41 2 31 3 41 4 41 6 21 7 32 3 62 4 22 5 23 4 33 6 33 8 64 5 24 8 65 7 45 8 632 33 43 5 样例输出 19 观察题目我们发现需要送餐的小区最多只有20个，于是想到状压dp来处理。再观察发现我们可以预先求出这20个小区+1号点+n号点两两之间的最短路，那么我们就将原图缩小成了只有22个点的新图，两两之间的距离就是原图中的最短路。之后写出dp方程$$F[i][S]=min{F[k][j]+dis[k][i]},S=j|(1&lt;&lt;k-2)$$这个方程表示从k号点走到i号点，j为经过的点集。当然我们还要注意到走到一个点时，必须满足一些关系，即有些点需要先到。那么我们可以用拓扑排序的方法预处理出这些关系。即对于点x，用$P$表示在x之前送餐的点的集合。具体实现可参照代码。那么我们在转移时只需要满足$S\&amp;P[i]==P[i]$即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#define N 23333#define M 433333using namespace std;queue&lt;int&gt;S,Q;int T,n,m,k,t,tt[55][55],RU[55],P[55];int TOT,LA[N],NE[M],EN[M],LE[M];int dis[N][25],F[25][1050000],dist[25][25],ans=1e9;bool mark[N];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void SPFA(int s)&#123; int i,x,y; for(i=1;i&lt;=n;i++)dis[i][s]=1e9; dis[s][s]=0;mark[s]=1;Q.push(s); while(!Q.empty()) &#123; x=Q.front(); Q.pop(); mark[x]=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(dis[y][s]&gt;dis[x][s]+LE[i]) &#123; dis[y][s]=dis[x][s]+LE[i]; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125;&#125;int main()&#123; int i,j,p,x,y,z; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; scanf("%d",&amp;t); for(i=1;i&lt;=t;i++) &#123; scanf("%d%d",&amp;x,&amp;y); tt[x][y]=1;RU[y]++; &#125; for(i=2;i&lt;=k+1;i++)if(!RU[i])S.push(i); while(!S.empty()) &#123; x=S.front();S.pop(); for(i=2;i&lt;=k+1;i++) if(tt[x][i]) &#123; RU[i]--; tt[x][i]=0; P[i]=P[i]|(1&lt;&lt;x-2); if(!RU[i])S.push(i); &#125; &#125; for(i=1;i&lt;=k+1;i++)SPFA(i); T=k+2; for(i=1;i&lt;T;i++) &#123; for(j=1;j&lt;T;j++)dist[i][j]=dis[j][i]; dist[i][T]=dis[n][i]; dist[T][i]=dis[n][i]; &#125; P[T]=(1&lt;&lt;k)-1; memset(F,-1,sizeof(F)); F[1][0]=0; for(i=0;i&lt;P[T];i++) for(j=1;j&lt;T;j++) &#123; if(F[j][i]==-1)continue; for(p=2;p&lt;T;p++) &#123; x=i|(1&lt;&lt;(p-2)); if(((x&amp;P[p])==P[p])&amp;&amp;(F[p][x]==-1||F[p][x]&gt;F[j][i]+dist[j][p])) F[p][x]=F[j][i]+dist[j][p]; &#125; &#125; for(i=1;i&lt;T;i++) if(F[i][P[T]]!=-1)ans=min(ans,F[i][P[T]]+dist[i][T]); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
        <category>杂学</category>
        <category>最短路</category>
        <category>状态压缩</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>最短路</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3777 卡牌操作（线段树）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3777-%E5%8D%A1%E7%89%8C%E6%93%8D%E4%BD%9C%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3777卡牌操作问题描述 有n张卡片在桌上一字排开，每张卡片上有两个数，第i张卡片上，正面的数为a[i]，反面的数为b[i]。现在，有m个熊孩子来破坏你的卡片了！ 第i个熊孩子会交换c[i]和d[i]两个位置上的卡片。 每个熊孩子捣乱后，你都需要判断，通过任意翻转卡片（把正面变为反面或把反面变成正面，但不能改变卡片的位置），能否让卡片正面上的数从左到右单调不降。 输入格式 第一行一个n。 接下来n行，每行两个数a[i],b[i]。 接下来一行一个m。 接下来m行，每行两个数c[i],d[i]。 输出格式 m行，每行对应一个答案。如果能成功，输出TAK，否则输出NIE。 样例输入 4 2 5 3 4 6 3 2 7 2 3 4 1 3 样例输出 NIE TAK 提示 【样例解释】 交换3和4后，卡片序列为(2,5) (3,4) (2,7) (6,3)，不能成功。 交换1和3后，卡片序列为(2,7) (3,4) (2,5) (6,3)，翻转第3张卡片，卡片的正面为2,3,5,6，可以成功。 n≤200000，m≤1000000，0≤a[i],b[i]≤10000000,1≤c[i],d[i]≤n. 首先用图论的思想，将一个卡牌看成两个点$A_i$和$B_i$，不妨设$A_i&lt;=B_i$，如果$A_i$的值小于$A_{i+1}$，那么就连一条从$A_i$指向$A_{i+1}$的边，同理处理所有点。那么是否有解的问题就变成了问是否存在一条路径可以从1走到n。 然后用到线段树维护连通性。 我们讨论一个区间$[L,R]$，用Va表示从$A_L$出发能够到达$R$号点时最小的权值，Vb表示从$B_L$出发。那么我们ls为区间的左儿子，rs为右儿子，那么我们需要考虑是否能通过左右儿子的值来算出$[L,R]$的值。令mid为$L+R&gt;&gt;1$。 首先我们考虑算出$Va_{[L,R]}$那么如果$Va_{ls}&lt;=A_{mid+1}$，那么意味着从mid点可以连到$A_{mid+1}$，所以$Va_{[L,R]}=Va_{rs}$。否则讨论$Va_{ls}&lt;=B_{mid+1}$，成立就意味着从mid点可以连到$B_{mid+1}$，所以$Va_{[L,R]}=Vb_{rs}$。如果都不满足，那么mid不能连到mid+1，意味着不存在一条从$A_L$到$A_R$或$B_R$的路径，那么$Va_{[L,R]}=inf$。 $Vb_{[L，R]}$同理计算。最后只需要看$Va_{[1,n]}$和$Vb_{[1,n]}$是否存在就行了。 关于修改显然就是单点修改了。具体可以参考代码。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 222222#define M 2222222using namespace std;int n,A[N],B[N],m;int ls[M],rs[M],va[M],vb[M],tot;void UD(int p,int l,int r)&#123; int mid=(l+r&gt;&gt;1)+1; if(va[ls[p]]&lt;=A[mid])va[p]=va[rs[p]]; else if(va[ls[p]]&lt;=B[mid])va[p]=vb[rs[p]]; else va[p]=1e9; if(vb[ls[p]]&lt;=A[mid])vb[p]=va[rs[p]]; else if(vb[ls[p]]&lt;=B[mid])vb[p]=vb[rs[p]]; else vb[p]=1e9;&#125;int BT(int x,int y)&#123; int p=++tot; if(x&lt;y) &#123; int mid=x+y&gt;&gt;1; ls[p]=BT(x,mid); rs[p]=BT(mid+1,y); UD(p,x,y); &#125; else va[p]=A[x],vb[p]=B[x]; return p;&#125;void CHA(int p,int l,int r,int k)&#123; if(l==r)&#123;va[p]=A[l];vb[p]=B[l];return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)CHA(ls[p],l,mid,k); else CHA(rs[p],mid+1,r,k); UD(p,l,r);&#125;int main()&#123; int i,x,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;A[i],&amp;B[i]); if(A[i]&gt;B[i])swap(A[i],B[i]); &#125; BT(1,n); scanf("%d",&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); swap(A[x],A[y]); swap(B[x],B[y]); CHA(1,1,n,x); CHA(1,1,n,y); if(va[1]!=1e9||vb[1]!=1e9)puts("TAK"); else puts("NIE"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3985 (HNOI 2012) 矿场搭建（Tarjan求割点）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3985-HNOI-2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA%EF%BC%88Tarjan%E6%B1%82%E5%89%B2%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3985 [HNOI2012] 矿场搭建问题描述 煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 输入格式 有若干组数据，每组数据的第一行是一个正整数 N（N≤500），表示工地的隧道数， 接下来的 N 行每行是用空格隔开的两个整数 S 和 T，表示挖 煤点S 与挖煤点 T 由隧道直接连接。 输入数据以 0 结尾。 输出格式 输入有多少组数据，输出就有多少行。每行对应一组输入数据的 结果。 其中第 i 行以 Case i: 开始（注意大小写，Case 与 i 之间有空格，i 与:之间无空格，: 之后有空格），其后是用空格隔开的两个正整数，第一个正整数表示对于第 i 组输入数据至少需 要设置几个救援出口，第二个正整数表示对于第 i 组输入数据不同最少救援出口的设置方案总 数。 输入数据保证答案小于 2^64。输出格式参照以下输入输出样例。 样例输入 9 1 3 4 1 3 5 1 2 2 6 1 5 6 3 1 6 3 2 6 1 2 1 3 2 4 2 5 3 6 3 7 0 样例输出 Case 1: 2 4 Case 2: 4 1 提示 Case 1 的四组解分别是(2,4),(3,4),(4,5),(4,6)； Case 2 的一组解为(4,5,6,7)。 此题容易想到割点，因为割点肯定不需要放出口，并且一个割点分出的分出联通块都需要放一个出口。所以我们用Tarjan求出割点，把割点都删掉，再来求联通块。 观察发现，如果一个联通块和两个或以上的割点相连，这个联通块不需要放出口，那么我们在求联通块的时候顺便统计相连的割点数。然后每一个需要放出口的联通块都只需要放一个即可，然后每一个点都可以放，有size种方案，然后乘法原理搞一下就行了。 但是仔细观察发现，一个联通块只需要放一个是有条件的，即他至少和一个割点相连，如果一个联通块不和任意一个割点相连，那么他需要放两个出口，这是容易证明的。因此有$C_{size}^{2}$种方案。 于是此题只需要求割点，再统计联通块相连的割点数和size即可。至于如何统计可以参考代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define M 1234#define int long longusing namespace std;int n,m,VT,T,scc,ans,cnt,tsize[M],size[M],dfn[M],low[M],be[M],cp[M],F[M];int TOT,LA[M],EN[M],NE[M],V[M][M];bool mark[M],mmark[M];void Clear()&#123; TOT=1;ans=1;cnt=0;T++; scc=0;VT=0;n=0; memset(V,0,sizeof(V)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(be,0,sizeof(be)); memset(cp,0,sizeof(cp)); memset(LA,0,sizeof(LA)); memset(F,0,sizeof(F)); memset(mark,0,sizeof(mark)); memset(mmark,0,sizeof(mmark)); memset(size,0,sizeof(size)); memset(tsize,0,sizeof(tsize));&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void Tarjan(int u,int f)&#123; int i,v; dfn[u]=low[u]=++VT; for(i=LA[u];i;i=NE[i]) &#123; v=EN[i]; if(!dfn[v]) &#123; Tarjan(v,u); tsize[u]++; low[u]=min(low[u],low[v]); if(low[v]&gt;=dfn[u]&amp;&amp;f!=0)mark[u]=1; &#125; else if(v!=f)low[u]=min(low[u],dfn[v]); &#125; if(f==0&amp;&amp;tsize[u]&gt;1)mark[u]=1;&#125;void FBE(int x)&#123; int i; if(mark[x])return;//是割点，不讨论 size[scc]++;//统计size be[x]=scc; for(i=LA[x];i;i=NE[i]) &#123; if(mark[EN[i]]&amp;&amp;F[EN[i]]!=scc) &#123; F[EN[i]]=scc;//标记该割点已讨论 cp[scc]++;//统计相连的割点数 continue; &#125; if(!be[EN[i]])FBE(EN[i]); &#125;&#125;main()&#123; int i,x,y; scanf("%lld",&amp;m); while(m) &#123; Clear(); for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld",&amp;x,&amp;y); if(V[x][y]||V[y][x])continue; V[x][y]=V[y][x]=1;//去重边 ADD(x,y);ADD(y,x); if(n&lt;x)n=x; if(n&lt;y)n=y; mmark[x]=mmark[y]=1;//标记是否存在这个点 &#125; for(i=1;i&lt;=n;i++)if(!dfn[i]&amp;&amp;mmark[i])Tarjan(i,0);//求割点 for(i=1;i&lt;=n;i++)if(!be[i]&amp;&amp;!mark[i]&amp;&amp;mmark[i])scc++,FBE(i);//找联通块 for(i=1;i&lt;=scc;i++)//计算答案，cnt表示出口数，ans表示方案数 &#123; if(cp[i]==0)cnt+=2,ans*=(size[i]*(size[i]-1)/2); else if(cp[i]&lt;=1)cnt++,ans*=size[i]; &#125; printf("Case %lld: %lld %lld\n",T,cnt,ans); scanf("%lld",&amp;m); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3762 守夜人 （并查集）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3762-%E5%AE%88%E5%A4%9C%E4%BA%BA-%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3762守夜人问题描述 鉴于john snow当选了新的守夜人总司令，艾里沙爵士感觉非常不爽，想搞点事情来难倒snow。艾里沙爵士告诉你有一个n项的序列X0,X1,X2…..Xn-1。（其中每一项均在int范围之内）但是你现在不知道其中的任何一项。艾里沙会逐步的告诉你一些信息并且问你一些问题。共有两种类型的信息和一种类型的询问。 I p v : 告诉你 Xp = v I p q v : 告诉你 Xp XOR Xq = v Q k p1 p2 . . . pk : 询问Xp1 XOR Xp2 XOR . . . XOR Xpk的值 k≤15 输入格式 会有多组测试数据但不会超过10组。每一组数据以两个整数开始：n , Q(1 ≤ n ≤ 20, 000, 2 ≤ Q ≤ 40, 000)题目描述中的k是一个不大于15的整数。最后一组数据为n==Q==0，不用进行运算。 输出格式 对于每组数据，输出第一行为数据的组数，接下来的每一行对应一次询问的答案。如果根据前面给出的信息无法算出答案，则输出“I don’t know.”。如果与已知信息冲突，输出“The first i facts are conflicting.”，并结束对于这一组数据的运算，其中i为这组数据出现过的的信息条数（不含询问，包含当前这一条信息）。 样例输入 2 6I 0 1 3Q 1 0Q 2 1 0I 0 2Q 1 1Q 1 03 3I 0 1 6I 0 2 2Q 2 1 22 4I 0 1 7Q 2 0 1I 0 1 8Q 2 0 10 0 样例输出 Case 1:I don’t know.312Case 2:4Case 3:7The first 2 facts are conflicting. 提示 注释：鉴于两种I操作的输入比较麻烦，这里给出一种参考输入方法：gets(s);if(sscanf(s,”%d%d%d”,&amp;a,&amp;b,&amp;v)==2)//这一行输入了两个整数，要先除去行首的字母,具体可参考代码 这题显然是带权并查集，用$D[i]$来记录下$i$和的他父亲的异或值。考虑如何处理三个操作。 先处理路径压缩，假设fx是x的父亲，ffx是fx的父亲，由异或运算的特性可知x^ffx=x^fx^fx^ffx=D[x]^D[fx]，所以路径压缩就解决了。 考虑已知$x_p$^$x_q=v$，那么合并p，q所在集合，令fp是p的根，fq是q的根，那么将fq设为fp的父亲，有D[fp]=fp^fq=p^fp^q^fq^p^q=D[p]^D[q]^v，所以合并操作解决。 然后问题是处理操作一，这里有两种处理办法，一种是添加虚拟节点，将操作一视为操作二，并保证虚拟节点永远是根。具体可以参考THH的博文。 我用的是第二种操作，直接用数组X[i]记录下他的值即可，然后为了维护X[i]，需要将路径压缩中添加一步，即如果父亲的X值已知，那么就顺便把儿子的X值算出来，因为知道他们的异或和。同时合并时要优先将X值已知的元素作为父亲。 然后考虑如何判断矛盾，关于操作一，那么只需要和X数组比较一下即可。对于操作二稍复杂，我们需要判断两种情况：1.给出的两个数p，q位于同一集合，那么判断给出的值是否等于D[p]^D[q]。2.p，q不在同一集合，那么判断是否两个数的X值都已知，如果都已知就判断给出的值是否等于X[p]^X[q] 最后处理询问操作，首先将询问的k个元素中已知的元素找出来并标记，直接异或到ans中，然后处理未知的元素，这些未知的元素必然要两两配对异或起来，因此直接暴力找位于同一集合的元素异或起来并异或到答案中，如果有不能配对的元素，那么就得不到答案，如果都配对的，就找到了。这里写的时候优化一下可以$O(k)$解决。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 43333using namespace std;int n,m,F[N],X[N],V[N],A[20];bool mark1[20],mark2[20];char s[N];int GF(int x)&#123; if(F[x]==x)return x; int t=F[x]; F[x]=GF(F[x]); if(X[t]!=-1)X[x]=V[x]^X[t];//更新X值 V[x]^=V[t];//更新V值 return F[x];&#125;int main()&#123; int i,j,a,b,v,p,q,cnt,k,o,fx,fy,pp,T=0,ans; scanf("%d%d",&amp;n,&amp;m); while(n!=0) &#123; printf("Case %d:\n",++T); for(i=1;i&lt;=n;i++)F[i]=i,V[i]=0,X[i]=-1; cnt=0; for(i=1;i&lt;=m;i++) &#123; scanf("%s",s); if(s[0]=='I') &#123; cnt++; gets(s); if(sscanf(s,"%d%d%d",&amp;a,&amp;b,&amp;v)==2) &#123; a++; p=GF(a); if(X[a]!=-1&amp;&amp;b!=X[a]) &#123; printf("The first %d facts are conflicting.\n",cnt); break; &#125; X[a]=b; F[a]=a;F[p]=a;//把他设为所在集合的根 V[p]=V[a];V[a]=0; continue; &#125; a++;b++; p=GF(a);q=GF(b); if(X[a]!=-1&amp;&amp;X[b]!=-1) &#123; if((X[a]^X[b])!=v) &#123; printf("The first %d facts are conflicting.\n",cnt); break; &#125; &#125; if(p==q) &#123; if((V[a]^V[b])!=v) &#123; printf("The first %d facts are conflicting.\n",cnt); break; &#125; &#125; if(X[p]!=-1)swap(p,q);//优先将X值已知的元素作为根 F[p]=q; V[p]=V[a]^V[b]^v; &#125; else &#123; gets(s); o=sscanf(s,"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",&amp;k,&amp;A[1],&amp;A[2],&amp;A[3],&amp;A[4],&amp;A[5],&amp;A[6],&amp;A[7],&amp;A[8],&amp;A[9],&amp;A[10],&amp;A[11],&amp;A[12],&amp;A[13],&amp;A[14],&amp;A[15]);//智障的读入 memset(mark1,0,sizeof(mark1)); pp=0;ans=0; for(j=1;j&lt;=k;j++)A[j]++,GF(A[j]); for(j=1;j&lt;=k;j++) if(X[A[j]]==-1&amp;&amp;mark1[j]==0)//未知元素 &#123; fx=GF(A[j]); ans^=V[A[j]]; mark1[j]=1;o=1; for(p=1;p&lt;=k;p++) if(X[A[p]]==-1&amp;&amp;mark1[p]==0) &#123; fy=GF(A[p]); if(fx==fy) &#123; o++;ans^=V[A[p]]; mark1[p]=1; &#125; &#125; if(o&amp;1)&#123;pp=1;break;&#125;//一个集合中可以一次处理完 &#125; else if(mark1[j]==0)ans^=X[A[j]],mark1[j]=1;//已知元素 if(pp)&#123;printf("I don't know.\n");continue;&#125; printf("%d\n",ans); &#125; &#125; while(i&lt;m)&#123;gets(s);i++;&#125; scanf("%d%d",&amp;n,&amp;m); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3768 数列操作（单调队列/栈+DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3768-%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A0%88-DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3768数列操作问题描述 给出N个正整数数列a[1..N]，再给出一个正整数k，现在可以重复进行如下操作：每次选择一个大于k的正整数a[i]，将a[i]减去1，选择a[i-1]或a[i+1]中的一个加上1。经过一定次数的操作后，问最大能够选出多长的一个连续子序列，使得这个子序列的每个数都不小于k。总共给出M次询问，每次询问给出的k不同，你需要分别回答。 输入格式 第一行两个正整数N (N &lt;= 300,000)和M (M &lt;= 50)。第二行N个正整数，第i个正整数表示a[i] (a[i] &lt;= 10^9)。第三行M个正整数，第i个正整数表示第i次询问的k (k &lt;= 10^9)。 输出格式 共一行，输出M个正整数，第i个数表示第i次询问的答案。 样例输入 5 61 2 1 1 51 2 3 4 5 6 样例输出 5 5 2 1 1 0 考虑一段满足条件的区间$[L+1,R]$，那么一定有$(R-L)*k&lt;=Sum[R]-Sum[L]$。为了方便讨论，我们把序列中每个数都减去k，那么有$0&lt;=Sum[R]-Sum[L]$即$Sum[R]&gt;=Sum[L]$然后我们考虑以i为右端点的区间，那么需要找到满足$Sum[j]&lt;=Sum[i]$的最小的j，鉴于时间复杂度的要求，我们考虑维护单调性。 假设$Sum[i]&gt;=Sum[i-1]$，那么讨论$Sum[i]$肯定是更优的。假设$Sum[i]&lt;Sum[i-1]$，那么小于$Sum[i]$的也一定小于$Sum[i-1]$ 因此我们先预处理从左往右维护一个单调递减的队列/栈，然后从右往左讨论，将小于$Sum[i]$的全部出队，这样就能找到第一个小于$Sum[i]$的数，并且对于$Sum[i-1]$的讨论不会产生影响，因为第一个小于$Sum[i]$的数也小于$Sum[i-1]$，否则$i-1$就不需要讨论。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(a,b) ((a&gt;b)?(a):(b))#define N 333333using namespace std;long long n,m,A[N],S[N];long long Q[N],top,ans;int main()&#123; int i,j,k; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]); while(m--) &#123; scanf("%lld",&amp;k); top=0;Q[++top]=0; for(i=1;i&lt;=n;i++) &#123; S[i]=S[i-1]+A[i]-k; if(S[i]&lt;S[Q[top]])Q[++top]=i; &#125; ans=0; for(i=n;i&gt;=0;i--) &#123; while(top&gt;0&amp;&amp;S[i]&gt;=S[Q[top]])top--; ans=max(ans,i-Q[top+1]); &#125; printf("%lld ",ans); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4239 追捕游戏（LCA）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4239-%E8%BF%BD%E6%8D%95%E6%B8%B8%E6%88%8F%EF%BC%88LCA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4239追捕游戏问题描述 何老板最近在玩一款追铺游戏，游戏虽然简单，何老板仍旧乐此不疲。 游戏地图中有n座城市由n-1条双向道路连接。任意两座城市都可相互到达。一名罪犯从A城市出发沿最短路线逃往B城市。在罪犯出发的同时，何老板控制一名警察从C城市出发去追捕那名罪犯。每条道路都有一定的长度(单位米)。罪犯和警察行走的速度相同，都是1秒钟行走1米。 若罪犯到达B城市时还没有被抓住，何老板就输掉了这局游戏。何老板总共玩了m局游戏，每局游戏开始前，何老板想知道他是否能赢下这局游戏，如果能，警察最少行走多少米才能抓到罪犯？ 输入格式 第一行，两个整数n和m 接下来n-1行，每行三个整数X,Y,Z，表示城市X和Y之间有一条长度为Z的道路相连。 接下来m行，每行三个整数A,B,C。 输出格式 m行，每行对应一局游戏的结果。若能抓捕到罪犯。输出一个整数，表示警察最少需要行走的距离。若无法抓到罪犯，输出-1。 样例输入 11 21 2 61 3 31 4 33 5 23 6 54 7 96 10 35 8 45 9 38 11 811 9 102 4 7 样例输出 109 提示 【样例解释】 第1局在5号城市抓住罪犯。第2局在4号城市抓住罪犯。 【数据范围】对于约40% 的数据：1&lt;=N,M&lt;=2000对于约100% 的数据：1&lt;=N,M&lt;=100000 1&lt;=道路的长度&lt;=10000 此题容易发现A-&gt;B的路径是唯一的，因此警察从C到A-&gt;B路径上距离C最近的一点T等待是最优的。那么我们需要算出$dis(B,T)$和$dis(C,T)$。观察可以发现以下关系式。$$2\times dis(B,T)=dis(A,B)+dis(C,B)-dis(A,C)$$$$2\times dis(C,T)=dis(A,C)+dis(B,C)-dis(A,B)$$于是我们就算出了$dis(B,T)$和$dis(C,T)$,然后判断一下谁先到即可。 除此之外，还可以用一个玄学结论，即A,B,C两两求LCA后，必定有两个LCA相同，只出现了一次的那个LCA就是T点。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 100005#define M 200005using namespace std;int n,m,S=20,fa[N][24],dis[N],dep[N];int TOT,LA[N],NE[M],EN[M],LE[M];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int f,int l)&#123; int i,y; fa[x][0]=f; dis[x]=dis[f]+l; dep[x]=dep[f]+1; for(i=1;i&lt;=S;i++)fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)DFS(y,x,LE[i]); &#125;&#125;int LCA(int x,int y)&#123; int i,t; if(dep[x]&lt;dep[y])x^=y^=x^=y; t=dep[x]-dep[y]; for(i=0;i&lt;=S;i++) if(t&amp;(1&lt;&lt;i))x=fa[x][i]; if(x==y)return y; for(i=S;i&gt;=0;i--) if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int DIS(int x,int y,int z)&#123;return dis[x]+dis[y]-2*dis[z];&#125;int main()&#123; int i,x,y,z,f1,f2,f3,t1,t2; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; DFS(1,0,0); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); f1=LCA(x,y); f2=LCA(x,z); f3=LCA(y,z); t1=DIS(x,y,f1)+DIS(x,z,f2)-DIS(y,z,f3)&gt;&gt;1; t2=DIS(x,z,f2)+DIS(y,z,f3)-DIS(x,y,f1)&gt;&gt;1; if(t1&lt;t2)printf("-1\n"); else printf("%d\n",t2); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3775 数列操作（单调队列+DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3775-%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3775数列操作问题描述 给定一个长度为n的序列，你有一次机会选中一段连续的长度不超过d的区间，将里面所有数字全部修改为0。请找到最长的一段连续区间，使得该区间内所有数字之和不超过p。 输入格式 第一行包含三个整数n,p,d(1&lt;=d&lt;=n&lt;=300000，0&lt;=p&lt;=10^16)。第二行包含n个正整数，依次表示序列中每个数wi。 输出格式 包含一行一个正整数，即修改后能找到的最长的符合条件的区间的长度。 样例输入 9 7 23 4 1 9 4 1 7 1 3 样例输出 5 由于要讨论区间和，所以先求出前缀和数组$Sum[i]$，现在如果我们选择以j结尾的一个区间，那么有$Sum[j]-Sum[i]-(Sum[x]-Sum[x-d])&lt;=p，x-d&gt;=i，x&lt;=j$，所求的区间就是$[i+1,j]$。那么我们需要找到满足条件的最小的i。考虑用单调队列优化，由于$Sum$数组是单调递增的，因此用$l$记下当前讨论的区间的左端点，如果左端点不满足上述条件，那么右移，现在只需要找到当前区间中$(Sum[x]-Sum[x-d])$的最大值即可，这个用单调队列维护即可。然而我石乐志，用堆来维护。 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;#include&lt;queue&gt;#define ll long long#define N 333333using namespace std;struct node&#123;ll v,x;&#125;;bool operator&lt;(node a,node b)&#123;return a.v&lt;b.v;&#125;priority_queue&lt;node&gt;Q;deque&lt;ll&gt;P;node tmp;ll n,p,d,i,j,k,S[N],ans;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;p,&amp;d); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;k),S[i]=S[i-1]+k; for(i=0;i&lt;d;i++)P.push_back(i); for(i=d;i&lt;=n;i++) &#123; tmp.v=S[i]-S[i-d]; tmp.x=i-d; Q.push(tmp); P.push_back(i); while(P.size()&amp;&amp;p+S[P.front()]+Q.top().v&lt;S[i]) &#123; P.pop_front(); while(Q.size()&amp;&amp;Q.top().x&lt;P.front())Q.pop(); &#125; ans=max(ans,i-P.front()); &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4241 （NOIP 2016）蚯蚓（单调队列）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-4241-%EF%BC%88NOIP-2016%EF%BC%89%E8%9A%AF%E8%9A%93%EF%BC%88%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P4241【NOIP2016 DAY2】蚯蚓问题描述 输入格式 第一行包含六个整数n,m,q,u,v,t，其中：n,m,q的意义见问题描述； u,v,t均为正整数；你需要自己计算p=u/v(保证0 &lt; u &lt; v)t是输出参数，其含义将会在输出格式中解释。 第二行包含n个非负整数，为ai,a2,…,an，即初始时n只蚯蚓的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。 输出格式 第一行输出⌊m/t⌋ 个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。 第二行输出⌊(n+m)/t⌋个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序 依次输出排名第t，第2t，第3t……的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要 输出，你也应输出一个空行。 请阅读样例来更好地理解这个格式。 样例输入 1 3 7 1 1 3 13 3 2 样例输出 1 3 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2 样例输入 2 3 7 1 1 3 23 3 2 样例输出 2 4 4 56 5 4 3 2 样例输入 3 3 7 1 1 3 93 3 2 样例输出 3 2 提示 一开始想到用一个堆来维护最长的蚯蚓，用全局标记来解决长度增加。但是这样只能得60分。鉴于数据范围，我们需要$O(n)$的算法，于是考虑能否维护单调性，我们发现切出的两条蚯蚓中，较大的一条和较小的一条都可以维护单调性，因为如果我们先切长的蚯蚓，那么切出来的较长的蚯蚓肯定比后切的蚯蚓切出的要长，这个证明比较简单。于是我们可以用三个单调队列来维护，一个队列中存原有的蚯蚓，一个存切出的蚯蚓中较长的一条，一个存切出的蚯蚓中较短的一条，这三个队列都是单调的，因此答案很容易得到。推荐手工队列。 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define ll long long#define N 12345678using namespace std;ll A[N],B[N],C[N],la,ra,lb,rb,lc,rc;ll n,m,q,u,v,t,s,i,j,k,x,y,z;bool cmp(ll a,ll b)&#123;return a&gt;b;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]); la=lb=lc=1;ra=n;sort(A+1,A+n+1,cmp); for(i=1;i&lt;=m;i++) &#123; if(la&lt;=ra&amp;&amp;(A[la]&gt;=B[lb]||lb&gt;rb)&amp;&amp;(A[la]&gt;=C[lc]||lc&gt;rc))x=A[la++]+s; else if(lb&lt;=rb&amp;&amp;(B[lb]&gt;=C[lc]||lc&gt;rc))x=B[lb++]+s; else if(lc&lt;=rc)x=C[lc++]+s; if(i%t==0)printf("%lld ",x); y=floor(x*u/v);z=x-y; if(y&lt;z)y^=z^=y^=z; s+=q; B[++rb]=y-s; C[++rc]=z-s; &#125; printf("\n"); for(i=1;i&lt;=n+m;i++) &#123; if(la&lt;=ra&amp;&amp;(A[la]&gt;=B[lb]||lb&gt;rb)&amp;&amp;(A[la]&gt;=C[lc]||lc&gt;rc))x=A[la++]+s; else if(lb&lt;=rb&amp;&amp;(B[lb]&gt;=C[lc]||lc&gt;rc))x=B[lb++]+s; else if(lc&lt;=rc)x=C[lc++]+s; if(i%t==0)printf("%lld ",x); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1725 数字（数位dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-1725-%E6%95%B0%E5%AD%97%EF%BC%88%E6%95%B0%E4%BD%8Ddp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P1725数字问题描述 给出一个整数n和一个数组a。数组a中包含十个整数，编号0到9。你的任务是统计满足下列条件的正整数的个数：1.该正整数的长度不能超过n位；2.该正整数的最高位不能是0；3.数字i(0&lt;=i&lt;=9)在该正整数中至少出现a[i]次。 输入格式 第一行一个整数n(1&lt;=n&lt;=100)。第二行，10个空格间隔的整数，表示a[0],a[1]…a[9]里面存的数字 输出格式 一行，一个整数，表示满足条件的数字的个数，结果可能很大，输出与1000000007取模后的结果。 样例输入1： 10 0 0 0 0 0 0 0 0 1 样例输入2： 21 1 0 0 0 0 0 0 0 0 样例输入3： 31 1 0 0 0 0 0 0 0 0 样例输入1： 1 样例输入2： 1 样例输入3： 36 用$F[i][j]$表示用数字$[j,9]$构成长度为$i$的数字的方案数。 递推方程：$F[i][j]=\sum F[i-k][j+1]*C_{i}^{k}$ 意味着在$i$个位置中放$k$个数字$j$，这样就保证了满足题目条件，然后剩下的位置上放$[j+1,9]$的排列方式就是$F[i-k][j+1]$ 关于$0$需要特殊讨论，因为$0$不能放首位，因此有$F[i][0]=\sum F[i-k][1]*C_{i-1}^{k}$ 代码： 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 105#define ll long longusing namespace std;ll n,C[N][N],mod=1000000007,a[N],F[N][10],ans;int main()&#123; ll i,j,k; scanf("%lld",&amp;n); for(i=0;i&lt;=9;i++)scanf("%lld",&amp;a[i]); for(i=0;i&lt;=n;i++)C[i][0]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;//预处理组合数 for(i=a[9];i&lt;=n;i++)F[i][9]=1;//赋初值 for(j=8;j&gt;=1;j--) for(i=a[j];i&lt;=n;i++) for(k=a[j];k&lt;=i;k++)F[i][j]=(F[i][j]+F[i-k][j+1]*C[i][k])%mod; for(i=a[0];i&lt;=n;i++) for(k=a[0];k&lt;=i;k++) if(i&gt;0)F[i][0]=(F[i][0]+F[i-k][1]*C[i-1][k])%mod; for(i=1;i&lt;=n;i++)ans=(ans+F[i][0])%mod; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2498 （NOIP 2013）华容道（BFS+最短路）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2498-%EF%BC%88NOIP-2013%EF%BC%89%E5%8D%8E%E5%AE%B9%E9%81%93%EF%BC%88BFS-%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2498【NOIP2013-D2T3】华容道问题描述 小B最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道：给定一种局面，华容道是否根本就无法完成，如果能完成，最少需要多少时间。小B玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的：1.在一个nm棋盘上有nm个格子，其中有且只有一个格子是空白的，其余nm-1个格子上每个格子上有一个棋子，每个棋子的大小都是11的；2.有些棋子是固定的，有些棋子则是可以移动的；3.任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。 给定一个棋盘，游戏可以玩q次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第i次玩的时候，空白的格子在第EXi行第EYi列，指定的可移动棋子的初始位置为第SXi行第SYi列，目标位置为第TXi行第TYi列。假设小B每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小B每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。 输入格式 第一行有3个整数，每两个整数之间用一个空格隔开，依次表示n,m和q；接下来的n行每行有 m 个整数，描述一个n*m的棋盘。每两个整数之间用一个空格隔开，每个整数描述棋盘上一个格子的状态，0表示该格子上的棋子是固定的，1表示该格子上的棋子可以移动或者该格子是空白的。接下来的q行，每行包含6个整数依次是EXi,EYi,SXi,SYi,TXi,TYi,每两个整数之间用一个空格隔开，表示每次游戏空白格子的位置，指定棋子的初始位置和目标位置。 输出格式 输出有q行，每行包含1个整数，表示每次游戏所需要的最少时间，如果某次游戏无法完成目标则输出−1。 样例输入 3 4 20 1 1 10 1 1 00 1 0 03 2 1 2 2 21 2 2 2 3 2 样例输出 2-1 此题一开始容易想到爆搜，及记录当前空白块的位置和起始块的位置，用（X1，Y1，X2，Y2）这个四元数组来记录状态直接搜，尝试发现只有30分。 观察移动的方式，可以发现如果要移动，那么需要移动的块和空白块必须相邻，于是我们可以改进一下我们的状态，用（X1，Y1，K）来表示，X1，Y1记录需要移动的块的位置，K表示空白块在该块的（上，下，左，右）四个位置。 于是我们可以用图论来解决，建边的时候讨论每一个点的4个状态分别移动到（上下左右）四个位置所需要的操作步数，这个用宽搜就可以实现，具体来讲，我们需要知道将空白块移动到目标位置，并且不经过需要移动的块所需的步数，连完边之后用最短路跑跑，跑4次最短路取达到终点的最短路径即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 12345#define M 1234567using namespace std;//1 上 4 下 2 左 3 右 struct node&#123;int x,y,s;node(int a,int b,int c)&#123;x=a;y=b;s=c;&#125;&#125;;int n,m,q,map[32][32],id[32][32][5],tot,ans;int ex,ey,sx,sy,tx,ty;int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;;int TOT,LA[N],NE[M],EN[M],LE[M];int dis[N];queue&lt;int&gt;Q;queue&lt;node&gt;P;bool F[32][32],mark[N];int GX(int x,int k)//找到对应位置的点坐标&#123; if(k==1)return x-1; if(k==4)return x+1; return x;&#125;int GY(int y,int k)&#123; if(k==2)return y-1; if(k==3)return y+1; return y;&#125;void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int Find(int x1,int y1,int x2,int y2,int x,int y)//找到从(x1,y1)到(x2,y2)的最短路径且不经过(x,y)&#123; if(x1==x2&amp;&amp;y1==y2)return 0; int i,j,k,xx,yy; memset(F,0,sizeof(F)); while(P.size())P.pop(); P.push(node(x1,y1,0)); F[x1][y1]=1; while(!P.empty()) &#123; for(i=0;i&lt;4;i++) &#123; xx=P.front().x+dx[i]; yy=P.front().y+dy[i]; if(map[xx][yy]!=0&amp;&amp;(xx!=x||yy!=y)) &#123; if(xx==x2&amp;&amp;yy==y2)return P.front().s+1; if(F[xx][yy])continue; F[xx][yy]=1; P.push(node(xx,yy,P.front().s+1)); &#125; &#125; P.pop(); &#125; return -1;&#125;int SPFA(int u)&#123; int i,x,y; memset(dis,60,sizeof(dis)); dis[u]=0;mark[u]=1;Q.push(u); while(Q.size()) &#123; x=Q.front(); Q.pop(); mark[x]=0; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(dis[y]&gt;dis[x]+LE[i]) &#123; dis[y]=dis[x]+LE[i]; if(!mark[y])mark[y]=1,Q.push(y); &#125; &#125; &#125; int sum=dis[0]; if(dis[id[tx][ty][1]]&lt;sum)sum=dis[id[tx][ty][1]]; if(dis[id[tx][ty][2]]&lt;sum)sum=dis[id[tx][ty][2]]; if(dis[id[tx][ty][3]]&lt;sum)sum=dis[id[tx][ty][3]]; if(dis[id[tx][ty][4]]&lt;sum)sum=dis[id[tx][ty][4]]; if(sum==dis[0])return -1; return sum;&#125;int main()&#123; int i,j,k,p,x,y,z,x1,y1,x2,y2; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)scanf("%d",&amp;map[i][j]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(k=1;k&lt;=4;k++)id[i][j][k]=++tot; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(k=1;k&lt;=4;k++) &#123; x1=GX(i,k);y1=GY(j,k); if(map[i][j]==0||map[x1][y1]==0)continue; for(p=0;p&lt;4;p++) &#123; x=i+dx[p]; y=j+dy[p]; if(map[x][y]!=0) &#123; if(x==x1&amp;&amp;y==y1)ADD(id[i][j][k],id[x][y][5-k],1); else &#123; z=Find(x1,y1,x,y,i,j); if(z!=-1)ADD(id[i][j][k],id[x][y][4-p],z+1); &#125; &#125; &#125;&#125; while(q--) &#123; scanf("%d%d%d%d%d%d",&amp;ex,&amp;ey,&amp;sx,&amp;sy,&amp;tx,&amp;ty); if(sx==tx&amp;&amp;sy==ty)&#123;puts("0");continue;&#125;//注意特判 ans=1e9; for(i=1;i&lt;=4;i++) &#123; x=GX(sx,i);y=GY(sy,i); if(map[x][y]==0)continue; z=Find(ex,ey,x,y,sx,sy); if(z!=-1) &#123; k=SPFA(id[sx][sy][i]); if(k!=-1)ans=min(ans,k+z); &#125; &#125; if(ans==1e9)puts("-1"); else printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2655 （HAOI 2010）计数（数位DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2655-%EF%BC%88HAOI-2010%EF%BC%89%E8%AE%A1%E6%95%B0%EF%BC%88%E6%95%B0%E4%BD%8DDP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2655【HAOI2010 Day1】计数问题描述 你有一组非零数字（不一定唯一），你可以在其中插入任意个0，这样就可以产生无限个数。比如说给定{1,2},那么可以生成数字12,21,102,120,201,210,1002,10200,等等。现在给定一个数，问在这个数之前有多少个数。（注意这个数不会有前导0）。 输入格式 只有1行，为1个整数n. 输出格式 只有整数，表示N之前出现的数的个数。 样例输入 1020 样例输出 7 一位一位的讨论，从最高位开始。用cnt数组记下每个数出现的次数 如果当前位小于N的这一位，那么后面的位置可以随便放，那么方案数是$$C_{剩下的位置数}^{cnt_0}*C_{剩下的位置数-cnt_0}^{cnt_1}……$$ 如果当前这一位等于N，那么讨论下一位。 于是只需要依次讨论每一位是几即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;char s[55];ll num[10],l,ans,c[55][55];ll GA(ll x)&#123; ll i,sum=1; for(i=0;i&lt;=9;i++) sum*=c[x][num[i]],x-=num[i]; return sum;&#125;int main()&#123; ll i,j,k; scanf("%s",&amp;s[1]);s[0]='#'; l=strlen(s)-1; for(i=0;i&lt;=50;i++)c[i][0]=1; for(i=1;i&lt;=50;i++) for(j=1;j&lt;=i;j++)c[i][j]=c[i-1][j]+c[i-1][j-1]; for(i=1;i&lt;=l;i++)num[s[i]-48]++; for(i=1;i&lt;=l;i++) &#123; for(j=0;j&lt;s[i]-48;j++) if(num[j]) &#123; num[j]--; ans+=GA(l-i); num[j]++; &#125; num[s[i]-48]--; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1533 玩具（三分+贪心+单调队列）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-1533-%E7%8E%A9%E5%85%B7%EF%BC%88%E4%B8%89%E5%88%86-%E8%B4%AA%E5%BF%83-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P1533【Usaco Nov08 Gold】玩具问题描述 Bessie的生日快到了, 她希望用D (1 &lt;= D &lt;= 100,000; 70%的测试数据都满足1 &lt;= D &lt;= 500)天来庆祝. 奶牛们的注意力不会太集中, 因此Bessie想通过提供玩具的方式来使它们高兴. 她已经计算出了第i天需要的玩具数T_i (1 &lt;= T_i &lt;= 50). Bessie的幼儿园提供了许多服务给它们的奶牛程序员们, 包括一个每天以Tc (1 &lt;= Tc &lt;= 60)美元卖出商品的玩具店. Bessie想尽可能的节省钱, 但是Farmer John担心没有经过消毒的玩具会带来传染病(玩具店卖出的玩具是经过消毒的). 有两种消毒的方式. 第1种方式需要收费C1美元, 需要N1个晚上的时间; 第2种方式需要收费C2美元, 需要N2个晚上的时间(1 &lt;= N1 &lt;= D; 1 &lt;= N2 &lt;= D; 1 &lt;= C1 &lt;= 60;1 &lt;= C2 &lt;= 60). Bessie在party结束之后把她的玩具带去消毒. 如果消毒只需要一天,那么第二天就可以拿到; 如果还需要一天, 那么第三天才可以拿到. 作为一个受过教育的奶牛, Bessie已经了解到节约的意义. 帮助她找到提供玩具的最便宜的方法. 输入格式 第 1 行: 六个用空格隔开的整数 D, N1, N2, C1, C2, Tc 第 2..D+1 行: 第 i+1 行包含一个整数: T_i 输出格式 第 1 行: 提供玩具所需要的最小费用. 样例输入 4 1 2 2 1 38216 样例输出 35 设$F(x)$表示总共买$x$个玩具提供玩具的总费用，设$G(x)$表示总共买$x$个玩具所需要的给玩具消毒的费用。 那么显然有$F(x)=G(x)+x\times Tc$那么由于此题可以用费用流求解，那么根据VFK神犇的证明，$F(x)$的一阶导数单调不降，因此$F(x)$是下凸的单峰函数。具体证明参见VFK。 那么如何求解$G(x)$，贪心即可。如果慢消毒的费用比快消毒高，那么显然只用快消毒。如果买玩具比消毒便宜，那么显然全部买。之后考虑一般情况，如果时间允许，那么显然慢消毒是更优的。因此开三个单调队列维护，维护时间单调递减。第一个队列$A$表示慢消毒的玩具，第二个队列$B$表示快消毒的玩具，第三个队列$C$表示还没有完成消毒的玩具。维护时，每天用完的玩具加到C队列中。当C队列的队首时间与现在的时间差值大于等于快消毒时间时，将他加入B中。当B队列的队首时间与现在的时间差值大于等于慢消毒时间时，将他加入A中。每次优先用C队列的队首，然后再用B队列的队尾，不够用就说明买的不够，返回无穷大。贪心的正确性是显然的，具体可参考代码。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;#define N 123456using namespace std;struct node&#123; int x,y; node(int a,int b)&#123;x=a;y=b;&#125;&#125;;deque&lt;node&gt;A,B,C;int d,n1,n2,c1,c2,tc,T[N],sum;int ok(int k)&#123; int i,j,ans; A.clear();B.clear();C.clear(); ans=(tc-c1)*k; A.push_back(node(k,0)); for(i=1;i&lt;=d;i++) &#123; while(C.size()&amp;&amp;i-C.front().y&gt;=n2)B.push_back(C.front()),C.pop_front(); while(B.size()&amp;&amp;i-B.front().y&gt;=n1)A.push_back(B.front()),B.pop_front(); j=T[i]; while(j) &#123; if(A.size()) &#123; if(A.front().x&gt;j) &#123; A.front().x-=j; ans+=c1*j;j=0; &#125; else &#123; j-=A.front().x; ans+=c1*A.front().x; A.pop_front(); &#125; &#125; else if(B.size()) &#123; if(B.back().x&gt;j) &#123; B.back().x-=j; ans+=c2*j;j=0; &#125; else &#123; j-=B.back().x; ans+=c2*B.back().x; B.pop_back(); &#125; &#125; else return 1e9; &#125; C.push_back(node(T[i],i)); &#125; return ans;&#125;void EF(int l,int r)&#123; int lmid,rmid,ans=1e9; while(l+2&lt;r) &#123; lmid=(r-l)/3+l; rmid=(lmid+r)/2; if(ok(lmid)&gt;ok(rmid))l=lmid; else r=rmid; &#125; while(l&lt;=r)ans=min(ans,ok(l)),l++; printf("%d",ans);&#125;int main()&#123; int i; scanf("%d%d%d%d%d%d",&amp;d,&amp;n1,&amp;n2,&amp;c1,&amp;c2,&amp;tc); for(i=1;i&lt;=d;i++)scanf("%d",&amp;T[i]),sum+=T[i]; if(tc&lt;=c1&amp;&amp;tc&lt;=c2)&#123;printf("%d",sum*tc);return 0;&#125; if(n1&lt;n2)swap(n1,n2),swap(c1,c2); if(c1&gt;=c2)n1=n2,c1=c2; EF(0,sum);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>贪心</category>
        <category>分治法</category>
        <category>三分</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>单调性</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1623 守卫者的挑战（概率+递推）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-1623-%E5%AE%88%E5%8D%AB%E8%80%85%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%88%E6%A6%82%E7%8E%87-%E9%80%92%E6%8E%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P1623【概率】守卫者的挑战问题描述 打开了黑魔法师Vani的大门，队员们在迷宫般的路上漫无目的地搜寻着关押applepi的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为K的包包。 擂台赛一共有N项挑战，各项挑战依次进行。第i项挑战有一个属性ai，如果ai&gt;=0，表示这次挑战成功后可以再获得一个容量为ai的包包；如果ai=-1，则表示这次挑战成功后可以得到一个大小为1 的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑，只需要完成所有N项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功L次才能离开擂台。 队员们一筹莫展之时，善良的守卫者Nizem帮忙预估出了每项挑战成功的概率，其中第i项挑战成功的概率为Pi/100。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。 输入格式 第一行三个整数N,L,K。 第二行N个实数，第个i实数Pi表示第i项挑战成功的百分比。 第三行N个整数，第个i整数ai表示第i项挑战的属性值. 输出格式 一个整数，表示所求概率，四舍五入保留6 位小数。 样例输入1 3 1 010 20 30-1 -1 2 样例输入2 5 1 236 44 13 83 63-1 2 -1 2 1 样例输出1 0.300000 样例输出2 0.980387 令$F[i][j][k]$表示前$i$场比赛，打赢了$j$场，剩下的背包容积为$k$的概率，那么目标就是求$F[n][l-n][0-n]$的和，注意，背包容积大于$n$是没有意义的，全部统计到$n$中即可。那么递推式就比较好推了。为了方便，考虑第$i+1$场比赛的输赢及属性。 假如$A_{i+1}=-1$那么如果第$i+1$场赢了，$F[i+1][j+1][k-1]+=F[i][j][k]\times P[i+1]$如果第$i+1$场输了，$F[i+1][j][k]+=F[i][j][k]\times (1-P[i+1])$ 反之，假如$A_{i+1}=t$那么如果第$i+1$场赢了，$F[i+1][j+1][k+t]+=F[i][j][k]\times P[i+1]$如果第$i+1$场输了，$F[i+1][j][k]+=F[i][j][k]\times (1-P[i+1])$ 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,l,m,A[205];double P[205],F[205][205][405],ans;int main()&#123; int i,j,k; scanf("%d%d%d",&amp;n,&amp;l,&amp;m); for(i=1;i&lt;=n;i++)scanf("%lf",&amp;P[i]),P[i]=P[i]/double(100); for(i=1;i&lt;=n;i++)scanf("%d",&amp;A[i]); F[0][0][min(m,n)+200]=1; for(i=0;i&lt;n;i++) for(j=0;j&lt;=i;j++) for(k=-n;k&lt;=n;k++) &#123; if(A[i+1]==-1) &#123; F[i+1][j][k+200]+=F[i][j][k+200]*(1-P[i+1]); F[i+1][j+1][k+199]+=F[i][j][k+200]*P[i+1]; &#125; else &#123; F[i+1][j][k+200]+=F[i][j][k+200]*(1-P[i+1]); F[i+1][j+1][min(k+A[i+1],n)+200]+=F[i][j][k+200]*P[i+1]; &#125; &#125; for(i=l;i&lt;=n;i++) for(j=0;j&lt;=n;j++)ans+=F[n][i][j+200]; printf("%.6lf",ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>概率与期望</category>
        <category>递推</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2127 搜集卡片 （数学期望+状态压缩+递推）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2127-%E6%90%9C%E9%9B%86%E5%8D%A1%E7%89%87-%EF%BC%88%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-%E9%80%92%E6%8E%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2127【概率】搜集卡片问题描述 童年时代，你是否热衷于搜集零食里的卡片呢？比如你集齐了108张水浒英雄的卡片，你会感到非常有成就感，而且还可以去兑换奖品。 作为一个聪明的小孩，你注意到如果你要赢得奖品，你必须买很多很多的零食才能搜集齐卡片。要赢得奖品，你估计要买多少袋零食才能成功？ 输入格式 第一行，一个整数N(1 &lt;= N &lt;= 20), 表示总共有N种不同的卡片。第二行，N个空格间隔的实数p1, p2, …, pN, (p1 + p2 + … + pN &lt;= 1), 表示零食袋中每种卡片出现的概率。注意：一包零食中最多有一张卡片，也可能一张都没有。 输出格式 一个实数，表示你计算的结果，保留6位小数 样例输入 20.1 0.4 样例输出 10.500000 注意到n的范围，容易想到状态压缩。用一个二进制数$S$表示当前已收集到的卡片集合。用$F[S]$表示从状态$S$开始，收集完所有卡片需要买的零食的期望值。那么买一袋零食，有$$F[S]=1+(1-\sum {p[i]})\times F[S]+\sum{p[j]\times F[ \ S|\ j\ ]}+\sum {p[k]\times F[S]}$$其中$i取1-n，表示没抽中卡片，j表示一个不在S集合中的卡片，k表示在集合S中的卡片$于是移项整理得到$$\sum{p[i]}\times F[S]=1+\sum{F[\ S|\ j\ ]\times p[j]}$$其中$i和j都表示不在集合S中的卡片$于是直接递推即可。目标状态是$F[0]$ 代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,S;double P[22],F[1050000],tmp;int main()&#123; int i,j; scanf("%d",&amp;n);S=(1&lt;&lt;n)-1; for(i=1;i&lt;=n;i++)scanf("%lf",&amp;P[i]); for(i=S-1;i&gt;=0;i--) &#123; tmp=0;F[i]=1; for(j=1;j&lt;=n;j++) if(!(i&amp;(1&lt;&lt;j-1))) &#123; F[i]+=F[i|(1&lt;&lt;j-1)]*P[j]; tmp+=P[j]; &#125; F[i]/=tmp; &#125; printf("%.6lf",F[0]);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>杂学</category>
        <category>概率与期望</category>
        <category>递推</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
        <tag>递推</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2644 （SCOI 2010） 传送带（三分）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2644-%EF%BC%88SCOI-2010%EF%BC%89-%E4%BC%A0%E9%80%81%E5%B8%A6%EF%BC%88%E4%B8%89%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2644【SCOI2010 DAY2】传送带问题描述 在一个2维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段AB和线段CD。lxhgww在AB上的移动速度为P，在CD上的移动速度为Q，在平面上的移动速度R。现在lxhgww想从A点走到D点，他想知道最少需要走多长时间 输入格式 输入数据第一行是4个整数，表示A和B的坐标，分别为Ax，Ay，Bx，By 第二行是4个整数，表示C和D的坐标，分别为Cx，Cy，Dx，Dy 第三行是3个整数，分别是P，Q，R 输出格式 输出数据为一行，表示lxhgww从A点走到D点的最短时间，保留到小数点后2位 样例输入 0 0 0 100100 0 100 1002 2 1 样例输出 136.60 提示 对于100%的数据，1&lt;= Ax，Ay，Bx，By，Cx，Cy，Dx，Dy&lt;=1000 1&lt;=P，Q，R&lt;=10 此题比较简单，设$F(x,y)$表示在$AB$上走x，在$CD$上走的行走时间，显然是一个单峰函数，三分套三分即可。需要注意的是不要用直线解析式算交点，直接用线段的长度关系求。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;cmath&gt;#define ll double using namespace std;ll xa,xb,xc,xd,ya,yb,yc,yd,v1,v2,v3,l1,l2;ll R(ll a,ll b,ll c,ll d)&#123; return sqrt((a-c)*(a-c)+(b-d)*(b-d));&#125;ll G(ll x,ll y)&#123; ll x1,y1,x2,y2; x1=xa+(xb-xa)*x; y1=ya+(yb-ya)*x; x2=xd-(xd-xc)*y; y2=yd-(yd-yc)*y; return l1*x/v1+l2*y/v2+R(x1,y1,x2,y2)/v3;&#125;ll F2(ll x)&#123; ll l,r,tl,tr; l=0;r=1; while(r-l&gt;=0.0000001) &#123; tl=l+(r-l)/3; tr=r-(r-l)/3; if(G(x,tl)&lt;G(x,tr))r=tr; else l=tl; &#125; return G(x,tl);&#125;ll F1()&#123; ll l,r,tl,tr; l=0;r=1; while(r-l&gt;=0.0000001) &#123; tl=l+(r-l)/3; tr=r-(r-l)/3; if(F2(tl)&lt;F2(tr))r=tr; else l=tl; &#125; return F2(tl);&#125;int main()&#123; scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&amp;xa,&amp;ya,&amp;xb,&amp;yb,&amp;xc,&amp;yc,&amp;xd,&amp;yd,&amp;v1,&amp;v2,&amp;v3); l1=R(xa,ya,xb,yb); l2=R(xc,yc,xd,yd); printf("%.2lf",F1());&#125;]]></content>
      <categories>
        <category>分治法</category>
        <category>三分</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2650 （SDOI 2011） 消防（树的直径+DP+单调队列/二分答案）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2650-%EF%BC%88SDOI-2011%EF%BC%89-%E6%B6%88%E9%98%B2%EF%BC%88%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-DP-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2650【SDOI2011 第2轮 DAY1】消防问题描述 某个国家有n个城市，这n个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为zi(zi&lt;=1000)。 这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。 现在这个国家的经费足以在一条边长度和不超过s的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。 你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。 输入格式 输入包含n行：第1行，两个正整数n和s，中间用一个空格隔开。其中n为城市的个数，s为路径长度的上界。设结点编号以此为1，2，……，n。从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“2 4 7”表示连接结点2与4的边的长度为7。 输出格式 输出包含一个非负整数，即所有城市到选择的路径的最大值，当然这个最大值必须是所有方案中最小的。 【样例输入1】 5 21 2 52 3 22 4 42 5 3 【样例输入2】 8 61 3 22 3 23 4 64 5 34 6 44 7 27 8 3 【样例输出1】 5 【样例输出2】 5 【数据规模和约定】 对于20%的数据，n&lt;=300。对于50%的数据，n&lt;=3000。对于100%的数据，n&lt;=300000，边长小等于1000。 首先我们需要发现，这条路径必然是建在树的直径上。至于证明，只需要假设路径Q不在直径上，那么假设距离最远的点不在直径上，易证不可能，因此距离这条路径Q最远的点一定在直径上。之后再假设一个A点是不在直径上的一个点，我们假设直径上有一条路径P，如果A到P的距离大于了直径的端点到Q的距离，显然是矛盾的，因此任意的A点到P的距离一定小于直径端点到Q的距离，因此得证。 既然如此，我们将直径上的边权设为0，跑一遍BFS，即可求出其他所有点到直径的距离dis，之后我们需要考虑这条路径的位置。 现在，我们只需要在直径上求出一条不超过S的路径使得其他点到他的距离最小，显然这个最小距离不会大于我们之前求出的dis的最大值。 考虑在直径左右两边截掉一部分长度，可以发现，其他点到这条路径的距离如果变大了，那么新的距离不会超过截掉的长度，否则就与直径矛盾。 所以截掉一段后的发生变化的距离中的最大距离必然是直径的左端点或右端点到路径的距离，因此我们只需要求出需要截掉的最短的长度，当然，这个长度是左边和右边分别截掉长度的最大值。 有了上述结论，我们就求出了直径外的点到路径的距离，和直径上的点到路径的最大距离的最小值，取一个max即可。 至于如何求出截掉部分的长度的最小值，可以二分截掉的长度，也可以直接用dp+单调队列维护。 具体可以参考代码 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;#define N 333333#define M 666666using namespace std;deque&lt;int&gt;Q;int n,s,S,T,D[N],SS[N],dis[N],cnt,Max,Maxp,ans,Ans=1e9;int TOT=1,LA[N],NE[M],EN[M],LE[M];void ADD(int x,int y,int z)&#123; TOT++; EN[TOT]=y; LE[TOT]=z; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void FD(int x,int f,int tot)//找到直径的端点&#123; int i,y; if(tot&gt;Max)Max=tot,Maxp=x; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)FD(y,x,tot+LE[i]); &#125;&#125;bool FW(int x,int y,int f)//标记直径上的边&#123; int i,u; if(x==y)return 1; for(i=LA[x];i;i=NE[i]) &#123; u=EN[i]; if(u==f)continue; if(FW(u,y,x)) &#123; D[++cnt]=LE[i]; LE[i]=LE[i^1]=0; return 1; &#125; &#125; return 0;&#125;void DFS(int x,int f,int tot)//算出其他点到直径的距离&#123; int i,y; dis[x]=tot; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(y!=f)DFS(y,x,tot+LE[i]); &#125;&#125;int main()&#123; int i,x,y,z; scanf("%d%d",&amp;n,&amp;s); for(i=1;i&lt;n;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ADD(x,y,z);ADD(y,x,z); &#125; Max=Maxp=-1;FD(1,0,0);S=Maxp;//找直径的端点 Max=Maxp=-1;FD(S,0,0);T=Maxp;//找直径的端点 FW(S,T,0);DFS(S,0,0);//标记直径+求距离 for(i=1;i&lt;=n;i++)ans=max(ans,dis[i]);//取最大距离 for(i=1;i&lt;=cnt;i++)SS[i]=D[i]+SS[i-1];//前缀和，准备dp Q.push_back(0); for(i=1;i&lt;=cnt;i++) &#123; Q.push_back(i); while(Q.size()&amp;&amp;SS[i]-SS[Q.front()]&gt;s)Q.pop_front(); if(Q.size())Ans=min(Ans,max(SS[Q.front()],SS[cnt]-SS[i])); &#125; printf("%d",max(ans,Ans));&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>分治法</category>
        <category>一般dp</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2791 （APIO 2012）守卫（贪心+链表+差分数组）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2791-%EF%BC%88APIO-2012%EF%BC%89%E5%AE%88%E5%8D%AB%EF%BC%88%E8%B4%AA%E5%BF%83-%E9%93%BE%E8%A1%A8-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2791【APIO2012】守卫问题描述 APIO王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在阴影里面使得其他人看不到他们。整个王国除了国王居住的APIO城堡以外都已经被占领了。在城堡前，有N个灌木丛，从1到N编号，有K个忍者躲在恰好K个灌木丛后面。APIO城堡里有M个守卫。守卫i监视着编号从Ai到Bi的连续的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。作为国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着一个忍者。你需要写一个程序来输出所有的这些灌木丛的编号。 输入格式 第一行包含三个用空格分隔的整数N, K, M，N是灌木丛的个数，K是忍者的个数，M是守卫的个数。接下来M行，每行描述一个守卫的信息。其中的第i行包含三个整数Ai,Bi, Ci，表示第i个守卫的监视范围是从Ai到Bi（Ai ≤ Bi）。Ci是0或者1，若是0表示范围内没有看到忍者，1表示范围内有至少一个忍者。输入数据保证至少存在一种忍者排列方式满足所有条件。 输出格式 若存在灌木丛，在其后面一定躲着忍者，则将这些一定躲着忍者的灌木丛按照编号从小到大的顺序依次输出，每个一行。即若有X个这样的灌木丛，则需要输出X行。若不存在，则输出一行一个“-1”，不包含引号。 样例输入1： 5 3 41 2 13 4 14 4 04 5 1 样例输入2： 5 1 11 5 1 样例输出1： 35 样例输出2： -1 提示 1 ≤ N ≤ 100,000 灌木的数量；1 ≤ K ≤ N 忍者数；1 ≤ M ≤ 100,000 守卫数。 这个题，显然我们需要先将没有忍者的地方标记出来，这个用差分数组实现即可。然后剩下的位置就都可能存在忍者了。为了方便，我们把这些位置离散化一下，从而使这些位置变成编号连续的。那么将存在忍者的区间按照左右端点排序。之后用链表将存在忍者的区间合并一下，即如果两个区间存在包含关系，那么大的那个区间就是没用的，只需要保留小区间。处理完了之后，所有区间的左右端点肯定都是递增的。 那么我们可以用贪心求出从左到右处理到某个区间最少要放的忍者数，因为如果要放，那么放在一个区间的右端点显然是最优的。同理可以求出从右到左到某个区间最少要放的忍者数。 之后我们考虑哪些地方一定要放，根据贪心的原则我们发现，如果一个区间的贪心值和他前一个区间一样，那么这个区间显然就不需要放，那么如果这个区间需要放，由于尽量放在右端点是最优的，那么我们假设在右端点减一的位置放一个忍者，利用前面的贪心数组，我们可以算出此时满足所有区间需要的忍者数，如果大于了总忍者数，说明放在这里是不可能的，那么就必须放在右端点，也就是说右端点必须放。于是我们只需要讨论每一个贪心时必须放的区间即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 123456using namespace std;struct node&#123;int x,y;&#125;edge[N],E[N],tmp;bool cmp(node a,node b)&#123; if(a.x==b.x)return a.y&gt;b.y; return a.x&lt;b.x;&#125;bool cmp1(node a,node b)&#123;return a.x&lt;b.x;&#125;bool cmp2(node a,node b)&#123;return a.y&lt;b.y;&#125;int n,k,m,cnt,p,q,A[N],B[N],C[N],L[N],FL[N],FR[N];bool mark[N],T;int main()&#123; int i,j,x,y,z; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(z==1)edge[++cnt].x=x,edge[cnt].y=y; else A[x]++,A[y+1]--; &#125; for(i=1;i&lt;=n;i++) &#123; A[i]=A[i]+A[i-1]; if(A[i]&lt;=0)B[++p]=i; &#125; if(p==k)&#123;for(i=1;i&lt;=p;i++)printf("%d\n",B[i]);return 0;&#125; for(i=1;i&lt;=cnt;i++) &#123; x=lower_bound(B+1,B+p+1,edge[i].x)-B; y=lower_bound(B+1,B+p+1,edge[i].y)-B; if(B[y]&gt;edge[i].y)y--; edge[i].x=x;edge[i].y=y;L[i]=i-1; &#125; sort(edge+1,edge+cnt+1,cmp); for(i=2;i&lt;=cnt;i++) &#123; while(edge[L[i]].x&lt;=edge[i].x&amp;&amp;edge[L[i]].y&gt;=edge[i].y) &#123; mark[L[i]]=1; L[i]=L[L[i]]; &#125; &#125; for(i=1;i&lt;=cnt;i++)if(!mark[i])E[++q]=edge[i]; sort(E+1,E+q+1,cmp1); y=0; for(i=1;i&lt;=q;i++) if(E[i].x&gt;y) &#123; FL[i]=FL[i-1]+1; y=E[i].y; &#125; else FL[i]=FL[i-1]; x=n+1; for(i=q;i&gt;=1;i--) if(E[i].y&lt;x) &#123; FR[i]=FR[i+1]+1; x=E[i].x; &#125; else FR[i]=FR[i+1]; for(i=1;i&lt;=q;i++) &#123; if(FL[i]!=FL[i-1]+1)continue; if(E[i].x==E[i].y) &#123; printf("%d\n",B[E[i].x]); T=1;continue; &#125; tmp.x=E[i].y;tmp.y=E[i].y-1; x=lower_bound(E+1,E+q+1,tmp,cmp2)-E;x--; y=lower_bound(E+1,E+q+1,tmp,cmp1)-E; if(FL[x]+FR[y]+1&gt;k)T=1,printf("%d\n",B[E[i].y]); &#125; if(!T)printf("-1");&#125;]]></content>
      <categories>
        <category>贪心</category>
        <category>杂学</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3800 分解质因数（欧拉函数+线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3800-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3801分解质因数问题描述 记Pi表示正整数i的质因数集合。 已知正整数n,求满足下列条件的有序正整数对(a,b)的数目： (1)1&lt;=a&lt;=b&lt;=n(2)t为a,b的最大公约数，Pt是Pn的子集 输入格式 一个正整数n. 输出格式 一个正整数，表示合题意的有序正整数对的数目. 样例输入 1 6 样例输出 1 20 样例输入 2 7 样例输出 2 19 数据范围 50%的数据1&lt;=n&lt;=2000; 100%的数据1&lt;=n&lt;=1000000. 此题有两种做法。 做法一：先介绍一种比较简单粗暴的。我们考虑一个数$d$，满足$P_{d}$是$P_{n}$的子集，这样的$d$是比较容易求的，只需要求出$n$的质因数分解后用线性筛就可以处理，但是本题可以直接暴力一点预处理。 总之，我们求出了$d$，那么现在需要考虑对于每一个$d$，有多少个数对$(A,B)$满足$gcd(A,B)=d$，那么根据$gcd$的性质，有$gcd(\frac {A}{d},\frac {B}{d})=1$那么显然我们只需要找出在$1-\frac {n}{d}$的范围中，有多少对互质的整数即可，那么显然是$\sum_{i=1}^{\frac{n}{d}} \varphi(i)$，那么$\varphi$的前缀和$S_{\varphi}$可以用线性筛处理，然后枚举$d$把$S_{\varphi}(\frac{n}{d})$累加起来就是答案。 代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 1000005#define ll long longusing namespace std;ll n,phi[N],S[N],P[N],tot,ans;bool mark[N];int main()&#123; ll i,j; scanf("%lld",&amp;n);phi[1]=1;S[1]=1; for(i=2;i&lt;=n;i++) &#123; if(!phi[i])phi[i]=i-1,P[++tot]=i; for(j=1;j&lt;=tot&amp;&amp;P[j]*i&lt;=n;j++) if(i%P[j])phi[i*P[j]]=phi[i]*(P[j]-1); else &#123;phi[i*P[j]]=phi[i]*P[j];break;&#125; S[i]=S[i-1]+phi[i]; &#125; for(i=1;i&lt;=tot;i++)if(n%P[i])for(j=P[i];j&lt;=n;j+=P[i])mark[j]=1; for(i=1;i&lt;=n;i++)if(!mark[i])ans+=S[n/i]; printf("%lld",ans);&#125; 做法二：做法二比较的巧妙，我们可以认为在$P_{n}$中的质数不是质数，那么题设条件就变成了求有多少对互质的数对，那么显然是欧拉函数求解，但是由于质数是改动过的，我们记他为$\varphi’(x)$，那么因为这个函数与欧拉函数基本是一样的，那么他显然是积性函数，那么就可以用线性筛来搞。具体来说，我们在普通的线性筛中，遇到质数时判断一下，如果这个质数在$P_{n}$中，那么$\varphi’(x)=x$，否则$\varphi’(x)=x-1$，然后合数还是通过积性函数性质来搞。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int N=20000050; int n,phi[N],prime[N]; bool mark[N],p[N]; void linear() &#123; int i,j,tot=0; phi[1]=1; for(i=2;i&lt;=n;i++) &#123; if(!phi[i]) &#123; if(!p[i])phi[i]=i-1; else phi[i]=i; prime[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=n;j++) if(i%prime[j]==0)&#123;phi[i*prime[j]]=phi[i]*prime[j];break;&#125; else phi[i*prime[j]]=phi[i]*(phi[prime[j]]); &#125;&#125; main() &#123; int i,j,k; cin&gt;&gt;n; int tmp=n; for(i=2;i*i&lt;=n&amp;&amp;tmp!=1;i++) if(tmp%i==0) &#123; while(tmp%i==0)tmp/=i; p[i]=true; &#125; if(tmp!=1)p[tmp]=true; linear(); long long ans=0; for(i=1;i&lt;=n;i++)ans+=1LL*(phi[i]); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>欧拉函数</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>线性筛</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3051 浇花 （差分数组/区间DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3051-%E6%B5%87%E8%8A%B1-%EF%BC%88%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84-%E5%8C%BA%E9%97%B4DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3051浇花问题描述 n 个非负整数排成一行，每个数值为Ai，数的位置不可改变。需要把所有的数都恰好等于h。可进行的操作是：对任意长度的区间[i,j]中的每个数都加1，i 和j 也任选，但要求每个数只能作为一次区间的起点，也只能作为一次区间的终点。也即是说： 对任意的两个区间[l1, r1] 和[l2, r2], 要求: l1≠l2 并且r1 ≠ r2.请问有多少种不同的方式，使所有的数都等于h.输出答案模1000000007 (10^9+7)后的余数。两种方式被认为不同，只要两种方式所实施的操作的区间集合中，有一个区间不同即可. 输入格式 第1 行：2 个整数n, h (1 ≤ n, h ≤ 2000)接下来n 行，每行1 个整数，表示Ai (1≤Ai≤2000)30%的数据，n, h &lt;= 30100%的数据，n, h &lt;= 2000 输出格式 第1 行：1 个整数，表示答案 样例输入 Sample1:3 21 1 1Sample2:5 11 1 1 1 1 样例输出 Sample1:4Sample2:1 此题有两种做法。做法一：比较笨拙的DP做法 引用一下考试时的题解 类似于括号dp的讨论方式，讨论i的左边，选哪个数字作为区间的起点，更新i的值 dp[i][k]表示从左往右讨论到第i个数字，i的左边有k个数字还未被用过(被当做区间的左起点), 的方案数。 分两种情况讨论： 情况1：i被别人更新(因为i前面的k个数，任选一个为区间起点，都可更新到i)： 若a[i]+k==h 则dp[i][k]=dp[i+1][k-1]*k+dp[i+1][k] 说明，条件a[i]+k==h,因为i左边有k个数字还没用过，那么以这k个数字作为区间左起点可以操作k次，每次都可以更新到i，更新k次，恰好就能使a[i]变成h。 现在对于i而言，有两种选择， 使用i或者不使用i。 若用i作为区间右端点，因为i只能当一次区间终点，所以只能从前k个中选一个来与它配对，故有k种方案，k个数中i选了一个，对于i+1它左边就只有k-1个未使用的数了，数量总数为k*dp[i+1][k-1] 。 注意，这里i不能再作为区间的左端点了，这样的话会导致i被多更新一次，高度变成h+1 若不用i作为区间端点，则方案数为dp[i+1][k] 情况2：i作为区间起点去更新别人 若a[i]+k+1=h则dp[i][k]=dp[i+1][k]*(k+1)+dp[i+1][k+1] 说明，因为i前面有k个数未被当做左起点使用，全部操作都只能把a[i]更新到h-1这个高度，那么i号点必须自己作为某区间的左起点更新一次，在更新这个区间的同时把自己的高度也更新1，达到h。 这样，对于下一个数i+1而言，算上i号点，它左侧有k+1个点可选做区间左端点，任选一个选后剩下k个点，状态dp[i+1][k] 若不用i作为区间左端点，则方案数为dp[i+1][k+1] 时间复杂度O(n2),实现时采用记忆化搜索比较方便。 代码： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;ll n,h,A[2222],F[2222][2222],mod=1000000007;ll DFS(ll x,ll k)&#123; if(F[x][k]!=-1)return F[x][k]; if(x==n+1) &#123; if(k==0)return 1; else return 0; &#125; F[x][k]=0; if(A[x]+k==h)F[x][k]=DFS(x+1,k-1)*k%mod+DFS(x+1,k); if(A[x]+1+k==h)F[x][k]=DFS(x+1,k)*(k+1)%mod+DFS(x+1,k+1); F[x][k]%=mod; return F[x][k];&#125;int main()&#123; ll i; scanf("%lld%lld",&amp;n,&amp;h); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]); memset(F,-1,sizeof(F)); printf("%lld",DFS(1,0)%mod);&#125; 做法二：优秀的差分数组解法 首先将题目中的数组中每个数变成$H-A[i]$得到新的$A[i]$。然后将数组$A[i]$差分一下记作$B[i]$，那么先判无解。 首先，如果存在$A[i]&gt;H$那么显然无解。然后，如果$B[i]$中存在除了$1,0,-1$以外的数，那么无解。（证明：反向考虑，如果存在解，那么每次区间修改都会在差分数组中的两个位置+1或-1，那么由于每个位置只能做一次起点和终点，+1和-1的次数最多都只有一次，所以必然$B[i]$中只有1,0，-1） 之后就可以考虑成类似括号匹配的问题。由于差分数组的原理，那么每一个1都要和-1配对，用$cnt$表示讨论到$i$位置时，左边还没有配对的1。 如果$i$位置是1，那么$cnt++$即可。如果$i$位置是-1，那么他可以和左边任意一个1配对，$ans=ans\times cnt$，然后$cnt–$如果$i$位置是0，那么$i$位置可能没有操作，对方案没有影响，或者$i$位置可以看成一个1和-1，既是起点又是终点，那么先$cnt++$，然后$ans=ans\times cnt$，之后$cnt–$，等价于$ans=ans\times (cnt+1)$ 代码： 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll i,n,h,ans,cnt,A[2222],B[2222],mod=1e9+7;int main()&#123; scanf("%lld%lld",&amp;n,&amp;h);ans=1; for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]),A[i]=h-A[i]; for(i=1;i&lt;=n+1;i++)B[i]=A[i]-A[i-1]; for(i=1;i&lt;=n+1;i++) &#123; if(B[i]==1)cnt++; else if(B[i]==0)ans=ans*(cnt+1)%mod; else if(B[i]==-1)ans=ans*cnt%mod,cnt--; else &#123;ans=0;break;&#125; &#125; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>杂学</category>
        <category>一般dp</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2522 Sandy的卡片（差分数组+DP）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2522-Sandy%E7%9A%84%E5%8D%A1%E7%89%87%EF%BC%88%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84-DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2522【SDOI2008】Sandy的卡片问题描述 Sandy和Sue的热衷于收集干脆面中的卡片。然而，Sue收集卡片是因为卡片上漂亮的人物形象，而Sandy则是为了积攒卡片兑换超炫的人物模型。每一张卡片都由一些数字进行标记，第i张卡片的序列长度为Mi，要想兑换人物模型，首先必须要集够N张卡片，对于这N张卡片，如果他们都有一个相同的子串长度为k，则可以兑换一个等级为k的人物模型。相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串。Sandy的卡片数远远小于要求的N，于是Sue决定在Sandy的生日将自己的卡片送给Sandy，在Sue的帮助下，Sandy终于集够了N张卡片，但是，Sandy并不清楚他可以兑换到哪个等级的人物模型，现在，请你帮助Sandy和Sue，看看他们最高能够得到哪个等级的人物模型。 输入格式 第一行为一个数N，表示可以兑换人物模型最少需要的卡片数，即Sandy现在有的卡片数第i+1行到第i+N行每行第一个数为第i张卡片序列的长度Mi，之后j+1到j+1+Mi个数，用空格分隔，分别表示序列中的第j个数 输出格式 一个数k，表示可以获得的最高等级。 样例输入 22 1 23 4 5 9 样例输出 2 提示 30%的数据保证n&lt;=50100%的数据保证n&lt;=1000,m&lt;=200 首先需要明白题目中全部加上一个数，意思是将一个区间整体加上一个数。那么显然用差分，差分一下之后就变成了求这n个串的最长公共子串。 这里只记录一种比较好理解的DP方法。令$G[i]$表示将每个串与1号串匹配后，以1号串第i个字符作为结尾的子串的最长公共串的长度。然后将每个串和1号串直接跑一次最长公共子串，$F[i][j]$表示第$k$个串和第1个串匹配的结果。那么令$Q[i]=max(F[i][j])，j取1-m$那么$Q[i]$就表示了第$k$个串和第1个串匹配时，以1号串第$i$个字符作为结尾的最长公共子串长度。然后用$Q[i]$更新$G[i]$，即$G[i]=min(G[i],Q[i])$。所有串都讨论完了之后，取$max(G[i])$就是答案。 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005#define M 205using namespace std;int n,A[N][M],F[M][M],G[M],Q[M],ans;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;A[i][0],&amp;x); for(j=1;j&lt;A[i][0];j++) &#123; scanf("%d",&amp;y); A[i][j]=y-x;x=y; &#125; &#125; for(i=1;i&lt;A[1][0];i++)G[i]=i; for(i=2;i&lt;=n;i++) &#123; memset(Q,0,sizeof(Q)); for(j=1;j&lt;A[1][0];j++) for(k=1;k&lt;A[i][0];k++) &#123; if(A[i][k]==A[1][j])F[j][k]=F[j-1][k-1]+1; else F[j][k]=0; Q[j]=max(Q[j],F[j][k]); &#125; for(j=1;j&lt;A[1][0];j++)G[j]=min(G[j],Q[j]); &#125; for(i=1;i&lt;A[1][0];i++)ans=max(ans,G[i]); cout&lt;&lt;ans+1;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>杂学</category>
        <category>一般dp</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 2993 （NOI 2014）动物园（KMP+栈）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-2993-%EF%BC%88NOI-2014%EF%BC%89%E5%8A%A8%E7%89%A9%E5%9B%AD%EF%BC%88KMP-%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P2993【NOI2014 Day2】动物园问题描述 近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。某天，园长给动物们讲解KMP算法。园长：“对于一个字符串S，它的长度为L。我们可以在O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？”熊猫：“对于字符串S的前i个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]。”园长：“非常好！那你能举个例子吗？”熊猫：“例S为abcababc，则next[5]=2。因为S的前5个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0，next[4] = next[6] = 1，next[7] = 2，next[8] = 3。”园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)的时间内求出next数组。下课前，园长提出了一个问题：“KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。例如S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2。”最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出num数组呢？特别地，为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出$\prod_{i=1}^{L}(num[i]+1)$对1,000,000,007取模的结果即可。其中$\prod_{i=1}^{L}(num[i]+1)=(num[1]+1)\times (num[2]+1)\times …\times (num[L]+1)$ 输入格式 第1行仅包含一个正整数n，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。数据保证S中仅含小写字母。输入文件中不会包含多余的空行，行末不会存在多余的空格。 输出格式 包含n行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对1,000,000,007取模的结果。输出文件中不应包含多余的空行。 样例输入 3aaaaaababcababc 样例输出 36132 数据范围 总结一下题意，我们需要求对于以$i$位置为末尾的子串，他的所有长度小于等于$\frac{i}{2}$的前缀和后缀中相同的串的个数。 回忆$KMP$算法中$fail[i]$的意义，他表示以$i$号位置为结尾的子串的前缀和后缀中最长的相等的串。 我们来看看对于一个位置$i$，$fail[i]$位置表示的子串肯定既是$i$的前缀，也是$i$的后缀，那么$fail[fail[i]]$表示的子串呢，容易发现他肯定也是$i$的前缀和$i$的后缀，同时由于$fail$数组记录的是最长的子串，那么$fail[fail[i]]$表示的肯定是$i$的前缀和后缀中长度第二长的子串。 那么问题的解就比较显然了，我们需要求$fail$链上，编号小于等于$\frac {i}{2}$的编号个数。 暴力一点就直接用$while$循环算。但事实上，如果将$fail[i]$作为$i$的父亲，那么$fail$数组就形成了一棵树。那么我们就可以在遍历树的过程中用树状数组来维护。这样大概能得80分。事实上，我们可以更快一点，观察发现，$fail$链上的编号是递增的，那么$num[i]&gt;=num[fail[i]]$，那么我们可以每次直接将$num[i]$赋值为$num[fail[i]]$，然后用栈暴力增加$num[i]$，由于每个数最多被讨论到一次，均摊复杂度$O（n）$具体实现可以参考代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1000005#define ll long longusing namespace std;char A[N];int n,l,F[N],B[N],S[N],top;int TOT,LA[N],NE[N],EN[N];ll ans,mod=1000000007LL;void DFS(int x)&#123; S[++top]=x; B[x]=B[F[x]]; while(B[x]&lt;top-1&amp;&amp;(S[B[x]+1]&lt;&lt;1)&lt;=x)B[x]++;//暴力更新 for(int i=LA[x];i;i=NE[i])DFS(EN[i]); top--;&#125;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;int main_main()&#123; int i,j,n; scanf("%d",&amp;n); while(n--) &#123; memset(LA,0,sizeof(LA)); ans=1;TOT=0; scanf("%s",&amp;A[1]);A[0]='%'; l=strlen(A)-1;j=0; for(i=2;i&lt;=l;i++) &#123; while(j&gt;0&amp;&amp;A[i]!=A[j+1])j=F[j]; if(A[i]==A[j+1])j++; F[i]=j; &#125; for(i=1;i&lt;=l;i++)ADD(F[i],i); DFS(0); for(i=1;i&lt;=l;i++)ans=ans*B[i]%mod; printf("%lld\n",ans); &#125;&#125;const int main_stack=16;char my_stack[128&lt;&lt;20];int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3545 接近（DP+单调队列）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3545-%E6%8E%A5%E8%BF%91%EF%BC%88DP-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3545接近问题描述 对于一个数字序列A，并且有若干询问。对于每个询问，要求求出一段在序列A中非空 的连续段使得这一段数字的总和的绝对值尽量接近P。 输入格式 第一行2个数N、T，表示序列的长度和询问的个数。接下来一行N个整数，表示A序列。 接下来T行，每行一个数P表示询问。 输出格式 共输出T行，每行对应一个询问的答案。输出3个数：第一个数为能够实现的最接近P 的数，后面两个数L、R表示A序列中的L到 R这一段数能实现这个答案。如果存在多解，输出L最小的解；如果还有多解，输出R最小的解。 样例输入 5 1-10 -5 0 5 103 样例输出 5 2 2 数据范围 30%的数据 1&lt;=N&lt;=1,000。60%的数据 1&lt;=N&lt;=10,000。100%的数据 1&lt;=N&lt;=100,000，A 序列中数字绝对值&lt;=10,000，T&lt;=100，询问的 数字&lt;=10^9 此题容易想到求出前缀和数组$Sum$，鉴于复杂度，需要一个$O(n)$的算法，但此时遇到的问题就是，前缀和数组并不具有单调性。注意到题目中的绝对值，于是学习到了一个大胆的操作，将前缀和数组排序，强行维护单调性，而且位置坐标并不会对答案产生影响，于是就单调DP即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;struct node&#123;ll v,c;&#125;;bool cmp(node a,node b)&#123; if(a.v==b.v)return a.c&gt;b.c; return a.v&lt;b.v;&#125;node S[123456];ll n,T,x,L,ans,tmp,l,r;void MD(int p,int q)&#123; int tx,ty,t; tx=S[p].c;ty=S[q].c; if(tx&gt;ty)swap(tx,ty); t=S[p].v-S[q].v-x; if(t&lt;0)t=-t; if(t&lt;tmp)tmp=t,ans=S[p].v-S[q].v,l=tx,r=ty; if(t==tmp&amp;&amp;tx&lt;l)l=tx,r=ty,ans=S[p].v-S[q].v; if(t==tmp&amp;&amp;tx==l&amp;&amp;ty&lt;r)r=ty,ans=S[p].v-S[q].v;&#125;void Work()&#123; L=0;tmp=1e18; for(int i=1;i&lt;=n;i++) &#123; while(L&lt;i-1&amp;&amp;S[i].v-S[L+1].v&gt;=x)L++; MD(i,L);if(L&lt;i-1)MD(i,L+1);//更新答案 &#125; printf("%lld %lld %lld\n",ans,l+1,r);&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;T); for(int i=1;i&lt;=n;i++)scanf("%lld",&amp;x),S[i].v=S[i-1].v+x,S[i].c=i; sort(S,S+n+1,cmp); while(T--)scanf("%lld",&amp;x),Work();&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>一般dp</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3790 （SDOI 2009）学校食堂 （状压dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3790-%EF%BC%88SDOI-2009%EF%BC%89%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3790【SDOI2009】学校食堂问题描述 小F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是a，这一道为b，则做这道菜所需的时间为（a or b）-（a and b），而做第一道菜是不需要计算时间的。其中，or 和and 表示整数逐位或运算及逐位与运算，C语言中对应的运算符为“|”和“&amp;”。学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第i 个同学，最多允许紧跟他身后的Bi 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。现在，小F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。 输入格式 第一行包含一个正整数C，表示测试点的数据组数。每组数据的第一行包含一个正整数N，表示同学数。每组数据的第二行起共N行，每行包含两个用空格分隔的非负整数Ti和Bi，表示按队伍顺序从前往后的每个同学所需的菜的口味和这个同学的忍受度。每组数据之间没有多余空行。 输出格式 包含C行，每行一个整数，表示对应数据中食堂完成所有菜所需的最少时间。 样例输入 255 24 112 03 32 225 04 0 样例输出 161 数据规模和约定 对于30%的数据，满足1 ≤ N ≤ 20。对于100%的数据，满足1 ≤ N ≤ 1,000，0 ≤ Ti ≤ 1,000，0 ≤ Bi ≤ 7，1 ≤ C ≤ 5。存在30%的数据，满足0 ≤ Bi ≤ 1。 观察到$Bi$的范围，我们发现第$i$个人最多与后面7个人产生关系，于是我们可以用一个二进制数记下$i$和他后面7个人中哪些人已经吃了饭，由于做菜的时间与上一个人有关，于是再开一维记录上一个人吃饭的是谁，观察发现我们只需要记录上一个吃饭的人与$i$的相对位置，最多只有15种可能。于是我们令$F[i][S][k]$表示讨论到第$i$个人，集合状态是$S$，上一个吃饭的人与$i$的位置关系是$k$$S$的第一位记录$i$是否吃饭了，如果$i$已经吃饭了，那么转移到$F[i+1][S&gt;&gt;1][k-1]$如果第$i$个人没有吃饭，那么枚举下一个吃饭的人，如果他与$i$的相对位置为$j$，转移到$F[i][S|(1&lt;&lt;j)][j]$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int c,n,T[N],B[N],F[N][260][20];int GT(int x,int y)&#123; if(x==0)return 0; return T[x]^T[y];&#125;void Work()&#123; memset(F,60,sizeof(F)); int i,j,k,s,t,ans=1e9,inf=F[0][0][0]; F[1][0][7]=0; for(i=1;i&lt;=n;i++) for(s=0;s&lt;(1&lt;&lt;8);s++) for(k=-8;k&lt;=7;k++) if(F[i][s][k+8]&lt;inf) &#123; if(s&amp;1)F[i+1][s&gt;&gt;1][k-1+8]=min(F[i+1][s&gt;&gt;1][k-1+8],F[i][s][k+8]); else &#123; t=inf; for(j=0;j&lt;=7;j++) if(!(s&amp;(1&lt;&lt;j))) &#123; if(i+j&gt;t)break; F[i][s|(1&lt;&lt;j)][j+8]=min(F[i][s|(1&lt;&lt;j)][j+8],F[i][s][k+8]+GT(i+k,i+j)); t=min(t,i+j+B[i+j]); &#125; &#125; &#125; for(i=-8;i&lt;=7;i++)ans=min(ans,F[n+1][0][i+8]); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; scanf("%d",&amp;c); while(c--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;T[i],&amp;B[i]); Work(); &#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>杂学</category>
        <category>状态压缩</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3792 分糖果（差值dp+前缀和优化）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3792-%E5%88%86%E7%B3%96%E6%9E%9C%EF%BC%88%E5%B7%AE%E5%80%BCdp-%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3792分糖果问题描述 有n种糖果（编号1到n）,第i号糖果有Ai颗，现需要将所有糖果分给两个小朋友，要求两个小朋友得到糖果数量相等，问有多少种分法？（可以不必将所有糖果分完。如全部都不分，每人的糖果数量为0，也算是一种分法） 输入格式 第一行，一个整数n，表示糖果种类数量第二行，n个空格间隔的整数，表示每种糖果的数量 输出格式 一行，一个整数，表示总的方案数，答案 mod 10^9+7后再输出。 样例输入 1 12 样例输出 1 2 样例输入 2 21 2 样例输出 2 4 提示 1&lt;=n&lt;=2001&lt;=Ai&lt;=200 容易想到令$F[i][j][k]$表示分完第$i$中糖后，第一个小朋友有$j$颗糖，第二个小朋友有$k$颗糖的方案数。再想发现，我们只关心他们分的糖是否相等，因此可以简化成令$F[i][j]$表示分完第$i$中糖，两人分的糖果的差值为$j$那么,$F[i][j]=\sum F[i-1][j-k]*((A[i]-k)/2+1)$，这个递推式的复杂度是$O(n^4)$，我们需要优化考虑$F[i][j]-F[i][j-1]$，讨论$A[i]$的奇偶，观察可以发现$F[i][j]$关于$F[i][j-1]$的递推式，这个式子可以前缀和优化。于是复杂度就降到了$O(n^3)$，鉴于递推式比较冗长，这里就不写了。实际做的时候只需要取比较小的$A[i]$把$F[i][j]-F[i][j-1]$展开，观察一下就可以发现关于奇偶性的规律。代码比较恶心，前缀和需要根据奇偶分开。 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define N 123456using namespace std;ll F[N],S[2][N],A[N],n,m,p,mod=1e9+7;int main()&#123; ll i,j,k,t; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;A[i]),m+=A[i]; F[m]=1;p=m*2; for(i=1;i&lt;=n;i++) &#123; S[0][0]=F[0]; S[1][0]=0; for(j=1;j&lt;=p;j++)//先处理出前缀和 &#123; k=j&amp;1; S[k][j]=(S[k][j-1]+F[j])%mod; S[k^1][j]=S[k^1][j-1]; &#125; for(j=0;j&lt;=A[i];j++)F[0]=(F[0]+F[j]*((A[i]-j&gt;&gt;1)+1))%mod;//先算出F[0] for(j=1;j&lt;=p;j++)//递推 &#123; k=(A[i]+j)&amp;1;//判断需要的前缀和数组的奇偶 F[j]=(F[j-1]+S[k][j+A[i]]-S[k][j-1])%mod; if(j-A[i]-2&lt;0)t=0; else t=S[k^1][j-A[i]-2]; F[j]=(F[j]-S[k^1][j-1]+t)%mod; &#125; &#125; cout&lt;&lt;(F[m]+mod)%mod;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3793 礼物和糖果（背包dp）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3793-%E7%A4%BC%E7%89%A9%E5%92%8C%E7%B3%96%E6%9E%9C%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3793礼物和糖果问题描述 何老板要给大家买节日礼物，他有M元钱，学校小卖部有N种礼品，因为店长和何老板是熟人，所以若第i种礼品买x(x&gt;0)件的话，店长会给何老板Ai*x+Bi颗糖果。 因为何老板非常喜欢吃糖，所以他希望获得的糖果越多越好。现给出每种礼品的单价Wi、Ai值与Bi值，问何老板最多能得到多少颗糖果？ 输入格式 第一行，两个空格间隔的整数M和N接下来N行，每行三个整数Wi, Ai 和 Bi，描述一种礼物的情况。 输出格式 一行，一个整数，表示何老板能得到的最大糖果数 样例输入 100 210 2 120 1 1 样例输出 21 提示 1 ≤ M ≤ 20001 ≤ N ≤ 10000 ≤ Ai, Bi ≤ 20001 ≤ Wi ≤ 2000 将一个物品拆成两个物品，一个物品价格为$A[i]+B[i]$，只能买一个。另一个物品价格为$A[i]$，可以买无限个。然后背包dp即可。 代码： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 2222using namespace std;int m,n,W[N],A[N],B[N],F[N];int main()&#123; int i,j,k; scanf("%d%d",&amp;m,&amp;n); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;W[i],&amp;A[i],&amp;B[i]); for(i=1;i&lt;=n;i++) &#123; for(j=m;j&gt;=W[i];j--)F[j]=max(F[j],F[j-W[i]]+A[i]+B[i]); for(j=W[i];j&lt;=m;j++)F[j]=max(F[j],F[j-W[i]]+A[i]); &#125; cout&lt;&lt;F[m];&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>一般dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3798 有趣的数列 （卡特兰数+线性筛）]]></title>
    <url>%2F2018%2F03%2F15%2FNKOJ-3798-%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%88%97-%EF%BC%88%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0-%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3798有趣的数列问题描述 我们称一个长度为2n的数列是有趣的，当且仅当该数列满足以下三个条件： (1)它是从1到2n共2n个整数的一个排列{Ai}； (2)所有的奇数项满足A1 &lt; A3 &lt; … &lt; A2n-1，所有的偶数项满足A2 &lt; A4 &lt; … &lt; A2n； (3)任意相邻的两项A2i-1与A2i(1≤i≤n)满足奇数项小于偶数项，即：A2i-1 &lt; A2i。 现在的任务是：对于给定的n，请求出有多少个不同的长度为2n的有趣的数列。因为最后的答案可能很大，所以只要求输出答案 mod P的值。 输入格式 用空格隔开的两个整数n和P。 50%的数据满足n≤1000 100%的数据满足n≤1000000且P≤1000000000。 输出格式 仅含一个整数，表示不同的长度为2n的有趣的数列个数mod P的值。 样例输入 3 10 样例输出 5 简单考虑一下，设 $F[2n]$ 为长度为 $2n$ 时满足条件的排列数 将它划分成两段来考虑，保证一段中的任意一个数大于另一段中的任意一个数 那么有 $F[2n]=F[2n-2]\times F[2]+F[2n-4]\times F[4]……$ ，那么这就是卡特兰数 正确性考虑一下发现每种排列都会且仅会被讨论到一次。当然，打表找规律更加直接。 接下来如何算卡特兰数，只需要分解质因数处理即可。分解质因数时需要用到线性筛，记录下一个合数的质因数分解链，具体实现参见代码。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define N 3333333#define ll long longusing namespace std;ll n,p,P[N],cnt[N],Las[N],tot,ans=1;bool mark[N];void Linear()&#123; ll i,j,x=2*n; for(i=2;i&lt;=x;i++) &#123; if(!mark[i])P[++tot]=i; for(j=1;j&lt;=tot&amp;&amp;P[j]*i&lt;=x;j++) &#123; mark[i*P[j]]=1; Las[i*P[j]]=j;//质因数链 if(i%P[j]==0)break; &#125; &#125;&#125;void Ins(ll x,ll ty)&#123; while(x&gt;1) &#123; if(!mark[x])&#123;cnt[x]+=ty;return;&#125; cnt[P[Las[x]]]+=ty; x/=P[Las[x]]; &#125;&#125;ll QM(ll a,ll b)&#123; ll sum=1; while(b) &#123; if(b&amp;1)sum=sum*a%p; b&gt;&gt;=1;a=a*a%p; &#125; return sum;&#125;int main()&#123; ll i; scanf("%lld%lld",&amp;n,&amp;p); Linear(); Ins(n+1,-1); for(i=2;i&lt;=n;i++)Ins(i,-1); for(i=n+1;i&lt;=2*n;i++)Ins(i,1); for(i=1;i&lt;=2*n;i++) if(cnt[i])ans=ans*QM(i,cnt[i])%p; cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>卡特兰数</category>
        <category>线性筛</category>
      </categories>
      <tags>
        <tag>线性筛</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3615(CQOI 2016) 路由表（trie）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-3615-CQOI-2016-%E8%B7%AF%E7%94%B1%E8%A1%A8%EF%BC%88trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3615【CQOI2016 Day2】路由表 问题描述 输入格式 第一行，一个整数n，表示操作次数。 接下来n行，每行描述一次操作，操作有两种： A D/L 其中D为一个IP地址，L为整数(1&lt;=L&lt;=32)。添加一条表项至路由表，其目的地址为D，掩码长度为L。下一条地址由于没有用到，故省略。 Q D a b 其中，D为一个IP地址，a、b为正整数(a&lt;=b).查询从第a到第b次调价表项期间（含a,b）,目的地址D的路由表项选择发生了多少次变化。保证查询时表中至少有b个表项目 输出格式 若干行，每行一个整数，表示对应查询操作 样例输入 11 A 0.0.0.0/8 Q 1.2.3.4 1 1 A 1.0.0.0/9 A 1.128.0.0/10 A 1.0.0.0/10 A 1.0.0.0/8 Q 1.2.3.4 1 5 A 1.2.0.0/16 A 1.2.3.1/32 Q 1.2.3.4 5 7 Q 1.2.3.1 5 7 样例输出 0 2 1 2 提示 对于一次查询的一种理解方式是：无视其它所有查询操作，只看添加操作。先清空路由表，然后执行第1到a-1次添加操作。之后再统计第a到b次添加操作过程中，统计匹配改变的次数。 设一条表项的掩码长度为L，数据保证将目的地址转为二进制串后，末尾的32-L位均为0 数据范围：n&lt;=$10^5$ 此题只需要将IP转化为一个字符串后添加入一个trie中，每次查询时暴力匹配，将1到b次添加操作之间的串拿出来，按照操作顺序排序，然后按题目要求搞就行了。由于要求改变量，所以必须知道1-a-1次操作后的情况。 附上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct node&#123;int son[2],num,len;&#125;trie[5000000],A[123456];int tot=1,rt=1,cnt;char s[45];bool cmp(node a,node b)&#123;return a.num&lt;b.num;&#125;void CHA(int l,int x)&#123; for(int i=7;i&gt;=0;i--) s[++l]=(1&amp;(x&gt;&gt;i))+48;&#125;void TRA(int a,int b,int c,int d)&#123; CHA(0,a); CHA(8,b); CHA(16,c); CHA(24,d);&#125;void Ins(int L,int k)&#123; int p=1,i,c; for(i=1;i&lt;=L;i++) &#123; c=s[i]-48; if(!trie[p].son[c])trie[p].son[c]=++tot; p=trie[p].son[c]; &#125; trie[p].num=k; trie[p].len=L;&#125;void Find(int L,int b)&#123; int p=1,i,c; for(i=1;i&lt;=L;i++) &#123; c=s[i]-48; if(!trie[p].son[c])return; p=trie[p].son[c]; if(trie[p].num&lt;=b&amp;&amp;trie[p].num) &#123; cnt++; A[cnt].num=trie[p].num; A[cnt].len=trie[p].len; &#125; &#125;&#125;void ADD(int k)&#123; int a,b,c,d,l; scanf("%d.%d.%d.%d/%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;l); TRA(a,b,c,d);Ins(l,k);&#125;void Solve()&#123; int i,a,b,c,d,l,r,k=0,ans=0;cnt=0; scanf("%d.%d.%d.%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;l,&amp;r); TRA(a,b,c,d);Find(32,r); if(cnt==0)&#123;puts("0");return;&#125; sort(A+1,A+cnt+1,cmp); for(i=1;i&lt;=cnt;i++) if(A[i].len&gt;k) &#123; k=A[i].len; if(A[i].num&gt;=l)ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; int i,k=0,n;char a; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; a=getchar(); while(a!='A'&amp;&amp;a!='Q')a=getchar(); if(a=='A')ADD(++k); else Solve(); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>trie</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3253 (CQOI 2015) 标识设计（状压DP）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-3253-CQOI-2015-%E6%A0%87%E8%AF%86%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%8A%B6%E5%8E%8BDP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[3253【CQOI2015】标识设计 问题描述 一家名字缩写为LLL的公司正在设计logo，他们的初步方案是在一张方格上放置3个L形的图案以及一些额外的装饰性图形。例如： （灰色区域表示装饰性图形） 3个L图案和装饰性图形均放置在方格之中，且必须占满方格。&quot;L&quot;的横竖笔画长短均可，但长度必须大于0（即不能退化为一条线段）。另外，为了使L图案醒目且容易辨别，设计师规定3个L形图案之间不能有重叠或交叉的部分。当然，L形图案也不能穿过装饰图形或与之重叠。 现在设计师已经确定了所有装饰性图形的位置，希望你计算一下放置不同的L形图案总共可以设计出多少个logo。 输入格式 输入文件第一行包含两个空格分开的正整数n和m，分别表示方格的行数和列数。 接下来n行，每行m个字符，为&quot;.&quot;或&quot;#&quot;。&quot;#&quot;表示该方格为装饰性图形，&quot;.&quot;表示可以放置L图案的空白区域。 输出格式 输出一个整数，为可能的logo总数。 样例输入 4 4 .... #... .... ..#. 样例输出样例输出 4 提示 样例解释： 满足要求的logo只有这4种。注意，颜色只是为了便于说明，不影响方案数，因为在实际的logo中3个L图案将使用相同的色彩、纹理和光泽。 数据范围： 对于30%的数据，n,m≤5。 对于100%的数据，2≤n,m≤30。 首先，根据题意很容易想到利用DP来求解，那么问题在于如何确定状态。 我们可以将这三个“L”型的标记看成三条路径，然后问题就变成求三条互不相交的“L”型的路径。 观察“L”的特点我们发现，相当于是我在拓展这条路的时候只能向下或向右走，于是我们可以列出如下状态： $F[x][y][re][s][ty]$ 我们来解释一下这个状态，他表示的是我当前讨论到了(x,y)这个格子，还剩下re个“L”没有放，然后s是一个状压的结果，他表示在二进制下，当前在某些列存在向下走的路径，但还没有开始向右走，ty表示当前是否有路径正在向右走。 由于可能的转移只能是路径向下或向右延伸，因此我们可以推出转移方式（以下可以直接看代码）： 若当前格子在一条向下走的路径上，那么他有向下和向右两种转移。 若当前格子在一条向右走的路径上，那么他有向右和停止两种转移。 若当前格子不在路径上，并且res&gt;0&amp;&amp;y≠m，那么他可以作为一条路径的起点。若当前格子是障碍格，并且处在一条路径上，那么返回0。若当前格子同时在一条向右走的路径和向下走的路径上，那么返回0。若当前y&gt;m，跳到下一行。若当前x&gt;n，但还有“L”没放或者还有路径在向下走，那么返回0，否则返回1。 从上到下，从左到右，逐行逐列DP即可。 最后我们来看看s表示的状态，由于我们最多只需要放3个“L”，那么我们最多同时存在三列有向下走的路径，因此s的状态总数的最大值等于4525种，貌似还没有这么多，忽略。因此我们可以提前离散化。 于是我们可以用记忆化搜索的形式来写，具体情况参见代码。 代码写的很渣，亟待改进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define N 32#define M 5000#define ll long longusing namespace std;ll n,m,F[N][N][4][M][2];char G[N][N];map&lt;ll,ll&gt;Q;ll R[M],cnt;ll DP(ll x,ll y,ll re,ll s,ll ty)//讨论到(x,y)，还剩下 res个L没放，当前状态是s，表示向下的路径的位置，ty表示是否处在向右的路径上 &#123; ll i,j,k,tmp=0,t=R[s];//离散化回来 if(F[x][y][re][s][ty]&gt;-1)return F[x][y][re][s][ty];//记忆化搜索 if(x&gt;n) &#123; if((!re)&amp;&amp;(!t))return F[x][y][re][s][ty]=1;//L已经放完并且都已经完成了向右走，返回1 return F[x][y][re][s][ty]=0;//否则返回0 &#125; if(y&gt;m) &#123; if(ty)return F[x][y][re][s][ty]=0;//如果当前处在向右的路径上，返回0 return F[x][y][re][s][ty]=DP(x+1,1,re,s,0);//否则跳到下一行继续dp &#125; if((1&lt;&lt;y-1)&amp;t)//如果当前格子在一条向下的路径上 &#123; if(G[x][y]=='#'||ty)return F[x][y][re][s][ty]=0;//如果他同时在一条向右的路径上，或者是障碍，返回0 return F[x][y][re][s][ty]=DP(x,y+1,re,s,0)+DP(x,y+1,re,Q[t^(1&lt;&lt;y-1)],1);//否则返回这条路径向右走和向下走的方案和（如果开始向右走，那么不能再向下走，记变状态） &#125; if(ty)//如果当前格子在一条向右的路径上 &#123; if(G[x][y]=='#')return F[x][y][re][s][ty]=0;//如果当前格子是障碍，返回0 return F[x][y][re][s][ty]=DP(x,y+1,re,s,1)+DP(x,y+1,re,s,0);//否则返回这条路径终止和向右走的方案和 &#125; tmp=DP(x,y+1,re,s,ty);//什么也不做，讨论下一格 if(re&gt;0&amp;&amp;G[x][y]=='.'&amp;&amp;y&lt;m)tmp+=DP(x,y+1,re-1,Q[t|(1&lt;&lt;y-1)],ty);//如果当前格子可以作为一条路径的起点，那么新增一条路径 return F[x][y][re][s][ty]=tmp;//返回当前的方案数 &#125;int main()&#123; memset(F,-1,sizeof(F)); ll i,j,k,t,tt,ttt; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%s",&amp;G[i][1]); Q[0]=++cnt;R[cnt]=0;//离散化状态 for(i=1;i&lt;=m;i++) &#123; t=1&lt;&lt;i-1; Q[t]=++cnt;R[cnt]=t; for(j=i+1;j&lt;=m;j++) &#123; tt=t|(1&lt;&lt;j-1); Q[tt]=++cnt;R[cnt]=tt; for(k=j+1;k&lt;=m;k++) &#123; ttt=tt|(1&lt;&lt;k-1); Q[ttt]=++cnt; R[cnt]=ttt; &#125; &#125; &#125; ll ans=DP(1,1,3,0,0); cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>杂学</category>
        <category>状态压缩</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 1987 手机游戏（高斯消元）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-1987-%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[手机游戏 问题描述 有一个有趣的手机游戏，有n*n个正方形的小按钮，有的按钮是黄色，有的按钮是白色。玩家的任务是通过点击按钮，让所有按钮都变成黄色，点按钮的次数越少，得分越高。 但是按钮有个奇怪的特点，当你点击了坐标为(x,y)的按钮后，坐标为(x,y),(x+1,y),(x-1,y),(x,y-1),(x,y+1)的五个按钮会同时改变自身的颜色，是白色的变成黄色，黄色的变成白色。完成游戏最少需要点击多少次按钮呢？请找出答案。 输入格式输入格式 第一行，一个整数n，表示有n*n个按钮。(1&lt;=n&lt;=40) 接下来是一个由小写字母&apos;y&apos;和字符&apos;w&apos;构成的n*n的矩阵，描述了游戏开始时的情景。&apos;y&apos;表示该按钮式黄色，&apos;w&apos;表示该按钮式白色。 输出格式 如果能够完成游戏，输出一个整数，表示所需最小点击次数。 如果无法完成游戏，输出&quot;inf&quot; 样例输入 样例输入1： 2 yw ww 样例输入2： 5 wwwww wwwww wwwww wwwww wwwww 样例输出 样例输出1： 1 样例输出2： 15 此题是高斯消元的模板题，显然将每一个格子当成未知数，按为1，不按为0，然后地图上每一个格子是否需要按作为常数，系数则是两个格子之间能否相互影响。高斯消元求解后的1的个数就是答案。此题坑点在于，因为可能存在自由变元，所以需要用DFS来枚举自由变元的取值最后取最优值。 关于时间复杂度，由于每个X最多和5个方程有关，所以消去一个X最多只需要4次消元，因此时间复杂度是$4N^2$也就是$4n^4$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1644using namespace std;char map[44][44];int n,m[N][N],X[N],id[44][44],cnt,ans=1e9,tot,dx[4]=&#123;0,0,1,-1&#125;,dy[4]=&#123;1,-1,0,0&#125;;void dfs(int x,int y)&#123; if(x==0&amp;&amp;y==0) &#123; int tmp=0; for(int i=1;i&lt;=tot;i++)tmp+=X[i]; if(ans&gt;tmp)ans=tmp; return; &#125; if(x==y) &#123; X[y]=m[x][tot+1]; for(int i=x+1;i&lt;=tot;i++)X[y]^=(X[i]&amp;m[x][i]); dfs(x-1,y-1); &#125; else &#123; X[y]=0;dfs(x,y-1); X[y]=1;dfs(x,y-1); &#125;&#125;int Gauss(int row,int col)&#123; int MR,i,j,k,x,y,temp; for(x=1,y=1;x&lt;=row&amp;&amp;y&lt;col;x++,y++) &#123; MR=x; for(i=x+1;i&lt;=row;i++) &#123; if(m[i][y]&gt;m[MR][y])MR=i; if(m[MR][y]==1)break; &#125; if(MR!=x)for(i=1;i&lt;=col;i++)swap(m[x][i],m[MR][i]); if(m[x][y]==0)&#123;x--;continue;&#125; for(i=x+1;i&lt;=row;i++) if(m[i][y]!=0)for(j=y;j&lt;=col;j++)m[i][j]^=m[x][j]; &#125; for(i=x;i&lt;=row;i++)if(m[i][col])return -1; dfs(x-1,col-1); return 0;&#125;int main()&#123; int i,j,k,x,y; scanf("%d",&amp;n);tot=n*n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)id[i][j]=++cnt; for(i=1;i&lt;=n;i++)scanf("%s",&amp;map[i][1]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++)if(map[i][j]=='w')m[id[i][j]][tot+1]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) &#123; m[id[i][j]][id[i][j]]=1; for(k=0;k&lt;4;k++) &#123; x=i+dx[k];y=j+dy[k]; if(x&amp;&amp;y&amp;&amp;x&lt;=n&amp;&amp;y&lt;=n)m[id[x][y]][id[i][j]]=1; &#125; &#125; x=Gauss(tot,tot+1); if(x==-1)puts("inf"); else cout&lt;&lt;ans;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3252 (CQOI 2015) 多项式（数学，高精度）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-3252-CQOI-2015-%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[P3252【CQOI2015】多项式 问题描述​ 在学习完二项式定理后，数学老师给出了一道题目：已知整数n,t和ak(0≤k≤n)，求bk(0≤k≤n)的表达式使得 同学们很快算出了答案。见大家这么快就搞定了，老师便布置了一个更BT的作业：计算某个bk的具体数值！接着便在黑板上写下了n,t的数值，由于ak实在太多，不能全写在黑板上，老师只给出了一个ak的递推式，让学生自行计算 正在学习信息竞赛的你觉得这个作业实在不适合手工完成，便敲起了代码…… 输入格式 输入文件共三行，第一行为一个正整数n，第二行为一个非负整数t，第三行为一个非负整数m。 输出格式 输出一行，为bm的值。 样例输入 322 样例输出 10536 提示 样例解释： a0=1, a1=134, a2=1584, a3=1492。 b0=18541, b1=24374, b2=10536, b3=1492。 1492y^3 + 1584y^2 + 134y + 1 = 1492(y-2)^3 + 10536(y-2)^2 + 24374(y-2) + 18541。 数据范围： 对于20%的数据，t=0。 对于另外30%的数据，n≤100000。 对于100%的数据，0&lt;n≤10^3000，0≤t≤10000，0≤n-m≤5。 根据pwj大佬提供的公式$F(x)=\sum^n_{k=0}a_kx^k=\sum^n_{k=0}b_k(x-t)^k$抄袭pwj大佬说的在x=t处泰勒展开$\begin{align}F(x)=\sum^n_{k=0}\frac{F^{(k)}(t)}{k!}(x-t)^k\end{align}$于是我们有$b_m=\frac{F^{(m)}\ (t)}{m!}$最后再根据pwj大佬所说 $\frac{F^{(m)}(t)}{m!}=\sum_{k=0}^{n-m}\binom{m+k}{k} a_{m+k}t^k$于是这道题就解决了。最后用高精度乱搞即可。最后只能%%%pwj大佬。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const ll mod=1e9;struct Big&#123; ll S[12345],T,cur; void Input() &#123; string s;cin&gt;&gt;s;ll i,t,l=s.length(); for(i=0;i&lt;l;i++) &#123; t=(l-i-1)/9;S[t]=S[t]*10+s[i]-48; T=T*10+s[i]-48;T%=3388; &#125; cur=(l-1)/9;while(cur&gt;0&amp;&amp;S[cur]==0)cur--; &#125; void Output() &#123; printf("%lld",S[cur]); ll i,k; for(i=cur-1;i&gt;=0;i--) &#123; k=mod/10; while(k&gt;S[i])putchar('0'),k/=10; if(k)printf("%lld",S[i]); &#125; &#125; void add(ll k) &#123; S[0]+=k;ll i=0; while(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i++]%=mod; if(S[cur+1])cur++; &#125; void ADD(const Big&amp; o) &#123; ll i,r=max(o.cur,cur); for(i=0;i&lt;=r;i++) &#123; S[i]+=o.S[i]; if(S[i]&gt;=mod)S[i+1]+=S[i]/mod,S[i]%=mod; &#125; cur=r+5;while(cur&gt;0&amp;&amp;S[cur]==0)cur--; &#125; void Multiply(const Big&amp; o,Big&amp; E) &#123; ll i,j;memset(&amp;E,0,sizeof(E)); for(i=0;i&lt;=cur;i++) for(j=0;j&lt;=o.cur;j++) &#123; E.S[i+j]+=S[i]*o.S[j]; if(E.S[i+j]&gt;=mod) &#123; E.S[i+j+1]+=E.S[i+j]/mod; E.S[i+j]%=mod; &#125; &#125; E.cur=cur+o.cur+5; while(E.cur&gt;0&amp;&amp;E.S[E.cur]==0)E.cur--; &#125; void Divide(ll k) &#123; for(ll i=cur;i&gt;0;i--) &#123; S[i-1]+=S[i]%k*mod;S[i]/=k; if(S[cur]==0)cur--; &#125; S[0]/=k; &#125;&#125;;Big N,M,C[12],t1,t2,t3,P[12],Ans;ll a,i,j,k,K;int main()&#123; N.Input();P[1].Input();M.Input(); K=N.T-M.T;if(K&lt;0)K+=3388; a=1;for(i=1;i&lt;=M.T;i++)a=(1234*a+5678)%3389; Ans.add(a);C[0].S[0]=1; for(k=1;k&lt;=K;k++) &#123; M.add(1); C[k-1].Multiply(M,C[k]); C[k].Divide(k); a=(a*1234+5678)%3389; P[k].Multiply(P[1],P[k+1]); t2.S[0]=a; C[k].Multiply(t2,t1); P[k].Multiply(t1,t3); Ans.ADD(t3); &#125; Ans.Output();&#125;]]></content>
      <categories>
        <category>高精度</category>
      </categories>
      <tags>
        <tag>数学杂题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 3249(CQOI 2015) 选数（莫比乌斯反演，杜教筛）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-3249-CQOI-2015-%E9%80%89%E6%95%B0%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%EF%BC%8C%E6%9D%9C%E6%95%99%E7%AD%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[选数问题描述 我们知道，从区间[L,H]（L和H为整数）中选取N个整数，总共有(H-L+1)N种方案。小z很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的N个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。 你的任务很简单，小z会告诉你一个整数K，你需要回答他最大公约数刚好为K的选取方案有多少个。由于方案数较大，你只需要输出其除以1000000007的余数即可。 输入格式 输入一行，包含4个空格分开的正整数，依次为N,K,L和H。 输出格式 输出一个整数，为所求方案数。 样例输入 2 2 2 4 样例输出 3 提示 样例解释： 所有可能的选择方案：(2,2), (2,3), (2,4), (3,2), (3,3), (3,4), (4,2), (4,3), (4,4)。 其中最大公约数等于2的只有3组：(2,2), (2,4), (4,2)。 数据范围： 对于30%的数据，N≤5，H-L≤5。 对于100%的数据，1≤N,K≤10^9，1≤L≤H≤10^9，H-L≤10^5。 首先，在[L,H]中选最大公约数为K的N个数显然等价于[L/K,H/K]中选最大公约数为1的N个数。因此，令A=(L-1)/K,B=H/K（为何要-1呢，主要是因为后面要用减法求可行数的范围（类似于前缀和）而除K后是要取整的，所以范围在这里先确定下来）推导一下：这样，如果我们能求出u的前缀和，那么就可以在$\sqrt{n}*\log{n}$的复杂度内解决这个问题。但是，当H很大而K很小时，B可能会很大以至于线性筛无法解决，这个时候我们可以用传说中的杜教筛来解决。他的数学基础是:这样，我们就可以递归的求出我们想要的前缀和了，注意到当n比较小的时候我们是可以线性筛求出来的。所以设置一个分界U，当n&lt;=U时用线性筛预处理。并且，经过复杂的推导我们知道当U=$n^{\frac{2}{3}}$最小为$n^{\frac{2}{3}}$ 具体实现可以参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define ll long long#define U 1000000using namespace std;map&lt;ll,ll&gt;Q;ll p[U+5],mu[U+5],smu[U+5],tot,mod=1000000007;bool mark[U+5];ll QM(ll a,ll b)&#123; ll ans=1;a%=mod; while(b) &#123; if(b&amp;1)ans=ans*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return ans;&#125;void EU()&#123; mu[1]=1;smu[1]=1; for(ll i=2;i&lt;=U;i++) &#123; if(!mark[i])p[++tot]=i,mu[i]=-1; for(ll j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;=U;j++) if(i%p[j])mark[i*p[j]]=1,mu[i*p[j]]=-mu[i]; else &#123;mark[i*p[j]]=1;mu[i*p[j]]=0;break;&#125; smu[i]=(smu[i-1]+mu[i])%mod; &#125;&#125;ll Mu(ll n)&#123; if(n&lt;=U)return smu[n]; if(Q.count(n))return Q[n]; ll ans=1,j,i; for(i=2;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans=(ans-Mu(n/i)*(j-i+1)%mod)%mod; &#125; Q[n]=ans; return ans;&#125;int main()&#123; ll N,K,L,H,i,j,ans=0; scanf("%lld%lld%lld%lld",&amp;N,&amp;K,&amp;L,&amp;H); EU();L=(L-1)/K;H=H/K; for(i=1;i&lt;=H;i=j+1) &#123; j=H/(H/i); if(L/i)j=min(j,L/(L/i)); ans=(ans+(Mu(j)-Mu(i-1))*QM(H/i-L/i,N)%mod)%mod; &#125; cout&lt;&lt;(ans+mod)%mod;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ 4038 (CQOI 2017) 小Q的棋盘（贪心）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ-4038-CQOI-2017-%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[考虑到是一颗树，所以先找出从0号点出发的最长链，假设长度为L。 如果L&gt;=N，那么答案就是N+1 如果L&lt;N，此时肯定发生了某些点走两次的情况，那么最优解就是在一些链上走2次，最后在最长链上走到底，这是显然的。因此答案是（N-L）/2+L+1 附上代码 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 12345using namespace std;int v,n,l;int LA[N],NE[N],EN[N],TOT;void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int x,int f,int d)&#123; l=max(l,d); for(int i=LA[x];i;i=NE[i]) if(EN[i]!=f)DFS(EN[i],x,d+1);&#125;int main()&#123; int i,x,y; scanf("%d%d",&amp;v,&amp;n); for(i=1;i&lt;v;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; DFS(0,-1,0); if(l&gt;=n)cout&lt;&lt;n+1; else cout&lt;&lt;min((n-l)/2+l+1,v);&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ3776 工资管理（树状数组）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ3776-%E5%B7%A5%E8%B5%84%E7%AE%A1%E7%90%86%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述 何老板的公司有n名员工，编号1到n。一开始所有员工的工资都是0。根据何老板的心情好坏，可能出现下列两种针对员工工资的操作：1.U x y 改工资操作：何老板将第x号员工的工资改成了y；2.Z x y 减工资操作：何老板生气了，他想选出x个员工，并将他们的工资全都减去1。何老板想知道，他能否一口气进行y次这样的减工资操作。能输出TAK，否则输出NIE。注意，员工的工资不能为负。 对于每个减工资的操作，何老板只是在心里想想，口头上说说，吓唬吓唬大家，解解闷气，他并不会真正执行。即不会对任何人的工资进行修改。 输入格式 第一行包含两个正整数n,m，分别表示员工的人数和操作次数。接下来m行，每行一个操作，形式如题面所述。 输出格式 包含若干行，对于每个减工资操作，若可行，输出TAK，否则输出NIE。 样例输入 1 3 8U 1 5U 2 7Z 2 6U 3 1Z 2 6U 2 2Z 2 6Z 2 1 样例输出 1 NIETAKNIETAK 样例输入 2 13 17U 1 12Z 1 9Z 1 5Z 4 7U 7 18Z 1 1Z 1 8U 6 4U 1 9U 3 13Z 5 2U 7 8U 4 20U 7 14Z 6 1Z 3 2Z 8 7 样例输出 2 TAKTAKNIETAKTAKNIENIETAKNIE 提示 对于30%的数据：$1&lt;=n,m&lt;=1000$对于100%的数据：$1&lt;=n,m&lt;=200000,1&lt;=x&lt;=n，0&lt;=y&lt;=10^9,1&lt;=y&lt;=10^9$ 主要问题在操作2。首先相当将工资大于等于y的人数记为c，那么现在问题变成工资小于y的人能否每次选出（x-c）个人来完成y次操作。因为每个人工资是小于y的，如果剩下的人的工资总和不足 $y\times(x-c)$ 那么显然不行，如果剩下的人的工资总和大于 $y\times(x-c)$ ，那么剩下的人数显然大于x-c，考虑一下发现显然可行。因为如果某次操作后选不出x-c个人，而总和大于 $y\times(x-c)$那么就有人的工资大于y。 附上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 1234567using namespace std;ll c[N],d[N];ll ty[N],a[N],b[N],w[N],n,m;ll v[N],tot,t;void MDc(ll x,ll k)&#123;for(ll i=x;i&lt;=tot;i+=(i&amp;-i))c[i]+=k;&#125;void MDd(ll x,ll k)&#123;for(ll i=x;i&lt;=tot;i+=(i&amp;-i))d[i]+=k;&#125;ll GSc(ll x)&#123; ll i,sum=0; for(i=x;i&gt;0;i-=(i&amp;-i))sum+=c[i]; return sum;&#125;ll GSd(ll x)&#123; ll i,sum=0; for(i=x;i&gt;0;i-=(i&amp;-i))sum+=d[i]; return sum;&#125;int main()&#123; char s;ll i; scanf("%lld%lld",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) &#123; s=getchar(); while(s!='U'&amp;&amp;s!='Z')s=getchar(); scanf("%lld%lld",&amp;a[i],&amp;b[i]); if(s=='U')ty[i]=1;else ty[i]=2; v[++tot]=b[i]; &#125; sort(v+1,v+tot+1); for(i=1;i&lt;=m;i++)b[i]=lower_bound(v+1,v+tot+1,b[i])-v; for(i=1;i&lt;=m;i++) &#123; if(ty[i]==1) &#123; if(w[a[i]])MDc(w[a[i]],-1); MDc(b[i],1); if(w[a[i]])MDd(w[a[i]],-v[w[a[i]]]); MDd(b[i],v[b[i]]); w[a[i]]=b[i]; &#125; else &#123; t=GSc(tot)-GSc(b[i]-1); if(t&gt;=a[i])puts("TAK"); else &#123; if(GSd(b[i]-1)&gt;=(a[i]-t)*v[b[i]])puts("TAK"); else puts("NIE"); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ3958 （CQOI 2015）JZPTAB（莫比乌斯反演）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ3958-%EF%BC%88CQOI-2015%EF%BC%89JZPTAB%EF%BC%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述 输入格式 一个正整数T表示数据组数。 接下来T行 每行两个正整数 表示N、M。（T &lt;= 10000；N, M&lt;=10000000） 输出格式 共T行，每行一个整数 表示第i组数据的结果。 样例输入 1 14 5 样例输出 1 122 样例输入 2 5555 785450 31728 26284 132602 341 样例输出 2 64864969412437801031585967236439607508 话不多说，直接推导 S可以O(1)求出来，后面的一坨显然是积性的，只需要将后面的求和在线性筛的时候预处理出来即可。线性筛部分具体可参见代码。于是就可以在根号的复杂度内完成每次询问。最后注意要多取模，尤其是在算S的时候。(亲测30分) 附上代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define ll long long#define N 10000005using namespace std;ll T,n,m,p[N],g[N],s[N],ans,tot,mod=100000009;bool mark[N];int main()&#123; ll t,q,i,j; scanf("%lld",&amp;T); g[1]=1;s[1]=1; for(i=2;i&lt;N;i++) &#123; if(!mark[i])p[++tot]=i,g[i]=(i-i*i)%mod; for(j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++) if(i%p[j])mark[i*p[j]]=1,g[i*p[j]]=g[i]*g[p[j]]%mod; else &#123;mark[i*p[j]]=1;g[i*p[j]]=g[i]*p[j]%mod;break;&#125; s[i]=(s[i-1]+g[i])%mod; &#125; while(T--) &#123; scanf("%lld%lld",&amp;n,&amp;m); t=min(n,m);ans=0; for(i=1;i&lt;=t;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); q=(((n/i)*(n/i+1)&gt;&gt;1)%mod)*(((m/i)*(m/i+1)&gt;&gt;1)%mod)%mod; ans=(ans+q*(s[j]-s[i-1])%mod)%mod; &#125; printf("%lld\n",(ans+mod)%mod); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ3251 (CQOI 2015)任务查询系统（差分数组+主席树）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ3251-CQOI-2015-%E4%BB%BB%E5%8A%A1%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84-%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述​ 最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。 超级计算机中的任务用三元组(Si,Ei,Pi)描述，(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束（第Si秒和Ei秒任务也在运行），其优先级为Pi。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。 调度系统会经常向查询系统询问，第Xi秒正在运行的任务中，优先级最小的Ki个任务（即将任务按照优先级从小到大排序后取前Ki个）的优先级之和是多少。特别的，如果Ki大于第Xi秒正在运行的任务总数，则直接回答第Xi秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在1到n之间（包含1和n）。 输入格式​ 输入文件第一行包含两个空格分开的正整数m和n，分别表示任务总数和时间范围。 接下来m行，每行包含三个空格分开的正整数Si,Ei和Pi(Si≤Ei)，描述一个任务。 接下来n行，每行包含四个空格分开的整数Xi,Ai,Bi和Ci，描述一次查询。查询的参数Ki需要由公式 Ki = 1 + ( Ai * Pre + Bi ) mod Ci 计算得到。其中Pre表示上一次查询的结果，对于第一次查询，Pre=1。 输出格式​ 输出共n行，每行一个整数，表示查询结果。 样例输入4 31 2 62 3 31 3 23 3 43 1 3 21 1 3 42 2 4 3 样例输出2811 提示样例解释： K1=(11+3)%2+1=1； K2=(12+3)%4+1=2； K3=(2*8+4)%3+1=3。数据范围： 对于50%的数据，Ai=0。 对于100%的数据，1≤m,n,Si,Ei,Ci≤100000，0≤Ai,Bi≤100000，1≤Pi≤10000000，Xi为1到n的一个排列。 ​ 求前K小的和，实际上和求第K小一样，过程中累加一下sum就好。 ​ 然后根据时间建立n棵主席树，每个任务会修改Si到Ei这么多数，区间修改，用一点差分的思想相当于是在第Si棵树上加，在第Ei+1棵树上减，最后求个前缀就好。 ​ 具体实现时只需要按照操作的时间排序后不断加入就好。当将时间在Xi前的操作全部加入树上后得到的就是Xi时间的树。 ​ 最后说一下，因为在查询答案时到达底层节点时要取得前K个，所以需要将sum/cnt*k。（亲测乱写能得80分） 附上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define M 20000000#define N 300000using namespace std;struct node&#123;ll x,y,ny,d;&#125;A[N];bool cmp(node a,node b)&#123;return a.x&lt;b.x;&#125;ll B[N],rt[N],m,n,pre=1;ll ls[M],rs[M],cnt[M],sum[M],tot;ll CO(ll p)&#123; ll o=++tot; ls[o]=ls[p];rs[o]=rs[p]; cnt[o]=cnt[p];sum[o]=sum[p]; return o;&#125;ll ADD(ll p,ll l,ll r,ll k,ll sd,ll cd)&#123; ll o=CO(p); if(l==r)&#123;cnt[o]+=cd;sum[o]+=cd*sd;&#125; else &#123; ll mid=l+r&gt;&gt;1; if(k&lt;=mid)ls[o]=ADD(ls[o],l,mid,k,sd,cd); else rs[o]=ADD(rs[o],mid+1,r,k,sd,cd); cnt[o]=cnt[ls[o]]+cnt[rs[o]]; sum[o]=sum[ls[o]]+sum[rs[o]]; &#125; return o;&#125;ll ASK(ll p,ll l,ll r,ll k)&#123; if(l==r)return sum[p]/cnt[p]*k; ll mid=l+r&gt;&gt;1; if(cnt[ls[p]]&gt;=k)return ASK(ls[p],l,mid,k); return ASK(rs[p],mid+1,r,k-cnt[ls[p]])+sum[ls[p]];&#125;int main()&#123; ll i,j=1,k,p,a,b,c; scanf("%lld%lld",&amp;m,&amp;n); for(i=1;i&lt;=m;i++) &#123; scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c); B[i]=c; A[i].x=a;A[i].y=c;A[i].d=1; A[i+m].x=b+1;A[i+m].y=c;A[i+m].d=-1; &#125; sort(B+1,B+m+1); sort(A+1,A+2*m+1,cmp); for(i=1;i&lt;=2*m;i++)A[i].ny=lower_bound(B+1,B+m+1,A[i].y)-B; for(i=1;i&lt;=n;i++) &#123; rt[i]=rt[i-1];j--; while(A[++j].x==i)rt[i]=ADD(rt[i],1,m,A[j].ny,A[j].y,A[j].d); &#125; for(i=1;i&lt;=n;i++) &#123; scanf("%lld%lld%lld%lld",&amp;k,&amp;a,&amp;b,&amp;c); p=1+(a*pre+b)%c; if(p&gt;cnt[rt[k]])pre=sum[rt[k]]; else pre=ASK(rt[k],1,m,p); printf("%lld\n",pre); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>主席树</category>
        <category>杂学</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-Educational-25 E-Minimal Labels (拓扑排序）]]></title>
    <url>%2F2018%2F03%2F14%2FCF-Educational-25-E-Minimal-Labels-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[You are given a directed acyclic graph with n vertices and m edges. There are no self-loops or multiple edges between any pair of vertices. Graph can be disconnected. You should assign labels to all vertices in such a way that: Labels form a valid permutation of length n — an integer sequence such that each integer from 1 to n appears exactly once in it. If there exists an edge from vertex v to vertex u then labelv should be smaller than labelu. Permutation should be lexicographically smallest among all suitable. Find such sequence of labels to satisfy all the conditions. Input The first line contains two integer numbers n, m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105). Next m lines contain two integer numbers v and u (1 ≤ v, u ≤ n, v ≠ u) — edges of the graph. Edges are directed, graph doesn’t contain loops or multiple edges. Output Print n numbers — lexicographically smallest correct permutation of labels of vertices. Examples input 12343 31 21 33 2 output 11 3 2 input 1234564 53 14 12 33 42 4 output 14 1 2 3 input 123455 43 12 12 34 5 output 13 1 2 4 5 此题是拓扑排序裸题，但字典序要注意。取出节点时要先取出编号大的节点打上编号大的标签（反图），如果直接从小到大找入度为零的点然后编号的话会有反例 如图，如果从小到大讨论的话答案是 3 1 2 但显然正解是 2 3 1 附我naive的wa代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define N 2222222using namespace std;int n,m,d[N],tot,ans[N];int TOT,EN[N],NE[N],LA[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;int main()&#123; int i,j,x,y; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); d[y]++;ADD(x,y); &#125; for(i=1;i&lt;=n;i++)if(d[i]==0)q.push(i); while(!q.empty()) &#123; x=q.top(); q.pop(); ans[x]=++tot; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(d[y]&gt;0) &#123; d[y]--; if(d[y]==0)q.push(y); &#125; &#125; &#125; for(i=1;i&lt;=n;i++)printf("%d ",ans[i]);&#125; 附ac代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define N 222222using namespace std;int n,m,d[N],tot,ans[N];int TOT,EN[N],NE[N],LA[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;priority_queue&lt;int&gt;q;int main()&#123; int i,j,x,y; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); d[x]++;ADD(y,x); &#125; for(i=1;i&lt;=n;i++)if(d[i]==0)q.push(i); tot=n; while(!q.empty()) &#123; x=q.top(); q.pop(); ans[x]=tot--; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(d[y]&gt;0) &#123; d[y]--; if(d[y]==0)q.push(y); &#125; &#125; &#125; for(i=1;i&lt;=n;i++)printf("%d ",ans[i]);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder-RC078 D - Fennec VS. Snuke（博弈）]]></title>
    <url>%2F2018%2F03%2F14%2FAtCoder-RC078-D-Fennec-VS-Snuke%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Problem StatementFennec and Snuke are playing a board game. On the board, there are N cells numbered 1 through N, and N−1 roads, each connecting two cells. Cell ai is adjacent to Cell bi through the i-th road. Every cell can be reached from every other cell by repeatedly traveling to an adjacent cell. In terms of graph theory, the graph formed by the cells and the roads is a tree. Initially, Cell 1 is painted black, and Cell N is painted white. The other cells are not yet colored. Fennec (who goes first) and Snuke (who goes second) alternately paint an uncolored cell. More specifically, each player performs the following action in her/his turn: Fennec: selects an uncolored cell that is adjacent to a black cell, and paints it black. Snuke: selects an uncolored cell that is adjacent to a white cell, and paints it white. A player loses when she/he cannot paint a cell. Determine the winner of the game when Fennec and Snuke play optimally. Constraints 2≤N≤105 1≤ai,bi≤N The given graph is a tree. InputInput is given from Standard Input in the following format: 1234Na1 b1:aN−1 bN−1 OutputIf Fennec wins, print Fennec; if Snuke wins, print Snuke. 此题比较简单，因为是树，那么只需要考虑从1号点到n号点的路径上的点的数量，最优策略是优先取这条路径上的点，所以将1号点当成根遍历，从n回溯到1的过程中，找出哪些点是Snuke可以涂色的，将最后一个Snuke可以得到的点当根，最后一个Fennec可以得到的点所在子树的大小就是Fennec可以涂色的所有点，比较即可。 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 654321using namespace std;int n,rt,size[N],fa[N],cnt=0,sum1,sum2;int TOT,EN[N],LA[N],NE[N];void ADD(int x,int y)&#123; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void DFS(int u,int f)&#123; int i,v; fa[u]=f; size[u]=1; for(i=LA[u];i;i=NE[i]) &#123; v=EN[i]; if(v!=f) &#123; DFS(v,u); size[u]+=size[v]; &#125; &#125;&#125;int main()&#123; int i,x,y; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); ADD(x,y);ADD(y,x); &#125; DFS(1,0);i=n; while(i!=1)i=fa[i],cnt++; cnt--;i=0;x=n; while(i&lt;cnt/2)x=fa[x],i++; y=fa[x]; DFS(x,0); sum1=size[y];sum2=n-sum1; if(sum1&gt;sum2)cout&lt;&lt;"Fennec"; else cout&lt;&lt;"Snuke";&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NKOJ3959 天真的因数分解（二分答案+容斥原理+莫比乌斯函数）]]></title>
    <url>%2F2018%2F03%2F14%2FNKOJ3959-%E5%A4%A9%E7%9C%9F%E7%9A%84%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述 小岛: 什么叫做因数分解呢? doc : 就是将给定的正整数n, 分解为若干个素数连乘的形式. 小岛: 那比如说 n=12 呢? doc : 那么就是 12 = 2 X 2 X 3 呀. 小岛: 呜呜, 好难, 居然素数会重复出现, 如果分解后每一个素数都只出现一次, 我就会. wish: 这样来说, 小岛可以正确分解的数字不多呀. doc : 是呀是呀. wish: 现在问题来了, 对于给定的k, 第 k 个小岛无法正确分解的数字是多少? 输入格式 输入只有一行, 只有一个整数 k. 输出格式 输出只有一行, 只有一个整数, 表示小岛无法正确分解出来的第k个数字. 样例输入 1 10 样例输出 1 27 样例输入 2 23 样例输出 2 60 提示 对于30%的数据, k &lt;= 2,000,000 对于100%的数据, 1 &lt;= k &lt;= 10,000,000,000 ​ 首先，设要求的第K个无法正确分解的数为$A_k$，显然是没有关于k的式子可以直接推出$A_k$，所以考虑二分答案。 ​ 枚举一个数X，现在问题变成求1~X有多少个无法正确分解的数。 ​ 考虑一个无法正确分解的数M，那么将M标准分解后，肯定存在一个素因子P，且P的次数≥2。 ​ 那么 $\frac{x}{p^2}$ 显然表示了 $1-X$ 中包含 $p^2$ 的数的个数，因此枚举 $p$ 累加，但显然加重了，所以这里用容斥原理处理一下得到 $$Ans=\frac{X}{p_1^2}-\frac{X}{(p_1p_2)^2}+\frac{X}{(p_1p_2p_3)^2}\cdots$$​ 最后，观察一下系数，联想莫比乌斯函数，可以发现每一项前的系数就是分母内的数的莫比乌斯函数的相反数，并且分母的最大值显然是 $\sqrt{X}$，得到最后的求和式： $$Ans=\sum_{i=1}^{\sqrt{X}}-\mu(i)\frac{X}{i^2}$$​ 用线性筛预处理一下，至于二分的上限可以目测一下，我取的100*k，至此可以在 $O(\log{(ck)}\sqrt{ck}+\sqrt{ck})$ 的时间复杂度内解决该问题。 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define ll long long#define N 12345678using namespace std;ll k,n,p[N],tot;short mu[N];bool mark[N];void EU()&#123; ll i,j,x=sqrt(n); mu[1]=1; for(i=2;i&lt;=x;i++) &#123; if(!mark[i])p[++tot]=i,mu[i]=-1; for(j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;=x;j++) if(i%p[j])mark[i*p[j]]=1,mu[i*p[j]]=-mu[i]; else mark[i*p[j]]=1,mu[i*p[j]]=0; &#125;&#125;bool ok(ll x)&#123; ll i,y=sqrt(x),sum=0; for(i=2;i&lt;=y;i++)sum+=-mu[i]*(x/(i*i)); if(sum&gt;=k)return 0; return 1;&#125;ll EF(ll l,ll r)&#123; while(l&lt;=r) &#123; ll mid=l+r&gt;&gt;1; if(ok(mid))l=mid+1; else r=mid-1; &#125; return l;&#125;int main()&#123; scanf("%lld",&amp;k); n=100*k; EU(); cout&lt;&lt;EF(1,n);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>分治法</category>
        <category>二分答案</category>
        <category>容斥原理</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>容斥原理</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Newnode's NOI 模拟赛 第三题（可持久化线段树优化建图+Tarjan）]]></title>
    <url>%2F2018%2F03%2F14%2FNewnode-s-NOI-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-Tarjan%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三题问题描述 输入格式 第一行一个整数n。 接下来n行每行3个整数表示宇宙的三个属性(ai,bi,ci)。 输出格式 n行每行一个整数，如果第i个宇宙可以成为最大宇宙则第i行为1，否则为0。 样例输入 1 31 3 22 1 33 2 1 样例输出 1 111 样例输入 2 101 10 42 7 93 3 74 4 85 2 16 9 37 6 108 8 59 5 610 1 2 样例输出 2 1111011110 提示 对于20%的数据n&lt;=10；对于40%的数据n&lt;=500；对于60%的数据n&lt;=2000；对于100%的数据n&lt;=100000。 首先考虑暴力的做法。如果宇宙A大于宇宙B，那么从A到B连一条边，这样构好图后，可能成为最大的宇宙的点肯定满足从它出发可以到达所有能到达它的点。因此就是缩点后入度为0的点，注意到题目中给的$a_i,b_i,c_i$都是一个$1-n$的排列，那么任意两点间一定有一条边，因此入度为0的点只能有一个，反证即可证明。 因此可以暴力枚举点对来连边，然后跑Tarjan即可。这样的时空复杂度都是$O(n^2)$的。 考虑优化，用到了可持久化线段树来优化建边。首先，三种属性中至少有两种大于，可以通过枚举是那两种，变成恰有两种属性值大于，然后做三次就行了。 那么现在问题转化成$X_i&lt;X_j，Y_i&lt;Y_j$的点对连$j\rightarrow i$的边。注意到这是个二维偏序的问题，考虑一维排序来处理，那么现在按照$X_i$递增来考虑，需要将$i$点向$Y$值在$1-Y_i$中的点连边，直接连最多可能连$n^2$条边，但是可以用可持久化线段树来处理。 处理的方法是对$Y$值建立线段树，线段树中每个点向儿子连边，叶子节点向对应的$Y_i$对应的（原图中的）点连边，这样的话，如果要向$[1，Y_i]$中每个点连边，就只需要向线段树上，管辖$[1,Y_i]$这个区间的那个点连边就行了。最多拆成$\log_n$个线段树区间，因此每个点最多连出去$\log n$条边。 但是注意到还需要保证只向插入时间在它前面的点连边，因此需要可持久化，维护插入的版本信息。每个节点的新版本向旧版本连边就能保证后加的点能够走到所有新加的点。如果不可持久化就可能使得先加的点能通过线段树上的边指向后加的点。 这样操作之后，边数就控制在了$O(n\log n)$级别。总时间复杂度$O(n\log n)与巨大常数？$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define N 100005#define M 20000000using namespace std;char buf[1&lt;&lt;20],*p1,*p2;#define GC (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?0:*p1++)inline void _R(int &amp;x)&#123; char t=GC; while(t&lt;48||t&gt;57)t=GC; for(x=0;t&gt;47&amp;&amp;t&lt;58;t=GC)x=(x&lt;&lt;1)+(x&lt;&lt;3)+t-48;&#125;int n,A[N],B[N],C[N],id[N],D[M],Ans;int tot,rt,ls[M],rs[M];int TOT,LA[M],EN[M],NE[M];int Tot,La[M],En[M],Ne[M];int dfn[M],low[M],be[M],scc,VT;stack&lt;int&gt;S;bool mark[M],use[M];void ADD(int x,int y)&#123; if(!x||!y)return; TOT++; EN[TOT]=y; NE[TOT]=LA[x]; LA[x]=TOT;&#125;void add(int x,int y)&#123; Tot++; En[Tot]=y; Ne[Tot]=La[x]; La[x]=Tot;&#125;int CP(int x)&#123; int o=++tot; ls[o]=ls[x]; rs[o]=rs[x]; return o;&#125;void Ins(int &amp;p,int l,int r,int k,int d)&#123; int o=CP(p);ADD(o,p);p=o; if(l==r)&#123;ADD(p,d);return;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)Ins(ls[p],l,mid,k,d),ADD(p,ls[p]); else Ins(rs[p],mid+1,r,k,d),ADD(p,rs[p]);&#125;void Add(int p,int l,int r,int k,int d)&#123; if(!p)return; if(r&lt;k)&#123;ADD(d,p);return;&#125; int mid=l+r&gt;&gt;1; Add(ls[p],l,mid,k,d); if(k&gt;mid)Add(rs[p],mid+1,r,k,d);&#125;void Work(int x[],int y[])&#123; for(int i=1;i&lt;=n;i++)id[x[i]]=i; for(int i=1;i&lt;=n;i++) &#123; Ins(rt,1,n,y[id[i]],id[i]); Add(rt,1,n,y[id[i]],id[i]); &#125;&#125;void Tarjan(int x)&#123; int i,y; mark[x]=1;S.push(x); dfn[x]=low[x]=++VT; for(i=LA[x];i;i=NE[i]) &#123; y=EN[i]; if(!dfn[y])Tarjan(y),low[x]=min(low[x],low[y]); else if(mark[y])low[x]=min(low[x],dfn[y]); &#125; if(dfn[x]==low[x]) &#123; scc++; do&#123; y=S.top(); S.pop(); mark[y]=0; be[y]=scc; &#125;while(x!=y); &#125;&#125;void DFS(int x)&#123; if(Ans)return; if(use[x])&#123;Ans=x;return;&#125; for(int i=La[x];i;i=Ne[i]) &#123; int y=En[i];D[y]--; if(!D[y])DFS(y); &#125;&#125;int main_main()&#123; int i,j,k; _R(n);tot=n; for(i=1;i&lt;=n;i++)_R(A[i]),_R(B[i]),_R(C[i]); rt=0;Work(A,B); rt=0;Work(B,C); rt=0;Work(A,C); for(i=1;i&lt;=tot;i++)if(!dfn[i])Tarjan(i); for(i=1;i&lt;=tot;i++) for(j=LA[i];j;j=NE[j]) &#123; k=EN[j]; if(be[i]!=be[k])add(be[i],be[k]),D[be[k]]++; &#125; for(i=1;i&lt;=n;i++)use[be[i]]=1; for(i=1;i&lt;=scc;i++)if(!D[i])DFS(i); for(i=1;i&lt;=n;i++)printf("%d\n",be[i]==Ans);&#125;const int main_stack=16; char my_stack[128&lt;&lt;20]; int main() &#123; __asm__("movl %%esp, (%%eax);\n"::"a"(my_stack):"memory"); __asm__("movl %%eax, %%esp;\n"::"a"(my_stack+sizeof(my_stack)-main_stack):"%esp"); main_main(); __asm__("movl (%%eax), %%esp;\n"::"a"(my_stack):"%esp"); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图论</category>
        <category>主席树</category>
        <category>Tarjan</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
</search>
